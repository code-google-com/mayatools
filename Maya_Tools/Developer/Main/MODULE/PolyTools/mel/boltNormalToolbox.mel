
//////////////////////////////////////////////////////////////////////// 
source boltVehicleDisplayManager;
source sceeProcs;

//////////////////////////////////////////////////////////////////////// 
//from boltShaderTools.mel


global proc string[] boltTransformsToShapes(string $transforms[])
{
	string $shapes[] = {};
	for ($transform in $transforms)
	{
		if (objExists($transform))
		{
			string $newShapes[] = `listRelatives -fullPath -type "mesh" $transform`;
			if ($newShapes[0]!="")
			{
				$shapes = `stringArrayCatenate $shapes {$newShapes[0]}`;
			}
		}	
	}
	return $shapes;
}


proc float boltGetTri3DArea(vector $v1, vector $v2, vector $v3)
//uses heron's formula to return area of 3d triangle, given 3 points as vectors
{	
	vector $d1 = $v1 - $v2;
	vector $d2 = $v2 - $v3;
	vector $d3 = $v3 - $v1;
	
	float $e1 = sqrt(($d1.x*$d1.x)+($d1.y*$d1.y)+($d1.z*$d1.z));
	float $e2 = sqrt(($d2.x*$d2.x)+($d2.y*$d2.y)+($d2.z*$d2.z));
	float $e3 = sqrt(($d3.x*$d3.x)+($d3.y*$d3.y)+($d3.z*$d3.z));
	
	float $s = (($e1+$e2+$e3)/2);
	
	float $area = sqrt(($s-$e1)*($s-$e2)*($s-$e3)*$s);
	
	return $area;
}

proc float boltGetPoly3DArea(string $poly)
//returns surface area of a 3d poly by iterating through triangles
//may not work with concave quads
{
	
	string $objName = `match "^[^\.]*" $poly`;
	string $ftv[] = `polyInfo -faceToVertex $poly`;
	string $tokens[];
	tokenize $ftv[0] " :\n\r" $tokens;
	string $verts[] = {};
	for ( $t = 2; $t < `size $tokens`; $t++ )
	{
  		$verts[`size $verts`] = ($objName + ".vtx[" + $tokens[$t] + "]");
	}
	int $noVerts = `size $verts`;
	//get the verts and vertfaces in construction order
		
	float $area3D = 0;
		
	for ($i = 0; $i < $noVerts-2; $i++)
	{
		vector $v1 = `pointPosition -w $verts[$noVerts-1]`;
		vector $v2 = `pointPosition -w $verts[$i]`;
		vector $v3 = `pointPosition -w $verts[$i+1]`;

		float $triArea = `boltGetTri3DArea $v1 $v2 $v3`;
		$area3D = $area3D + $triArea;
	}
	return $area3D;
}

proc int GetNbMeshVerts(string $obj)
{
	if (`nodeType $obj` == "transform")
	{
		string $objs[] = `boltTransformsToShapes {$obj}`;
		$obj = $objs[0];
	}
	if (`objExists $obj`)
	{	
		int $vertCounts[] = `polyEvaluate -v $obj`;
		return $vertCounts[0];
	}
	return 0;
}

proc int sFindItem (string $array[], string $value)
{
	int $i;
	if (`size($array)` > 0) {
		for ($i = 0; $i <= `size($array)`; $i++)
		{
			if ($array[$i] == $value) {
				return $i;
			}
		}
	}
	return -1;
}







global proc boltNorms.GUI()
{
	//source boltShaderTools;
	//source boltVehicleDisplayManager;
	
	global string $gBoltNormalToolboxVFSelection[] = {};
		
	if (`window -exists boltNormalsWindow`) {deleteUI boltNormalsWindow;} 
	//delete the window if it already exists
	
	window -title "Normal Toolbox" -menuBar true -toolbox 1 boltNormalsWindow;
		
		menu -label "Help" -tearOff true -allowOptionBoxes true;
			menuItem -label "WIKI Help Page" -command "showHelp -a \"http://43.193.223.115:8080/mediawiki/index.php/BPT_NormalToolBox\"";

			columnLayout;
				
				
				frameLayout -collapsable 1 -label "Maya Shortcuts" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Smooth Edges" 	-ann "Smooths edges of selected geometry" 		-command "polySoftEdge -a 180 -ch 1";
							button -height 20 -width 100 -recomputeSize 0 -label "Crease Edges" 	-ann "Makes hard edges on selected geometry" 	-command "polySoftEdge -a 0 -ch 1";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Auto Smooth" 	-ann "Automatically smooths selected geometry based on a given angle theshold" 	-command "PolygonSoftenHardenOptions;";
							button -height 20 -width 100 -recomputeSize 0 -label "Flip Normals" 	-ann "Flips the normals of the currently selected polys" -command "polyNormal -normalMode 0 -ch 1";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -recomputeSize 0 -label "Unlock Normals" 		-ann "Can fix smoothing or normal problems with imported objects" 	-command "polyNormalPerVertex -ufn true;";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Selection" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Edge > VFs - Large" -command "boltNorms.EdgeToVF(1)" -ann "Converts edge selection to VFs on the large side of the edge";
							button -height 20 -width 100 -label "Edge > VFs - Small" -command "boltNorms.EdgeToVF(0)" -ann "Converts edge selection to VFs on the small side of the edge";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Poly Loop" -command "boltNorms.PolyLoop(0, 1)" -ann "Selects a loop of polys from an initial poly selection";
							button -height 20 -width 100 -label "Poly Ring" -command "boltNorms.PolyLoop(1, 1)" -ann "Selects a ring of polys from an initial poly selection";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Select Soft" -command "boltNorms.SelectHard(0)" -ann "Selects all soft edges on current object";
							button -height 20 -width 100 -label "Select Hard" -command "boltNorms.SelectHard(1)" -ann "Selects all hard edges on current object";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Lock Normals - VF Selection" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Lock Away From" -command "boltNorms.LockSelectedVFs(1)" -ann "Locks vertex faces away from those currently selected. Results in a smooth vertex";
							button -height 20 -width 100 -label "Lock Towards" -command "boltNorms.LockSelectedVFs(0)" -ann "Locks vertex faces towards those currently selected. Results in a smooth vertex";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Average" -command "boltNorms.AverageSelectedVFs" -ann "Makes all selected VFs point in the same, averaged direction.";
							button -height 20 -width 100 -label "Unlock" -command "boltNorms.UnlockSelectedVFs" -ann "Unlocks the selected VFs or Verts, preserving hard/soft edges.";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Lock Normals - Edge Selection" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Lock To Small Faces" -command "$s=`ls -sl`; boltNorms.EdgeToVF(0); boltNorms.LockSelectedVFs(0); select $s" -ann "Locks vertex faces towards the polys on the small side of the edge";
							button -height 20 -width 100 -label "Lock To Large Faces" -command "$s=`ls -sl`; boltNorms.EdgeToVF(1); boltNorms.LockSelectedVFs(0); select $s" -ann "Locks vertex faces towards the polys on the large side of the edge";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -label "Match seam normals" -command "boltNorms.MatchSeamNormals()" -ann "Given 2 adjacent edge loops on a seam, averages the normals across the seam";
						setParent ..;
					
					
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Lock Normals - Face Selection" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -label "Smooth Bevelled" -command "boltNorms.SmoothBevel(0)" -ann "Function designed to inteligently smooth out beveled edges, while preserving hard edges through the bevel.";
							button -height 20 -width 100 -label "Smooth + Flatten" -command "boltNorms.SmoothFaces()" -ann "Can help to flatten and smooth the shading on flat pannels by locking perimeter normals to the polys on the face.";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -label "Bulge Selected Faces" -command "boltNorms.BulgeSelectedFaces(0.05)" -ann "Bulges normals outwards slightly -improves look of mirrors.";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Lock Normals - Hard Edges" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -label "1. Select VFs to lock" -command "boltNorms.StoreVFSelection()" -ann "Select the VFs that you want to adjust - will result in a hard edge between these VFs and any that are unselected";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -label "2. Select VFs to lock towards" -command "boltNorms.LockTowardsHard()" -ann "Select the VFs that you want to average together, to define the normal for the VFs selected with the above button.";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Mirror" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -label "Mirror Locked Normals + Edges" 		-command "boltNorms.MirrorGUI(0.0005)" -ann "Can mirror from a _L object to corresponding _R object, just selected verts, or from left to right if whole object like a bonnet is selected.";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout -collapsable 1 -label "Back-up" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 3;
							text -l "Save Normals:" -w 88;
							button -height 20 -width 40 -label "All" -command    "boltNorms.BackupGUI(\"ALL\", \"SAVE\")" -ann "Saves a backup of normal data for all objects to disk";
							button -height 20 -width 70 -label "Selected" -command "boltNorms.BackupGUI(\"SL\", \"SAVE\")" -ann "Saves a backup of normal data for selected objects to disk";
						setParent ..;
						rowLayout -numberOfColumns 3;
							text -l "Restore Normals:" -w 88;
							button -height 20 -width 40 -label "All" -command    "boltNorms.BackupGUI(\"ALL\", \"RESTORE\")" -ann "Restores a backup of normal data for all objects from disk";
							button -height 20 -width 70 -label "Selected" -command "boltNorms.BackupGUI(\"SL\", \"RESTORE\")" -ann "Restores a backup of normal data for selected objects from disk";
						setParent ..;
					setParent ..;
				setParent ..;

				frameLayout -collapsable 1 -label "Vertex Normal Display" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 4;
							button -height 20 -width 49 -label "Off" 		-command "boltNorms.NormalDisplay(0, 0.05)" -ann "Turn off vertex normal dispaly";
							button -height 20 -width 49 -label "Small" 	-command "boltNorms.NormalDisplay(1, 0.01)" -ann "Display small vertex normals (needs a wireframe display/overlay mode on)";
							button -height 20 -width 49 -label "Medium" 	-command "boltNorms.NormalDisplay(1, 0.05)" -ann "Display medium vertex normals (needs a wireframe display/overlay mode on)";
							button -height 20 -width 49 -label "Large" 	-command "boltNorms.NormalDisplay(1, 0.1)" -ann "Display large vertex normals (needs a wireframe display/overlay mode on)";
						setParent ..;
					setParent ..;
				setParent ..;

				
				
			setParent ..;					
		
	setParent ..;   
	
	showWindow boltNormalsWindow;
	//display the window
	
	window -e -height 700 -width 200 boltNormalsWindow;

}



global proc boltNorms.Save()
{
}


global proc boltNorms.LockTowardsHard()
{
	global string $gBoltNormalToolboxVFSelection[];
	
	
	string $vfs[] = `ls -sl "*.vtxFace[*][*]"`; 
	string $faces[] = boltNorms.ToFaces($vfs);
	
	if (size($faces)<1) error "No faces to lock towards found";
	if (size($gBoltNormalToolboxVFSelection)<1) error "No VFs to adjust are stored (Use button 1 first)";
	
	print "\nLocking: "; print $gBoltNormalToolboxVFSelection; 
	print "\nTowards: "; print $faces;
	
	boltNorms.LockTo($gBoltNormalToolboxVFSelection, $faces);
}



global proc boltNorms.StoreVFSelection()
{
	global string $gBoltNormalToolboxVFSelection[];
	
	string $vfs[] = `ls -sl "*.vtxFace[*][*]"`; 
	
	$gBoltNormalToolboxVFSelection = $vfs;
}


global proc boltNorms.SmoothHole()
{
	string $vfs[] = `ls -sl "*.vtxFace[*][*]"`; 
	string $faces[] = boltNorms.ToFaces($vfs);
	string $verts[] = boltNorms.ToVerts($vfs);
	
	//get center position of hole
	vector $centerPos = <<0,0,0>>;
	int $count = 0;
	for ($vert in $verts)
	{
		$centerPos += `pointPosition -w $vert`;
		$count ++;
	}
	$centerPos /= $count;
	
	//get average normal for center of hole
	vector $centerNorm = <<0,0,0>>;
	for ($face in $faces)
	{
		$centerNorm += boltNorms.GetFaceNorm($face);
	}
	$centerNorm = unit($centerNorm);
	
	
	
	for ($vert in $verts)
	{
		//get polys on vert outside hole
		string $facesOnVert[] = boltNorms.ToFaces($verts);
		string $outerFacesOnVert[] = boltNorms.StringArrayIntersect($facesOnVert, $faces);
		
		//find furthest point on these polys from center
		float $furthestDist = 0.0;  
		string $furthestVert = "";
		string $vertsToCheck[] = boltNorms.ToVerts($outerFacesOnVert);
		for ($v in $vertsToCheck)
		{
			vector $vpos = `pointPosition -w $v`;
			float $d = mag($centerPos - $vpos);
			if ($d > $furthestDist)
			{
				$furthestDist = $d;
				$furthestVert = $v;
			}
		}
		
		//get the polys that this furthest vert is on
		string $furthestVertPolys[] = boltNorms.ToFaces({$furthestVert});
		$furthestVertPolys = boltNorms.StringArrayIntersect($furthestVertPolys,$outerFacesOnVert);
		
		//get the vector of this far point
		string $furthestVFs[] = boltNorms.GetVertexFaces({$furthestVert},$furthestVertPolys);
		vector $futhestNormal = `polyNormalPerVertex -q -xyz $furthestVFs[0]`;
		
		
		
		//work out relative distance
		vector $vpos = `pointPosition -w $vert`;
		float $d = mag($centerPos - $vpos);
		float $lerpAmount = $d / $furthestDist;
		
		//interpolate between center and far normal. 
		
		vector $normal = boltNorms.LerpVectors($centerNorm,$futhestNormal,$lerpAmount);
		polyNormalPerVertex -xyz ($normal.x) ($normal.y) ($normal.z) $vert;
	
	}
}





global proc boltNorms.SmoothHole2()
{
	string $vfs[] = `ls -sl "*.vtxFace[*][*]"`; 
	string $faces[] = boltNorms.ToFaces($vfs);
	string $verts[] = boltNorms.ToVerts($vfs);
	
	//get center position of hole
	vector $centerPos = <<0,0,0>>;
	int $count = 0;
	for ($vert in $verts)
	{
		$centerPos += `pointPosition -w $vert`;
		$count ++;
	}
	$centerPos /= $count;
	
	//get average normal for center of hole
	vector $centerNorm = <<0,0,0>>;
	for ($face in $faces)
	{
		$centerNorm += boltNorms.GetFaceNorm($face);
	}
	$centerNorm = unit($centerNorm);
	
	
	
	for ($vert in $verts)
	{
		//get polys on vert outside hole
		string $facesOnVert[] = boltNorms.ToFaces($verts);
		string $outerFacesOnVert[] = boltNorms.StringArrayIntersect($facesOnVert, $faces);
		
		
		//get verts not on hole
		string $vertsToCheck[] = boltNorms.ToVerts($outerFacesOnVert);
		$vertsToCheck = stringArrayRemove($verts,$vertsToCheck);
				
		//get average distance of these verts
		float $averageDist = 0.0;
		int $count = 0;
		for ($v in $vertsToCheck)
		{
			vector $vpos = `pointPosition -w $vert`;
			float $d = mag($centerPos - $vpos);
			$averageDist += $d;
			$count ++;
		}
		$averageDist /= $count;
			
		//get average normal
		
		vector $averageNorm = <<0,0,0>>;
		int $count = 0;
		for ($v in $vertsToCheck)
		{
			//get the polys that this furthest vert is on
			string $vertPolys[] = boltNorms.ToFaces({$v});
			$vertPolys = boltNorms.StringArrayIntersect($vertPolys,$outerFacesOnVert);
			//get the vector of this vert
			string $vertVFs[] = boltNorms.GetVertexFaces({$v},$vertPolys);
			vector $normal = `polyNormalPerVertex -q -xyz $vertVFs[0]`;
			$count ++;
			$averageNorm += $normal;
		}
		$averageNorm /= $count;
		
		//work out relative distance
		vector $vpos = `pointPosition -w $vert`;
		float $d = mag($centerPos - $vpos);
		float $lerpAmount = $d / $averageDist;
		
		//interpolate between center and far normal. 
		
		vector $normal = boltNorms.LerpVectors($centerNorm,$averageNorm,$lerpAmount);
		polyNormalPerVertex -xyz ($normal.x) ($normal.y) ($normal.z) $vert;
	
	}
}












global proc vector boltNorms.LerpVectors(vector $v1, vector $v2, float $amount)
//interpolates between two vectors
{
	float $x = $v1.x + ($v2.x - $v1.x) * $amount;
	float $y = $v1.y + ($v2.y - $v1.y) * $amount;
	float $z = $v1.z + ($v2.z - $v1.z) * $amount;
	return <<$x,$y,$z>>;
}




global proc boltNorms.SmoothFaces()
//smooths faces, - border verts are biased to contained polygons, 
//internal verts smoothed and unlocked
{
	string $faces[] = `ls -sl -fl "*.f[*]"`;
	string $vfs[] = boltNorms.ToVFs($faces);
	string $verts[] = boltNorms.ToVerts($faces);
	string $borderVerts[] = `polyListComponentConversion -border -toVertex $faces`;
	$borderVerts = `ls -fl $borderVerts`;
	string $nonBorderVerts[] = stringArrayRemove($borderVerts,$verts);
	
	for ($vert in $borderVerts)
	{
		string $facesOnVert[] = boltNorms.ToFaces({$vert});
 		
 		//get lists of un/selected faces on the vert
		string $unselectedFacesOnVert[] = stringArrayRemove($faces, $facesOnVert);
		string $selectedFacesOnVert[] = stringArrayRemove($unselectedFacesOnVert, $facesOnVert);
		
		boltNorms.LockTo({$vert}, $selectedFacesOnVert);
	}
	
	for ($vert in $nonBorderVerts)
	{
		polyNormalPerVertex -unFreezeNormal 1 $vert;
	}
}

global proc boltNorms.SmoothBevel(int $sharpEnds)
//smooths off bevels
{
	string $faceSelection[] = `ls -sl -fl "*.f[*]"`;
	string $vertSelection[] = boltNorms.ToVerts($faceSelection);
	string $edgeSelection[] = boltNorms.ToEdges($faceSelection);	
	
	for ($vert in $vertSelection)
	{
		//print "\nprocessing vert: "; print $vert;
		
		string $facesOnVert[] = boltNorms.ToFaces({$vert});
 		string $edgesOnVert[] = boltNorms.ToEdges({$vert});

		//get lists of un/selected faces on the vert
		string $unselectedFacesOnVert[] = stringArrayRemove($faceSelection, $facesOnVert);
		string $selectedFacesOnVert[] = stringArrayRemove($unselectedFacesOnVert, $facesOnVert);
		
		//prevents a crash if no unselected faces are found  
		if (size($unselectedFacesOnVert) == 0)
		{
			warning ($vert + " has no unselected faces attached to it. Could not smooth bevel here!");
		}
		else
		{
			//get lists of un/selected edges on the vert
			string $unselectedEdgesOnVert[] = stringArrayRemove($edgeSelection, $edgesOnVert);
			string $selectedEdgesOnVert[] = stringArrayRemove($unselectedEdgesOnVert, $edgesOnVert);
        	
			//get lists of un/selected vfs on the vert
			string $unselectedVFs[] = boltNorms.GetVertexFaces({$vert}, $unselectedFacesOnVert);
			string $selectedVFs[] 	= boltNorms.GetVertexFaces({$vert}, $selectedFacesOnVert);
			
			//if this is an end vert
			if (size($selectedFacesOnVert) == 1)
			{
				//print "\nEnd vert detected!";
				
				string $facesToLockTo[] = {};
				
				//check every face on the vert
				for ($face in $facesOnVert)
				{
					//check for faces containing 2 or more selected verts
					string $vertsOnFace[] = boltNorms.ToVerts({$face});
					string $selectedVertsOnFace[] = boltNorms.StringArrayIntersect($vertsOnFace,$vertSelection);
					if (size($selectedVertsOnFace)>=2)
					{
						//check for faces where one of the selected verts is on at least 2 selected polys
						int $use = 0;
						for ($v in $selectedVertsOnFace)
						{
							string $facesOnV[] = boltNorms.ToFaces({$v});
							string $selectedFacesOnV[] = boltNorms.StringArrayIntersect($facesOnV,$faceSelection);
							if (size($selectedFacesOnV)>=2) $use = 1;
						}
						if ($use==1) $facesToLockTo[size($facesToLockTo)] = $face;
					}
				}
				
				$facesToLockTo = stringArrayRemove($selectedFacesOnVert,$facesToLockTo);
				
				//work out which polys to adjust
				string $facesToLock[] = stringArrayCatenate($selectedFacesOnVert,$facesToLockTo);
				string $vfsToLock[] = boltNorms.GetVertexFaces({$vert}, $facesToLock);
				
				boltNorms.LockTo($vfsToLock, $facesToLockTo);
			}
			//locking command for all other verts
			else
			{
				//print "\nNon end vert detected!";
				
				//find the internal edge (the one with two selected polys)
				string $internalEdge = "";
				for ($edge in $selectedEdgesOnVert)
				{
					string $edgeFaces[] = boltNorms.ToFaces({$edge});
					string $selectedEdgeFaces[] = boltNorms.StringArrayIntersect($selectedFacesOnVert,$edgeFaces);
					if (size($selectedEdgeFaces)==2) $internalEdge = $edge;
				}
				
				if (boltNorms.IsEdgeHard($internalEdge))
				{
					//print ("\nHard internal edge found: " + $internalEdge);
					
					//store all the faces from 1 smoothing group
					string $faceGroup1[] = {$selectedFacesOnVert[0]};
					
					//list of edges to fan through, looking for crease
					string $edgesToFan[] = stringArrayRemove({$internalEdge},$edgesOnVert);
					
					string $edgesOnLastFace[] = boltNorms.ToEdges({$faceGroup1[size($faceGroup1)-1]});
					string $nextEdge[] = boltNorms.StringArrayIntersect($edgesToFan,$edgesOnLastFace);
					string $nextPolys[] = boltNorms.ToFaces($nextEdge);
					$nextPolys = stringArrayRemove($faceGroup1,$nextPolys);
					$faceGroup1[size($faceGroup1)] = $nextPolys[0];
					$edgesToFan = stringArrayRemove($nextEdge,$edgesOnVert);
					
					for ($i=1;$i<20;$i++)
					{
						$edgesOnLastFace = boltNorms.ToEdges({$faceGroup1[size($faceGroup1)-1]});
						$nextEdge = boltNorms.StringArrayIntersect($edgesToFan,$edgesOnLastFace);
						
						if (boltNorms.IsEdgeHard($nextEdge[0])) break;
											
						string $nextPolys[] = boltNorms.ToFaces($nextEdge);
						$nextPolys = stringArrayRemove($faceGroup1,$nextPolys);
						$faceGroup1[size($faceGroup1)] = $nextPolys[0];
						$edgesToFan = stringArrayRemove($nextEdge,$edgesOnVert);
						
						if (size($edgesToFan) == 0) break;
					}
					
					string $faceGroup2[] = stringArrayRemove($faceGroup1,$facesOnVert);
					
					
					//set group 1
					string $vfsToLock[] = boltNorms.GetVertexFaces({$vert}, $faceGroup1);
					string $facesToLockTo[] = stringArrayRemove($selectedFacesOnVert,$faceGroup1);
					boltNorms.LockTo($vfsToLock, $facesToLockTo);
					
					//print ("\nVERT: " + $vert);
					//print "\nVFs to lock: "; print $vfsToLock;
					//print "\nfaces to lock to: "; print $facesToLockTo; 
					
					//set group 2
					$vfsToLock = boltNorms.GetVertexFaces({$vert}, $faceGroup2);
					string $facesToLockTo2[] = stringArrayRemove($selectedFacesOnVert,$faceGroup2);
					
					//prevent trying to lock to no faces - can happen if out side of bevel has no hard edge.
					if (size($facesToLockTo2)==0) $facesToLockTo2 = $facesToLockTo;
					
					boltNorms.LockTo($vfsToLock, $facesToLockTo2);
					
					//print "\nVFs to lock: "; print $vfsToLock;
					//print "\nfaces to lock to: "; print $facesToLockTo2;
					
					
				}
				else
				{
					//print "\nSetting a normal normal";
					
					boltNorms.LockTo({$vert}, $unselectedFacesOnVert);
				}
			} 
		}
	}
}




global proc boltNorms.BulgeSelectedFaces(float $amount)
//used to improve reflections on flat mirrors etc.
{
	string $faces[] = `ls -sl -fl "*.f[*]"`;
	string $verts[] = boltNorms.ToVerts($faces);
	string $vfs[] = boltNorms.ToVFs($faces);
	
	//get center of selection
	vector $center = <<0,0,0>>;
	int $count = 0;
	for ($vert in $verts)
	{
		vector $pos = `pointPosition -w $vert`;
		$center += $pos;
		$count ++;
	}
	$center = $center / $count;
	
	//need to store all original positions first before we tweak, otherwise results get skewed
	vector $oldNormals[] = {};
	for ($vf in $vfs)
	{
		$oldNormals[size($oldNormals)] = `polyNormalPerVertex -q -xyz $vf`;
	}
	
	//calculate the new normals
	for ($i=0;$i<size($vfs);$i++)
	{
		string $v[] = boltNorms.ToVerts({$vfs[$i]});
		vector $pos = `pointPosition -w $v[0]`;
		vector $extreme = unit($pos - $center);
		vector $new = $oldNormals[$i]*(1-$amount) + $extreme*$amount;
		polyNormalPerVertex -xyz ($new.x) ($new.y) ($new.z) $vfs[$i];
	}
}






global proc boltNorms.LockTo(string $vfs[], string $faces[])
//locks the specified vfs (or a single vert) to the average normal of the specified faces
{
	//don't do anything if no faces were supplied - prevents zero normals being applied
	if (size($faces) == 0) return;
	
	vector $normal = <<0,0,0>>;
	for ($face in $faces)
	{
		$normal += boltNorms.GetFaceNorm($face);
	}
	$normal = unit($normal);

	for ($vf in $vfs)
	{
		polyNormalPerVertex -xyz ($normal.x) ($normal.y) ($normal.z) $vf;
	}
}




global proc boltNorms.LockSelectedVFs(int $away)
{
	string $vfSelection[] = `ls -sl -fl "*.vtxFace[*][*]"`; 
	string $vertSelection[] = boltNorms.ToVerts($vfSelection);

	for ($vert in $vertSelection)
	{
		string $vfsOnVert[] = boltNorms.ToVFs({$vert});
		
		string $unselectedVFsOnVert[] = stringArrayRemove($vfSelection, $vfsOnVert);
		string $selectedVFsOnVert[] = stringArrayRemove($unselectedVFsOnVert, $vfsOnVert);
		
		string $lockTowardsVFs[];
		if ($away == 1) $lockTowardsVFs = $unselectedVFsOnVert;
		if ($away == 0) $lockTowardsVFs = $selectedVFsOnVert;
		
		string $lockTowardsFaces[] = boltNorms.ToFaces($lockTowardsVFs);
 		
 		print "\n$vert = "; print $vert;
 		print "\n$lockTowardsFaces = "; print $lockTowardsFaces;
 		
 		vector $normal = <<0,0,0>>;
			
		for ($face in $lockTowardsFaces)
		{
			$normal += boltNorms.GetFaceNorm($face);
		}
		$normal = unit($normal);
			
		polyNormalPerVertex -xyz ($normal.x) ($normal.y) ($normal.z) $vert;
 	}
}

global proc boltNorms.AverageSelectedVFs()
{
	string $vfSelection[] = `ls -sl "*.vtxFace[*][*]"`; 
	string $faceSelection[] = boltNorms.ToFaces($vfSelection);
	string $edges[] = boltNorms.ToEdges($vfSelection);
	
	//record soft edges, as they get corrupted later on
	string $softEdges[] = {};
	for ($edge in $edges)
	{
		if (boltNorms.IsEdgeHard($edge) == 0)
		{
			$softEdges[size($softEdges)] = $edge;
		}
	}
	
	//set everything to the average normal
	vector $normal = <<0,0,0>>;
	for ($face in $faceSelection)
	{
		$normal += boltNorms.GetFaceNorm($face);
	}
	$normal = unit($normal);
	polyNormalPerVertex -xyz ($normal.x) ($normal.y) ($normal.z) $vfSelection;

	//restore soft/hard edges
	
	if (size($softEdges) > 0)
	{
		polySoftEdge -a 180 -ch 1 $softEdges;
	}
	
	select -cl;
	select $vfSelection;
}

global proc boltNorms.AverageSelectedVFs2()
{
	string $vfSelection[] = `ls -sl "*.vtxFace[*][*]"`; 
	string $faceSelection[] = boltNorms.ToFaces($vfSelection);
	string $edges[] = boltNorms.ToEdges($vfSelection);
	string $verts[] = boltNorms.ToVerts($vfSelection);
	
	//record soft edges, as they get corrupted later on
	string $softEdges[] = {};
	for ($edge in $edges)
	{
		if (boltNorms.IsEdgeHard($edge) == 0)
		{
			$softEdges[size($softEdges)] = $edge;
		}
	}
	
	//set everything to the average normal
	vector $normal = <<0,0,0>>;
	for ($face in $faceSelection)
	{
		$normal += boltNorms.GetFaceNorm($face);
	}
	$normal = unit($normal);
	polyNormalPerVertex -xyz ($normal.x) ($normal.y) ($normal.z) $verts;

	//restore soft/hard edges
	
	if (size($softEdges) > 0)
	{
		//polySoftEdge -a 180 -ch 1 $softEdges;
	}
	
	select -cl;
	select $vfSelection;
}

global proc boltNorms.UnlockSelectedVFs()
//unlocks normals, but preserves soft edges, unlike maya's default command
{
	string $sel[] = `ls -sl`;
	string $vfs[] = boltNorms.ToVFs($sel);
	string $edges[] = boltNorms.ToEdges($sel);
	
	//record soft edges, as they get corrupted later on
	string $softEdges[] = {};
	for ($edge in $edges)
	{
		if (boltNorms.IsEdgeHard($edge) == 0)
		{
			$softEdges[size($softEdges)] = $edge;
		}
	}
		
	polyNormalPerVertex -ufn true $vfs;

	if (size($softEdges) > 0)
	{
		polySoftEdge -a 180 -ch 1 $softEdges;
	}
	
	select -cl;
	select $sel;
}

global proc boltNorms.SelectHard(int $hard)
//selects hard/soft edges depending on flag
{
	string $sel[] = `ls -sl -type "mesh" -type "transform"`;
	$sel = boltTransformsToShapes($sel);
	
	string $newSel[] = {};
	
	for ($shape in $sel)
	{
		string $edges[] = boltNorms.ToEdges({$shape});
		for ($edge in $edges)
		{
			if (boltNorms.IsEdgeHard($edge) == $hard)
			{
				$newSel[size($newSel)] = $edge;
			}
		}
	}
	
	select -cl;
	select $newSel;
}



global proc int boltNorms.IsEdgeHard(string $edge)
{
	string $edgeInfo[] = `polyInfo -ev $edge`;
	if (`endsWith $edgeInfo[0] "Hard\n"`) return 1;
	return 0;
}







global proc string[] boltNorms.GetVertexFaces(string $verts[], string $faces[])
//given a list of verts and faces, converts to vfs
{
	string $vfs[] = {};	
	string $base = `match "^[^\.]*" $verts[0]`;
	
	for ($face in $faces)
	{
		string $faceNo = `match "\\[.*" $face`;
		for ($vert in $verts)
		{
			string $vertNo =  `match "\\[.*" $vert`;		
			$vfs[size($vfs)] = ($base + ".vtxFace" + $vertNo + $faceNo);
		}
	}
	
	return $vfs;
}
 


global proc vector boltNorms.GetFaceNorm( string $poly )
{
  vector $normal;
  string $polyInfoResult[] = `polyInfo -fn $poly`; 

  string $tokens[];
  int $numTokens = `tokenize $polyInfoResult[0] " " $tokens`;

  // Make sure we're looking at polyInfo data:
  if ( ( $numTokens > 3 ) && ( $tokens[0] == "FACE_NORMAL" ) )
  {
    // Maya performs data-type conversion here.
    float $x = ($tokens[$numTokens-3]);
    float $y = ($tokens[$numTokens-2]);
    float $z = ($tokens[$numTokens-1]);

    $normal = << $x, $y, $z >>;

    // Normalize it.
    $normal = `unit $normal`;
  }
  // Return it.
  return $normal;
}


global proc boltNorms.EdgeToVFOLD(int $side)
//selects vertex faces on one side of an edge selection 
// $side 0 = small side, $side 1 - large side
{
	string $edges[] = `ls -sl -fl "*.e[*]"`;
	string $verts[] = `polyListComponentConversion -toVertex $edges`;	
	$verts = `ls -fl $verts`;
	string $faces[] = `polyListComponentConversion -toFace $verts`;
	$faces = `ls -fl $faces`;
	
	print "\nInitial Face List"; print $faces;
	
	//check that edges are continuous
	string $endEdges[] = {};
	for ($edge in $edges)
	{
		string $adjacentEdges[] = `polyListComponentConversion -toVertex $edge`;
		string $adjacentEdges[] = `polyListComponentConversion -toEdge $adjacentEdges`;
		$adjacentEdges = `ls -fl $adjacentEdges`;
		string $unselectedAdjacentEdges[] = stringArrayRemove($edges, $adjacentEdges);
		
		//record end edges
		if ( size($unselectedAdjacentEdges)+2 == size($adjacentEdges) )
		{
			$endEdges[size($endEdges)] = $edge;
		}
		
		if ( size($unselectedAdjacentEdges)+3 < size($adjacentEdges) )
		{
			error "Invalid edge selection - selection must be linear. More than 2 edges per vert detected";
		}
		
		//check that all edges have 2 polys (not 1 or 3+)
		string $edgePolys[] = `polyListComponentConversion -toFace $edge`;
		$edgePolys = `ls -fl $edgePolys`;
		if (size($edgePolys) == 1) error "Invalid edge selection - open edge found";
		if (size($edgePolys) > 2) error "Invalid edge selection - non manifold edge found";
		
	}
	
	if (size($endEdges) > 2)
	{
		error "invalid edge selection - more than 2 open edges detected. Selection must be linear or a loop."; 
	}
		
	//get ordered list of polies surrounding the edge
	
	print "\n END EDGES:";
	print $endEdges;
	
	string $currentFace = $faces[0];
	string $orderedFaceList[] = {$faces[0]};
	
	
	for ($i=0; $i<size($faces); $i++)
	{
	
		//get list of all adjacent polys - but not the one on other side of selected edge
		string $adjacentEdges[] = `polyListComponentConversion -toEdge $currentFace`;
		$adjacentEdges = `ls -fl $adjacentEdges`;
		$adjacentEdges = stringArrayRemove($edges, $adjacentEdges);
		string $adjacentPolys[] = `polyListComponentConversion -toFace $adjacentEdges`;
		$adjacentPolys = `ls -fl $adjacentPolys`;
		
		for ($poly in $adjacentPolys)
		{
			//poly is in the face list
			if (stringArrayContains($poly, $faces))
			{
				//but not already in the ordered list
				if (!(stringArrayContains($poly, $orderedFaceList)))
				{
					$orderedFaceList[size($orderedFaceList)] = $poly;
					$currentFace = $poly;
					break; //prevent more than 1 polygon!
				}
			}
		}
	}
	print "\nFaceList:"; print $orderedFaceList;
	
	string $faces1[] = {};
	string $faces2[] = {};
	
	string $endVerts[] = {};
	
	//if all faces are selected, decide where to split the list
	if (size($orderedFaceList) <= size($faces))
	{
		//get end verts
		
		print "\nGetting end verts...";
		
		//get shortlist of 4 possible verts
		string $posEndVerts[] = `polyListComponentConversion -toVertex $endEdges`;
		$posEndVerts = `ls -fl $posEndVerts`;
		
		print "\nPos End verts are"; print $posEndVerts;
		
		for ($vert in $posEndVerts)
		{
			//get edges on each vert
			string $vertEdges[] = `polyListComponentConversion -toEdge $vert`;
			$vertEdges = `ls -fl $vertEdges`;
			
			//remove selected edges
			string $unselectedVertEdges[] = stringArrayRemove($edges, $vertEdges);
			
			//record end verts - verts with only 1 selected edge on them
			if ( size($unselectedVertEdges)+1 == size($vertEdges) )
			{
				$endVerts[size($endVerts)] = $vert;
			}
		}
		
		print "\nEnd verts are"; print $endVerts;
		
		if (size($endVerts)!=2)
		{
			print $endVerts;
			error "wrong number of end verts found";
		}
		
		string $endPolys[] = `polyListComponentConversion -toFace $endVerts`;
		$endPolys = `ls -fl $endPolys`;
		
		string $edgePolys[] = `polyListComponentConversion -toFace $edges`; 
		$edgePolys = `ls -fl $edgePolys`;
		
		$endPolys = stringArrayRemove($edgePolys, $endPolys);
		$orderedFaceList = stringArrayRemove($endPolys, $orderedFaceList);
		
		string $endPolys1[] = `polyListComponentConversion -toFace $endEdges[0]`;
		$endPolys1 = `ls -fl $endPolys1`;
		string $endPolys2[] = `polyListComponentConversion -toFace $endEdges[1]`;
		$endPolys2 = `ls -fl $endPolys2`;
		
		int $poly1 = sFindItem($orderedFaceList, $endPolys1[0]);
		int $poly2 = sFindItem($orderedFaceList, $endPolys1[1]);
		int $poly3 = sFindItem($orderedFaceList, $endPolys2[0]);
		int $poly4 = sFindItem($orderedFaceList, $endPolys2[1]);
		
		print "\nFaceList:"; print $orderedFaceList;
		
		print "\nPOLYS:";
		print $poly1;print $poly2;print $poly3;print $poly4;
		
		
		int $startPos = $poly1;
		if ($poly2 == ($poly1+1)) $startPos = $poly2;
		if ($poly2 == 0) $startPos = $poly2;
		
		int $endPos = $poly3;
		if ($poly4 == ($poly3-1)) $endPos = $poly4;
		if ($poly4 == size($orderedFaceList)-1) $endPos = $poly4;
		
		if ($startPos <= $endPos)
		{
			for ($i=$startPos; $i<$endPos+1; $i++)
			{
				$faces1[size($faces1)] = $orderedFaceList[$i];
			}
		}
		if ($startPos > $endPos)
		{
			for ($i=$startPos; $i<size($orderedFaceList); $i++)
			{
				$faces1[size($faces1)] = $orderedFaceList[$i];
			}
			for ($i=0; $i<$endPos+1; $i++)
			{
				$faces1[size($faces1)] = $orderedFaceList[$i];
			}
		}
		
	}
	//case for a closed loop
	else 
	{
		$faces1 = $orderedFaceList;
	}
	
	//create other faces
	$faces2 = stringArrayRemove($faces, $faces1);
	
	string $vfs[] = boltNorms.GetVertexFaces($verts, $faces1);
	select -cl;
	select $vfs;
}





global proc boltNorms.EdgeToVF(int $side)
//selects vertex faces on one side of an edge selection 
// $side 0 = small side, $side 1 - large side
{
	string $edges[] = `ls -sl -fl "*.e[*]"`;
	string $verts[] = `polyListComponentConversion -toVertex $edges`;	
	$verts = `ls -fl $verts`;
	string $faces[] = `polyListComponentConversion -toFace $verts`;
	$faces = `ls -fl $faces`;
	
	//check that all edges have 2 polys (not 1 or 3+)
	for ($edge in $edges)
	{ 
		string $edgePolys[] = `polyListComponentConversion -toFace $edge`;
		$edgePolys = `ls -fl $edgePolys`;
		if (size($edgePolys) == 1) error "Invalid edge selection - open edge found";
		if (size($edgePolys) > 2) error "Invalid edge selection - non manifold edge found";
	}
	
	//check for end verts and that the selection is valid
	string $endVerts[] = {};
	for ($vert in $verts)
	{
		string $adjacentEdges[] = boltNorms.ToEdges({$vert});
		string $selectedAdjacentEdges[] = boltNorms.StringArrayIntersect($edges, $adjacentEdges);
		
		//record end edges
		if ( size($selectedAdjacentEdges) == 1 )
		{
			$endVerts[size($endVerts)] = $vert;
		}
		
		//check for t junctions etc
		if ( size($selectedAdjacentEdges) >= 3 )
		{
			error "Invalid edge selection - selection must be linear. More than 2 edges per vert detected";
		}
	}
	if (size($endVerts) > 2)
	{
		error "invalid edge selection - more than 2 open edges detected. Selection must be linear or a loop."; 
	}
	//print "\nEnd Verts found: "; print $endVerts;
	
	//pick a start and end vert - depending whether or not a closed loop is selected.
	string $nextVert = $verts[0];
	if (size($endVerts)==2) $nextVert = $endVerts[0];
	string $endVert = "";
	if (size($endVerts)==2) $endVert = $endVerts[1];
	
	//the last edge that was processed
	string $lastEdge = "";
	string $lastVert = "";
	
	//the two seperated face lists
	string $faces1[] = {};
	string $faces2[] = {};
	
	//get the 1st edge to process
	string $nextEdges[] = boltNorms.ToEdges({$nextVert});
	$nextEdges = boltNorms.StringArrayIntersect($nextEdges,$edges);
	$nextEdges = stringArrayRemove({$lastEdge}, $nextEdges);
	string $nextEdge = $nextEdges[0];
	
	//start off the face lists
	string $edgePolys[] = boltNorms.ToFaces({$nextEdge});
	$faces1[0]=$edgePolys[0];
	$faces2[0]=$edgePolys[1];
	
	/////////////////////////////////////////////////////////////////loop
	
	int $emergencyStop2 = 0;
	while (boltNorms.DoesEdgeContainVert($nextEdge, $endVert)==0)
	{
		//needed to get the first iteration of the loop to run if closed loop is selected
		if ($endVert == "") $endVert = $verts[0];
				
		//get the next vert to process
		$lastVert = $nextVert;
		string $nextVerts[] = boltNorms.ToVerts({$nextEdge});
		$nextVerts = stringArrayRemove({$lastVert}, $nextVerts);
		$nextVert = $nextVerts[0];
	
		//get the next edge in the selection
		$lastEdge = $nextEdge;
		string $nextEdges[] = boltNorms.ToEdges({$nextVert});
		$nextEdges = boltNorms.StringArrayIntersect($nextEdges,$edges);
		$nextEdges = stringArrayRemove({$lastEdge}, $nextEdges);
		$nextEdge = $nextEdges[0];

		//keep storing polys until we come to one on the next edge - list 1
		int $emergencyStop = 0;
		while (boltNorms.DoesPolyContainEdge($faces1[size($faces1)-1], $nextEdge)==0)
		{
			//get the shared edge of the last poly and next vert, but not on the selected edges / poly, or second to last poly 
			string $notPoly = "";
			if (size($faces1)-2 >= 0) $notPoly = $faces1[size($faces1)-2];			
			string $sharedEdge = boltNorms.GetSharedEdge($faces1[size($faces1)-1], $nextVert, $edges, $notPoly);
			
			//get + store the next poly on this side
			string $nextPolys[] = boltNorms.ToFaces({$sharedEdge});
			$nextPolys = stringArrayRemove({$faces1[size($faces1)-1]},$nextPolys);
			$faces1[size($faces1)] = $nextPolys[0];
			
			$emergencyStop++; if ($emergencyStop > 50) error "infinite loop 1 aborted";
		}
		
		//keep storing polys until we come to one on the next edge - list 2
		int $emergencyStop = 0;
		while (boltNorms.DoesPolyContainEdge($faces2[size($faces2)-1], $nextEdge)==0)
		{
			//get the shared edge of the last poly and next vert, but not on the selected edges / poly, or second to last poly 
			string $notPoly = "";
			if (size($faces2)-2 >= 0) $notPoly = $faces2[size($faces2)-2];			
			string $sharedEdge = boltNorms.GetSharedEdge($faces2[size($faces2)-1], $nextVert, $edges, $notPoly);
			
			//get + store the next poly on this side
			string $nextPolys[] = boltNorms.ToFaces({$sharedEdge});
			$nextPolys = stringArrayRemove({$faces2[size($faces2)-1]},$nextPolys);
			$faces2[size($faces2)] = $nextPolys[0];
			
			$emergencyStop++; if ($emergencyStop > 50) error "infinite loop 1 aborted";
		}
		
		$emergencyStop2++; if ($emergencyStop2 > 1000) error "infinite loop 2 aborted";
	}
	

	//get surface area of each poly list
	float $area1 = 0;
	for ($poly in $faces1)
	{
		$area1 += boltGetPoly3DArea($poly);
	}
	float $area2 = 0;
	for ($poly in $faces2)
	{
		$area2 += boltGetPoly3DArea($poly);
	}

	//work out which collection of faces to select
	string $vfs[] = {};
	if (($side == 1) && ($area1 > $area2)) $vfs = boltNorms.GetVertexFaces($verts, $faces1);
	if (($side == 1) && ($area2 > $area1)) $vfs = boltNorms.GetVertexFaces($verts, $faces2);
	if (($side == 0) && ($area1 > $area2)) $vfs = boltNorms.GetVertexFaces($verts, $faces2);
	if (($side == 0) && ($area2 > $area1)) $vfs = boltNorms.GetVertexFaces($verts, $faces1);
	
	select -cl;
	select $vfs;
}




global proc boltNorms.PolyLoop(int $ring, int $constrain)
//selects a loop or ring of polys
{
	$sel = `ls -sl -fl "*.f[*]"`;
	string $ringEdges[] = {};
	for ($face in $sel)
	{
		string $edge = "";
		if ($ring==0) $edge = boltNorms.GetShortestEdgeOnFace($face); 
		if ($ring==1) $edge = boltNorms.GetLongestEdgeOnFace($face);
		
		int $edgeNo = match ("[0-9]+", match("[0-9]+.$",$edge));
		string $obj = `match "^[^\.]*" $edge`;
		
		string $thisRing[] = `polySelect -noSelection -asSelectString -edgeRing $edgeNo $obj`;
		$ringEdges = stringArrayCatenate($ringEdges,$thisRing);
	}
	$ringEdges = stringArrayRemoveDuplicates($ringEdges);
	string $polys[] = boltNorms.ToFaces($ringEdges);
	
	//if the selection should be constrained, and only 2 polys selected
	if ( ($constrain==1) && (size($sel)==2) )
	{
		// build lists from the first selected poly, heading in both directions, until second selected poly is reached
		
		
		
		string $sortedPolyList1[] = {};
		string $sortedPolyList2[] = {};
		$sortedPolyList1[0] = $sel[0];
		$sortedPolyList2[0] = $sel[0];
		
		
		for ($i=0; $i<size($polys); $i++)
		{
			string $poly1 = $sortedPolyList1[size($sortedPolyList1)-1];
			string $poly2 = $sortedPolyList2[size($sortedPolyList2)-1];
		
			if ($poly1 != $sel[1])
			{
				string $adjacentPolys[] = boltNorms.ToVerts({$poly1});
				$adjacentPolys = boltNorms.ToFaces($adjacentPolys);
				$adjacentPolys = stringArrayRemove($sortedPolyList1,$adjacentPolys);
				string $adjacentSelPolys[] = boltNorms.StringArrayIntersect($adjacentPolys, $polys);
				if (size($adjacentSelPolys) > 0) $sortedPolyList1[size($sortedPolyList1)] = $adjacentSelPolys[0];
			}
			if ($poly2 != $sel[1])
			{
				string $adjacentPolys[] = boltNorms.ToVerts({$poly2});
				$adjacentPolys = boltNorms.ToFaces($adjacentPolys);
				$adjacentPolys = stringArrayRemove($sortedPolyList2,$adjacentPolys);
				string $adjacentSelPolys[] = boltNorms.StringArrayIntersect($adjacentPolys, $polys);
				if (size($adjacentSelPolys) > 1) $sortedPolyList2[size($sortedPolyList2)] = $adjacentSelPolys[1];
				if (size($adjacentSelPolys) == 1) $sortedPolyList2[size($sortedPolyList2)] = $adjacentSelPolys[0];
			}
		}
		
		// if both lists contain the end poly choose shortest.
		
		if ( stringArrayContains($sel[1], $sortedPolyList1) && stringArrayContains($sel[1], $sortedPolyList2) )
		{
		
			if (size($sortedPolyList1) < size($sortedPolyList2)) 
			{
				$polys = $sortedPolyList1;
			}
			else
			{
				$polys = $sortedPolyList2;
			}
		}
		
		if ( stringArrayContains($sel[1], $sortedPolyList1) && !(stringArrayContains($sel[1], $sortedPolyList2)) )
		{
			$polys = $sortedPolyList1;
		}
		
		if ( !(stringArrayContains($sel[1], $sortedPolyList1)) && stringArrayContains($sel[1], $sortedPolyList2) )
		{
			$polys = $sortedPolyList2;
		}
		
	}
		
	select -cl;
	select $polys;
	
}

global proc string boltNorms.GetShortestEdgeOnFace(string $face)
//returns the shortest edge on a face
{
	string $edges[] = boltNorms.ToEdges({$face});
	string $shortestEdge = "";
	float $shortestLength = 10000000.0;
	for ($edge in $edges)
	{
		float $length = boltNorms.GetEdgeLength($edge);
		if ($length < $shortestLength)
		{
			$shortestLength = $length;
			$shortestEdge = $edge;
		}
	}
	return $shortestEdge;
}

global proc string boltNorms.GetLongestEdgeOnFace(string $face)
//returns the longest edge on a face
{
	string $edges[] = boltNorms.ToEdges({$face});
	string $longestEdge = "";
	float $longestLength = 0.0;
	for ($edge in $edges)
	{
		float $length = boltNorms.GetEdgeLength($edge);
		if ($length > $longestLength)
		{
			$longestLength = $length;
			$longestEdge = $edge;
		}
	}
	return $longestEdge;
}


global proc float boltNorms.GetEdgeLength(string $edge)
//returns the length of the specified edge
{
	string $verts[] = boltNorms.ToVerts({$edge});
	if (size($verts) != 2) return 0;
	vector $v1 = `pointPosition -world $verts[0]`;
	vector $v2 = `pointPosition -world $verts[1]`;
	return mag($v1-$v2);
}



global proc boltNorms.MirrorGUI(float $tol)
{
	//float $tol = 0.0005; // hard coded tollerance
	
	//get selection, and make sure we use shapes, not transforms
	$sel = `ls -sl`;
	if (size($sel) == 1)
	{
		if (`nodeType $sel[0]` == "transform")
		{
			string $shape[] = `listRelatives -children -type "mesh" $sel[0]`;
			$sel[0] = $shape[0];
		}
	}
		
	string $verts[] = boltNorms.ToVerts($sel);

	string $obj = `match "^[^\.]*" $verts[0]`;
	
	//quit if multiple objects selected
	for ($v in $verts)
	{
		if (`match "^[^\.]*" $v` != $obj)
		{
			error "Please select verts from a single object to mirror at once";
		}
	}
	
	//work out the object to mirror to.
	string $L[] = {"_FL", "_FL1", "_FL2", "_BL", "_BL1", "_BL2", "_L", "_L1", "_L2", "_L3", "_L4", "_BFL", "_BBL", "_TFL", "_TBL", "_TFL1", "_TFL2", "_TBL1", "_TBL2", "_BFL1", "_BFL2", "_BBL1", "_BBL2", "_LEFT"};
	string $R[] = {"_FR", "_FR1", "_FR2", "_BR", "_BR1", "_BR2", "_R", "_R1", "_R2", "_R3", "_R4", "_BFR", "_BBR", "_TFR", "_TBR", "_TFR1", "_TFR2", "_TBR1", "_TBR2", "_BFR1", "_BFR2", "_BBR1", "_BBR2", "_RIGHT"};
	string $mirroredObj = $obj;
	for ($i = 0; $i < size($L); $i++)
	{
		if (`match ($L[$i]+"$") $obj`  == $L[$i]) 	$mirroredObj = `substitute $L[$i]  $obj $R[$i]`;
		if (`match ($R[$i]+"$") $obj`  == $R[$i]) 	$mirroredObj = `substitute $R[$i]  $obj $L[$i]`;
		if (`match ($L[$i]+"_") $obj`  == ($L[$i]+"_")) $mirroredObj = `substitute ($L[$i]+"_")  $obj ($R[$i]+"_")`;
		if (`match ($R[$i]+"_") $obj`  == ($R[$i]+"_")) $mirroredObj = `substitute ($R[$i]+"_")  $obj ($L[$i]+"_")`;
		if (`match ($L[$i]+"Shape") $obj`  == ($L[$i]+"Shape")) $mirroredObj = `substitute ($L[$i]+"Shape")  $obj ($R[$i]+"Shape")`;
		if (`match ($R[$i]+"Shape") $obj`  == ($R[$i]+"Shape")) $mirroredObj = `substitute ($R[$i]+"Shape")   $obj ($L[$i]+"Shape")`;
	}
	$obj = $mirroredObj;
	
	//if a both sides of a whole object are selected, then mirror left to right 
	int $numVerts[] = `polyEvaluate -vertex $obj`;
	if (($mirroredObj == $obj) && (size($verts) == $numVerts[0]))
	{
		string $leftVerts[] = {};
		for ($v in $verts)
		{
			vector $pos = `pointPosition -w $v`;
			if ($pos.x > $tol)
			{
				$leftVerts[size($leftVerts)] = $v;
			}
		}
		$verts = $leftVerts;
	}
	
	print ("\nMirrored obj: " + $obj);
	
	boltNorms.MirrorNorms($verts, $obj, $tol);
}



global proc boltNorms.MirrorNorms(string $verts[], string $obj, string $tol)
//mirrors the normals on $verts, to $obj. 
{
	global string $gBoltNormsVertSelection[];
	global string $gBoltNormsVertLookup[];
	
	$gBoltNormsVertSelection = $verts;
	$gBoltNormsVertLookup = {};
	
	int $count = 20;
	int $count2 = 0;
	
	string $sel[] = `ls -sl`;
	
	for ($vert in $verts)
	{
		if ($count == 20)
		{
			$count = 0;
			print ("\nMirrored " + $count2 + "/" + size($verts) + " verts.");
		}
		$count++; $count2++;
		
		string $vfs[] = boltNorms.ToVFs({$vert});
		
		for ($vf in $vfs)
		{
			//find opposite vf
			string $vf2 = boltNorms.GetSymmetricalVF($vf,$obj,$tol);
			
			
			
			//if a vf was found
			if ($vf2 != "")
			{
				int $locked[] = `polyNormalPerVertex -q -freezeNormal $vf`;
				
				//if unlocked, unlock mirrored vf
				if ($locked[0] == 0)
				{
					polyNormalPerVertex -unFreezeNormal 0 $vf2;
				}				
				else
				//if locked, set mirrored vf normal to mirrored value
				{
					vector $normal = `polyNormalPerVertex -q -xyz $vf`;
					polyNormalPerVertex -xyz (($normal.x)*-1) ($normal.y) ($normal.z) $vf2;
				}
			}
		}
	}
	
	print "\nMirroring soft/hard edge assignments";
	
	//mirror soft / hard edges
	string $edges[] = boltNorms.ToEdges($verts);
	string $hardEdges[] = {};
	string $softEdges[] = {};
	for ($edge in $edges)
	{
		string $edge2 = boltNorms.GetSymmetricalEdge($edge,$obj,$tol);
		if ($edge2 != "")
		{
			if (boltNorms.IsEdgeHard($edge) == 1)
			{
				$hardEdges[size($hardEdges)] = $edge2;
			}
			else
			{
				$softEdges[size($softEdges)] = $edge2;
			}
		}
	}
	if (size($softEdges)>0) polySoftEdge -a 180 -ch 1 $softEdges;
	if (size($hardEdges)>0) polySoftEdge -a 0 -ch 1 $hardEdges;
	
	//restore selection
	select -cl; select $sel;

	print "\nNormal Mirroring complete!";
}





global proc string boltNorms.GetSymmetricalVF(string $vf, string $obj, float $tolerance)
//returns the vf on the object symmetrical to the given vf in x
//using specified tolerance.
{
	//print ("\ngetting symetrical vf for " + $vf);
	
	string $vert[] = boltNorms.ToVerts({$vf});
	string $face[] = boltNorms.ToFaces({$vf});
	string $vert2 = boltNorms.GetSymmetricalVertex($vert[0],$obj,$tolerance);
	string $face2 = boltNorms.GetSymmetricalFace($face[0],$obj,$tolerance);
	
	if (($face2 != "") && ($vert2 != ""))
	{
		string $vf2[] = boltNorms.GetVertexFaces({$vert2},{$face2});
		return $vf2[0];
	}
	return "";
}

global proc string boltNorms.GetSymmetricalVertex(string $vert, string $obj, float $tolerance)
//optimised version using array lookup
{
	global string $gBoltNormsVertSelection[];
	global string $gBoltNormsVertLookup[];
	
	//check if we need to build the lockup table...
	if (size($gBoltNormsVertLookup) == 0)
	{
		print "\nBuilding symmetry lookup table...";
		
		//expand the selection to include all surrounding face verts
		string $verts[] = boltNorms.ToVerts(boltNorms.ToFaces($gBoltNormsVertSelection));
	
		for($v in $verts)
		{
			$gBoltNormsVertLookup[size($gBoltNormsVertLookup)] = $v;
			string $v2 = boltNorms.GetSymmetricalVertex2($v, $obj, $tolerance);
			$gBoltNormsVertLookup[size($gBoltNormsVertLookup)] = $v2;
		}
	}
	
	int $i = sFindItem($gBoltNormsVertLookup,$vert);
	if ($i == -1) return "";
	return $gBoltNormsVertLookup[$i+1];
}
	
	

global proc string boltNorms.GetSymmetricalVertex2(string $vert, string $obj, float $tolerance)
//returns the vert on $obj symmetrical to $vert in x
//using specified $tolerance.
{
	vector $vPos = `pointPosition -w $vert`;
	int $noVerts = GetNbMeshVerts($obj);
	
	for($i=0 ; $i < $noVerts; $i++)
	{	
		string $vert2 = ($obj+".vtx["+$i+"]");
		vector $vPos2 =  `pointPosition -w $vert2`;
		if (abs($vPos.y - $vPos2.y) < $tolerance)
		{
			if (abs($vPos.z - $vPos2.z) < $tolerance)
			{
				if (abs($vPos.x - (-1*$vPos2.x)) < $tolerance)
				{
					return $vert2;
				}
			}
		}
	}
	//failed to find symmetrical vert
	return "";
}


global proc string boltNorms.GetMatchingVertex2(string $vert, string $obj1, string $obj2, float $tolerance)
//returns the vert on $obj2 in the same position as $vert on $obj1
//using specified $tolerance.
{
	vector $vPos = `pointPosition -w $vert`;
	int $noVerts = GetNbMeshVerts($obj2);
	
	for($i=0 ; $i < $noVerts; $i++)
	{	
		string $vert2 = ($obj1+".vtx["+$i+"]");
		vector $vPos2 =  `pointPosition -w $vert2`;
		if (abs($vPos.y - $vPos2.y) < $tolerance)
		{
			if (abs($vPos.z - $vPos2.z) < $tolerance)
			{
				if (abs($vPos.x - $vPos2.x) < $tolerance)
				{
					return $vert2;
				}
			}
		}
	}
	//failed to find matching vert
	return "";
}

global proc string boltNorms.GetMatchingEdge2(string $edge, string $obj1, string $obj2, float $tolerance)
//returns the edge on $obj2 that matches $edge on $obj1
//using specified tolerance.
{
	string $edgeVerts[] = boltNorms.ToVerts({$edge});
	string $edge2Verts[] = {};
	
	//get the verts that make up the symmetrical face
	for ($v in $edgeVerts)
	{
		string $v2 = boltNorms.GetMatchingVertex2($v, $obj1, $obj2, $tolerance);
		if ($v2 != "") $edge2Verts[size($edge2Verts)] = $v2;
	}	
	if (size($edge2Verts)<2) return "";
	
	string $edge2[] = boltNorms.ToEdges({$edge2Verts[0]});
	
	for ($v in $edge2Verts)
	{
		$edge2 = boltNorms.StringArrayIntersect($edge2,boltNorms.ToEdges({$v}));
	}
	
	if (size($edge2)<1) return "";
	return $edge2[0];
}







global proc string boltNorms.GetSymmetricalFace(string $face, string $obj, float $tolerance)
//returns the face on the object symmetrical to the given face in x
//using specified tolerance.
{
	string $faceVerts[] = boltNorms.ToVerts({$face});
	string $face2Verts[] = {};
	
	//get the verts that make up the symmetrical face
	for ($v in $faceVerts)
	{
		string $v2 = boltNorms.GetSymmetricalVertex($v, $obj, $tolerance);
		if ($v2 != "") $face2Verts[size($face2Verts)] = $v2;
	}
	
	if (size($face2Verts)<3) return "";
	
	string $face2[] = boltNorms.ToFaces({$face2Verts[0]});
	
	for ($v in $face2Verts)
	{
		$face2 = boltNorms.StringArrayIntersect($face2,boltNorms.ToFaces({$v}));
	}
	
	if (size($face2)<1) return "";
	return $face2[0];
}

global proc string boltNorms.GetSymmetricalEdge(string $edge, string $obj, float $tolerance)
//returns the edge on $obj symmetrical to the given edge in x
//using specified tolerance.
{
	string $edgeVerts[] = boltNorms.ToVerts({$edge});
	string $edge2Verts[] = {};
	
	//get the verts that make up the symmetrical face
	for ($v in $edgeVerts)
	{
		string $v2 = boltNorms.GetSymmetricalVertex($v, $obj, $tolerance);
		if ($v2 != "") $edge2Verts[size($edge2Verts)] = $v2;
	}	
	if (size($edge2Verts)<2) return "";
	
	string $edge2[] = boltNorms.ToEdges({$edge2Verts[0]});
	
	for ($v in $edge2Verts)
	{
		$edge2 = boltNorms.StringArrayIntersect($edge2,boltNorms.ToEdges({$v}));
	}
	
	if (size($edge2)<1) return "";
	return $edge2[0];
}



global proc string boltNorms.GetSharedEdgeFromVerts(string $v1, string $v2)
//returns the edge shared by two verts, or "" if none found
{
	string $e1[] = boltNorms.ToEdges({$v1});
	string $e2[] = boltNorms.ToEdges({$v2});
	string $sharedEdge[] = boltNorms.StringArrayIntersect($e1,$e2);
	
	if (size($sharedEdge)==0) return "";
	if (size($sharedEdge)>1) warning "More than one shared edge found between verts!!!";
	return $sharedEdge[0];
}



global proc string boltNorms.GetSharedEdge(string $poly, string $vert, string $notEdges[], string $notPoly)
//returns the shared edge of the given poly and vert, but not on the specified (selected) edges, polys
{
	//print "\ngetSharedEdge $poly = "; print $poly;
	//print "\ngetSharedEdge $vert = "; print $vert;
	//print "\ngetSharedEdge $notEdges = "; print $notEdges;
	
	string $edges1[] = boltNorms.ToEdges({$poly});
	string $edges2[] = boltNorms.ToEdges({$vert});
	
	string $edges3[] = boltNorms.StringArrayIntersect($edges1,$edges2);
	$edges3 = stringArrayRemove($notEdges,$edges3);
	
	if (size($edges3)>1)
	{
		if ($notPoly != "")
		{
			string $edges4[] = boltNorms.ToEdges({$notPoly});
			$edges3 = stringArrayRemove($edges4,$edges3);
		}
	}	
	if (size($edges3)>1) error "boltNorms.GetSharedEdge -too many edges found";
	if (size($edges3)==0) return "";
	return $edges3[0];
}

global proc boltNorms.ShrinkObj(float $amount)
{
	string $verts[] = boltNorms.ToVerts(`ls -sl`);
	
	for ($vert in $verts)
	{
		vector $normal = <<0,0,0>>;
		$faces = boltNorms.ToFaces({$vert});
		for ($face in $faces)
		{
			$normal += boltNorms.GetFaceNorm($face);
		}
		$normal = unit($normal);
	
		vector $pos = `pointPosition -w $vert`;
		$pos = $pos + ($normal * $amount);
		xform -ws -t ($pos.x) ($pos.y) ($pos.z) $vert;
	}
}	

global proc int boltNorms.ArePolysAdjacent(string $poly1, string $poly2)
//returns 1 if specified polys are adjacent
{
	string $edges1[] = boltNorms.ToEdges({$poly1});
	string $edges2[] = boltNorms.ToEdges({$poly2});
	string $commonEdges[] = boltNorms.StringArrayIntersect($edges1, $edges2);
	
	if (size($commonEdges)>0) return 1;
	return 0;
}

global proc int boltNorms.DoesPolyContainEdge(string $poly, string $edge)
//returns 1 if specified poly uses specified edge
{
	string $edges[] = boltNorms.ToEdges({$poly});
	
	if (stringArrayContains($edge, $edges)) return 1;
	return 0;	
}

global proc int boltNorms.DoesEdgeContainVert(string $edge, string $vert)
//returns 1 if specified poly uses specified edge
{
	string $verts[] = boltNorms.ToVerts({$edge});
	if (stringArrayContains($vert, $verts)) return 1;
	return 0;	
}

global proc string[] boltNorms.StringArrayIntersect(string $array1[], string $array2[])
//returns an array of items common to both supplied arrays
{
	string $temp[] = stringArrayRemove($array1, $array2);
	string $common[] = stringArrayRemove($temp, $array2);
	return $common; 
}

global proc string[] boltNorms.ToFaces(string $input[])
{
	string $output[] = `polyListComponentConversion -toFace $input`;
	$output = `ls -fl $output`;
	return $output;
}
global proc string[] boltNorms.ToVerts(string $input[])
{
	if (size($input) == 0) return {};
	if ($input[0] == "") return {};
	string $output[] = `polyListComponentConversion -toVertex $input`;
	$output = `ls -fl $output`;
	return $output;
}
global proc string[] boltNorms.ToEdges(string $input[])
{
	if (size($input) == 0) return {};
	if ($input[0] == "") return {};
	string $output[] = `polyListComponentConversion -toEdge $input`;
	$output = `ls -fl $output`;
	return $output;
}
global proc string[] boltNorms.ToVFs(string $input[])
{
	string $output[] = `polyListComponentConversion -toVertexFace $input`;
	$output = `ls -fl $output`;
	return $output;
}
global proc string[] boltNorms.ToUVs(string $input[])
{
	string $output[] = `polyListComponentConversion -toUV $input`;
	$output = `ls -fl $output`;
	return $output;
}
global proc string[] boltNorms.ToBorderEdges(string $input[])
{
	string $output[] = `polyListComponentConversion -toEdge -border $input`;
	$output = `ls -fl $output`;
	return $output;
}

global proc boltNorms.NormalDisplay(int $on, float $size)
{
	string $shapes[] = `ls -type "mesh"`;
	
	for ($shape in $shapes)
	{
		setAttr ($shape + ".displayNormal") $on;
		setAttr ($shape + ".normalType") 2;
		setAttr ($shape + ".normalSize") $size;
	}
}




//////////////////////////////////////////////////////////////////////// 
//from boltShaderTools.mel


global proc float boltNorms.boltGetPoly3DArea(string $poly)
//returns surface area of a 3d poly by iterating through triangles
//may not work with concave quads
{
	
	string $objName = `match "^[^\.]*" $poly`;
	string $ftv[] = `polyInfo -faceToVertex $poly`;
	string $tokens[];
	tokenize $ftv[0] " :\n\r" $tokens;
	string $verts[] = {};
	for ( $t = 2; $t < `size $tokens`; $t++ )
	{
  		$verts[`size $verts`] = ($objName + ".vtx[" + $tokens[$t] + "]");
	}
	int $noVerts = `size $verts`;
	//get the verts and vertfaces in construction order
		
	float $area3D = 0;
		
	for ($i = 0; $i < $noVerts-2; $i++)
	{
		vector $v1 = `pointPosition -w $verts[$noVerts-1]`;
		vector $v2 = `pointPosition -w $verts[$i]`;
		vector $v3 = `pointPosition -w $verts[$i+1]`;

		float $triArea = `boltNorms.boltGetTri3DArea $v1 $v2 $v3`;
		$area3D = $area3D + $triArea;
	}
	return $area3D;
}

global proc float boltNorms.boltGetTri3DArea(vector $v1, vector $v2, vector $v3)
//uses heron's formula to return area of 3d triangle, given 3 points as vectors
{	
	vector $d1 = $v1 - $v2;
	vector $d2 = $v2 - $v3;
	vector $d3 = $v3 - $v1;
	
	float $e1 = sqrt(($d1.x*$d1.x)+($d1.y*$d1.y)+($d1.z*$d1.z));
	float $e2 = sqrt(($d2.x*$d2.x)+($d2.y*$d2.y)+($d2.z*$d2.z));
	float $e3 = sqrt(($d3.x*$d3.x)+($d3.y*$d3.y)+($d3.z*$d3.z));
	
	float $s = (($e1+$e2+$e3)/2);
	
	float $area = sqrt(($s-$e1)*($s-$e2)*($s-$e3)*$s);
	
	return $area;
}


global proc boltNorms.MatchSeamNormals()
//given two edge loops on same or seperate objects, finds nearest verts, and averages normals.
{
	//max seperation allowed for matching verts, in m
	float $maxVertSeperation = 0.1;
	
	string $edges[] = `ls -sl -fl "*.e[*]"`;
	
	//get and verify 2 edge loops
	string $loop1[] = boltNorms.GetLoop($edges[0], $edges);
	string $remainingEdges[] = stringArrayRemove($loop1,$edges); 
	if (size($remainingEdges) == 0)
	{
		error "Please select 2 seperate, adjacent edge loops for seam matching";
	}
	string $loop2[] = boltNorms.GetLoop($remainingEdges[0], $remainingEdges);
	if ( size($remainingEdges) > size($loop2) )
	{
		error "Please select 2 seperate, adjacent edge loops for seam matching";
	}
	
	string $loop1verts[] = boltNorms.ToVerts($loop1);
	string $loop2verts[] = boltNorms.ToVerts($loop2);
	
	for ($v1 in $loop1verts)
	{
		$v2 = boltNorms.GetNearestVertPos($v1, $loop2verts);
		
		if ( boltNorms.GetVertDistance($v1, $v2) > $maxVertSeperation )
		{
			warning ("Not normal matching between " + $v1 + " and " + $v2 + ". Max vertex seperation of " + $maxVertSeperation + "m exceeded!");
		}
		else
		{
			boltNorms.AverageSeamVerts($v1, $v2);
		}
	}
	
	print "\nSeam Normal Matching completed.";


}

global proc vector boltNorms.GetAverageNormalOnVert(string $vert)
//returns the average normal on a vert.
{
	vector $normal = <<0,0,0>>;
	string $vfs[] = boltNorms.ToVFs({$vert});
	for ($vf in $vfs)
	{
		$normal += `polyNormalPerVertex -q -xyz $vf`;
	}
	return unit($normal);
}

global proc boltNorms.AverageSeamVerts(string $v1, string $v2)
//averages the normals of the two verts
{
	//get the average normal
	vector $v1n = boltNorms.GetAverageNormalOnVert($v1);
	vector $v2n = boltNorms.GetAverageNormalOnVert($v2);
	
	string $obj1 = boltNorms.getTransformOfComponent($v1);
	string $obj2 = boltNorms.getTransformOfComponent($v2);
	
	$v1n = boltNorms.convertToWS($obj1, $v1n);
	$v2n = boltNorms.convertToWS($obj2, $v2n);
	
	vector $normal = unit( $v1n + $v2n );
	
	$v1n = boltNorms.convertToOS($obj1, $normal);
	$v2n = boltNorms.convertToOS($obj2, $normal);
	
	//set the normals
	polyNormalPerVertex -xyz ($v1n.x) ($v1n.y) ($v1n.z) $v1;
	polyNormalPerVertex -xyz ($v2n.x) ($v2n.y) ($v2n.z) $v2;
}


global proc string boltNorms.getTransformOfComponent(string $component)
//returns the transform node of a component
{
	string $obj = `match "^[^\.]*" $component`;
	if (`nodeType $obj` != "transform")
	{
		string $objs[] = `boltShapesToTransformsNoPath {$obj}`; 
		$obj = $objs[0];
	}
	if (`nodeType $obj` != "transform") return "";
	return $obj;
}

global proc vector boltNorms.convertToWS(string $obj, vector $norm)
//converts a normal from os into ws, given the vert it belongs to
{
	matrix $m1[4][4];
	$m1 = bolt.getWorldMatrix($obj,0);
	
	float $mList[] = bolt.MatrixToFloat($m1);
	vector $norm2 = pointMatrixMult($norm,$mList);
	
	return $norm2;
}

global proc vector boltNorms.convertToOS(string $obj, vector $norm)
//converts a normal from ws into os, given the vert it belongs to
{
	matrix $m1[4][4];
	$m1 = bolt.getWorldMatrix($obj,1);
	
	float $mList[] = bolt.MatrixToFloat($m1);
	vector $norm2 = pointMatrixMult($norm,$mList);
	
	return $norm2;
}



global proc string boltNorms.GetNearestVertPos(string $vert, string $verts[])
//returns the name of the nearest vert to $vert from $verts.
{
	string $closestVert = "";
	float $closestDistance = 1000000;
	vector $vertPos = `xform -q -t -ws $vert`;
	
	for ($vert in $verts)
	{
		vector $p = `xform -q -t -ws $vert`;
		float $dist = mag($vertPos-$p);
		if ($dist < $closestDistance)
		{
			$closestDistance = $dist;
			$closestVert = $vert;
		}
	}
	return $closestVert;
}

global proc float boltNorms.GetVertDistance(string $vert1, string $vert2)
//returns the distance between 2 verts.
{
	vector $v1Pos = `xform -q -t -ws $vert1`;
	vector $v2Pos = `xform -q -t -ws $vert2`;
	return mag($v1Pos-$v2Pos);
}


global proc string[] boltNorms.GetLoop(string $edge, string $edgeList[])
//returns a list of edges from the supplied $edgeList that are attached to the specified edge
{
	string $returnLoop[] = {$edge};
	$edgeList = stringArrayRemove($returnLoop,$edgeList);
	
	$size = size($edgeList);
	for ($i=0;$i<=$size;$i++)
	{
		//get surrounding edges of loop
		string $v[] = boltNorms.ToVerts($returnLoop);
		string $e[] = boltNorms.ToEdges($v);
		string $newEdges[] = boltNorms.StringArrayIntersect($e,$edgeList);
		
		if (size($newEdges)>0)
		{
			$returnLoop = stringArrayCatenate($returnLoop,$newEdges);
			$edgeList = stringArrayRemove($newEdges,$edgeList);
		}
		else
		{
			return $returnLoop;
		}
	}
}
	
	
	
global proc boltNorms.Backup(string $obj)
{
	print ("\nSaving normals on " + $obj);
	
	//attempt to open file for writing first, so any errors are caught before data processing

	string $filePath = `file -q -sn`;
	string $path = dirname($filePath);
	string $name = basenameEx($filePath);
	string $normFile = ($path + "/" + $name + "_" + $obj + ".normals");
	$fileId=`fopen $normFile "w"`;
	if ($fileId == 0) error ("Error opening file '" + $normFile + "'. Is it write protected?");

	//get normal data as large text string
	string $file = "";

	int $count = 100;
	int $count2 = 0;
	
	$verts = `ls -fl ($obj + ".vtx[*]")`;
	$edges = `ls -fl ($obj + ".e[*]")`;
	
	//save hard edges
	for ($edge in $edges)
	{
		if (boltNorms.IsEdgeHard($edge) == 1)
		{
			$file += ("\n" + $edge);
		}
	}
	
	string $vert = "";
	//save locked normals, and vert positions
	
	//progressBar -e -beginProgress -isInterruptable false -status "Saving locked normals:" -maxValue size($verts) $gMainProgressBar;
	
	
	for ($vert in $verts)
	{
		if ($count == 100)
		{
			$count = 0;
			print ("\nSaved " + $count2 + "/" + size($verts) + " verts.");
		}
		$count++; $count2++;
		
		//store only locked vf normals
		string $vfs[] = `boltNorms.ToVFs {$vert}`;
		
		string $data = "";
		string $vf = "";
		for ($vf in $vfs)
		{
			int $locked[] = `polyNormalPerVertex -q -allLocked $vf`;
			if ( $locked[0] == 1)
			{
				float $norm[] = `polyNormalPerVertex -q -xyz $vf`;
				$data += ("\n" + $vf +" "+ $norm[0] +" "+ $norm[1] +" "+ $norm[2]);
			}
		}
		
		if (size($data) > 0) //if any vfs stored, store position too
		{
			//store position first
			float $pos[] = `pointPosition -w $vert`; 
			$file = ($file + "\n" + $vert +" "+ $pos[0] +" "+ $pos[1] +" "+ $pos[2] + $data);
		}
	}

	//write file
	fprint $fileId $file;
	fclose $fileId;		
	//write $file to disk
	
	print ("\nNormal data written to: " + $normFile);
}


global proc boltNorms.BackupGUI(string $sel, string $mode)
// options: ALL / SL  ,  SAVE / RESTORE
{
	$originalSel = `ls -sl`;
	
	string $objs[] = {};
	
	if ($sel == "ALL") 
	{
		$objs = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	}
	if ($sel == "SL") 
	{
		$objs = `ls -sl -transforms`;
	}
	
	for ($obj in $objs)
	{
		if ($mode == "SAVE")
		{
			boltNorms.Backup($obj);
		}
		if ($mode == "RESTORE")
		{
			boltNorms.Restore($obj);
		}
	}
	select $originalSel;
}


global proc boltNorms.Restore(string $obj)
{	
	print ("\nRestoring normals on " + $obj);
	
	string $shapes[] = boltTransformsToShapes({$obj});
	$shape = $shapes[0];
		
	string $filePath = `file -q -sn`;
	string $path = dirname($filePath);
	string $name = basenameEx($filePath);
	string $normFile = ($path + "/" + $name + "_" + $obj + ".normals");
	$fileId=`fopen $normFile "r"`;
	if ($fileId == 0) error ("Could not find file '" + $normFile + "'. Does it exist?");
	
	//unlock everything
	polyNormalPerVertex -ufn true $shape;
	//set all edges to soft
	polySoftEdge -a 180 -ch 0 $shape;
	
	string $edgesToCrease[] = {};
	
	int $count = 100;
	int $count2 = 0;	
	
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 ) 
	{
		if ($count == 100)
		{
			$count = 0;
			print ("\nProcessed " + $count2 + " lines of data.");
		}
		$count++; $count2++;
		
		
    	//print ( $nextLine );
    	$nextLine = substitute("[( \n\t\r)]*$", $nextLine, "");
    	
    	//store hard edges
    	if (`gmatch $nextLine "*.e\\[*"` == 1)
    	{
    		//print ("\nCreasing this edge");
    		$edgesToCrease[size($edgesToCrease)] = $nextLine;
    	}
    	
    	if (`gmatch $nextLine "*.vtxFace\\[*"` == 1)
    	{
    		string $buffer[];
			$numtokens = tokenize($nextLine, $buffer);
			float $x = $buffer[1]; float $y = $buffer[2]; float $z = $buffer[3];
			polyNormalPerVertex -xyz $x $y $z $buffer[0];
    	}
    	
    	$nextLine = `fgetline $fileId`;
	}
	fclose $fileId;
	
	//set all edges to soft, then crease
	polySoftEdge -a 180 -ch 0 $shape;
	polySoftEdge -a 0 -ch 0 $edgesToCrease;
}

global proc boltNorms.Restore2(string $obj)
//sets all locked norm vfs to same value, matches verts based on position
{	
	print ("\nRestoring normals on " + $obj);
	
	string $shapes[] = boltTransformsToShapes({$obj});
	$shape = $shapes[0];
		
	string $filePath = `file -q -sn`;
	string $path = dirname($filePath);
	string $name = basenameEx($filePath);
	string $normFile = ($path + "/" + $name + "_" + $obj + ".normals");
	$fileId=`fopen $normFile "r"`;
	if ($fileId == 0) error ("Could not find file '" + $normFile + "'. Does it exist?");
	
	//unlock everything
	polyNormalPerVertex -ufn true $shape;
	//set all edges to soft
	polySoftEdge -a 180 -ch 0 $shape;
	
	string $edgesToCrease[] = {};
	
	int $count = 100;
	int $count2 = 0;	
	
	string $nextLine = `fgetline $fileId`;
	while ( size( $nextLine ) > 0 ) 
	{
		if ($count == 100)
		{
			$count = 0;
			print ("\nProcessed " + $count2 + " lines of data.");
		}
		$count++; $count2++;
		
		
    	//print ( $nextLine );
    	$nextLine = substitute("[( \n\t\r)]*$", $nextLine, "");
    	
    	//store hard edges
    	if (`gmatch $nextLine "*.e\\[*"` == 1)
    	{
    		//print ("\nCreasing this edge");
    		$edgesToCrease[size($edgesToCrease)] = $nextLine;
    	}
    	
    	if (`gmatch $nextLine "*.vtxFace\\[*"` == 1)
    	{
    		string $buffer[];
			$numtokens = tokenize($nextLine, $buffer);
			float $x = $buffer[1]; float $y = $buffer[2]; float $z = $buffer[3];
			polyNormalPerVertex -xyz $x $y $z $buffer[0];
    	}
    	
    	$nextLine = `fgetline $fileId`;
	}
	fclose $fileId;
	
	//set all edges to soft, then crease
	polySoftEdge -a 180 -ch 0 $shape;
	polySoftEdge -a 0 -ch 0 $edgesToCrease;
}

global proc string[] boltNorms.getHardEdges(string $obj)
{
	string $edges[] = `ls -fl ($obj + ".e[*]")`;
	string $hardEdges[] = {};
	for ($edge in $edges)
	{
		if (boltNorms.IsEdgeHard($edge) == 1)
		{
			$hardEdges[size($hardEdges)] = $edge;
		}
	}
	return $hardEdges;
}

global proc boltNorms.setHardEdges(string $obj, string $hardEdges[])
{
	if ( size($hardEdges) == 0 ) return; //bugfix for shapes with no hard edges
	string $shapes[] = boltTransformsToShapes({$obj});
	$shape = $shapes[0];
	
	string $newHardEdgesSet = `sets $hardEdges`;
	string $existingHardEdges[] = boltNorms.getHardEdges($obj);
	string $existingHardEdgesSet = `sets $existingHardEdges`;
	
	
	string $edgesToMakeHard[] = `sets -sub $newHardEdgesSet $existingHardEdgesSet`;
	string $edgesToMakeSoft[] = `sets -sub $existingHardEdgesSet $newHardEdgesSet`;

	if (size($edgesToMakeHard) > 0) polySoftEdge -a 0 -ch 0 $edgesToMakeHard;
	if (size($edgesToMakeSoft) > 0)	polySoftEdge -a 180 -ch 0 $edgesToMakeSoft;

	//this hack needed to properly makes the soft edges soft
	select $obj;
	boltNorms.SelectHard(0);
	if (size(`ls -sl`)>0) polySoftEdge -a 180 -ch 0;
	select -cl;
}