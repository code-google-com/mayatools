
source boltCarData;
source boltShaderTools; //used for texture measurements etc
source boltDebugShaderGUI; //needed for restoreTechniques
source boltLodStats;
source boltLodTools; //short edges
source boltRigging; //delete havok nodes
source boltUVTools; //uvWinding
source boltHierarchy; //zeroPivot offsets
//source evosExportVehicle; //convert from M path
python("import superShaderTools");
python("import superVertPaint");
python("import superTextureTools");

global proc boltSuperCarValidator.GUI()
//displays car validator GUI
{
	
	global string $gBoltWarnings;
	$gBoltWarnings = "";
	//This string contains all errors / warnings found, to be printed at the end

	global string $gBoltWarningsLow;
	$gBoltWarningsLow = "";
	//This string contains all low priority warnings found, to be printed seperately at the end
	
	string $windowName = "boltSuperCarValidatorWindow";
	
	if (`window -exists $windowName`)
	{ 
		deleteUI $windowName;
	}
	//delete the window if it already exists
	
	global string $gBoltSCV_Checkboxes[];
	
	$gBoltSCV_Checkboxes = {"boltSCV_CheckB_Backup", 
							"boltSCV_CheckB_MPaths", 
							"boltSCV_CheckB_RenameShapes",
							"boltSCV_CheckB_DeleteHavok",
							"boltSCV_CheckB_DeleteHistory",
							"boltSCV_CheckB_MayaClean",
							"boltSCV_CheckB_EvoClean",
							"boltSCV_CheckB_SceeClean",
							"boltSCV_CheckB_DeleteLayers",
							"boltSCV_CheckB_DeleteWTK",
							"boltSCV_CheckB_CorruptSGs",
							"boltSCV_CheckB_FixVertexCols",
							"boltSCV_CheckB_TestMud",
							"boltSCV_CheckB_TidyShaders",
							"boltSCV_CheckB_DeleteTextures",
							"boltSCV_CheckB_CheckTextures",
							"boltSCV_CheckB_CheckUVSets",
							"boltSCV_CheckB_FlippedUVs",
							"boltSCV_CheckB_CheckUnmapped",
							"boltSCV_CheckB_CheckShaderErrors",
							"boltSCV_CheckB_PlacePivots",
							"boltSCV_CheckB_ZeroPivots",
							"boltSCV_CheckB_CheckScales",
							"boltSCV_CheckB_TestSymmetry",
							"boltSCV_CheckB_TestLODs",
							"boltSCV_CheckB_TestAllLODs",
							"boltSCV_CheckB_TestDeads",
							"boltSCV_CheckB_TestHierarchy",
							"boltSCV_CheckB_TestPhysics",
							"boltSCV_CheckB_TestLights",
							"boltSCV_CheckB_CheckPartNames",
							"boltSCV_CheckB_CheckAnimLocs",
							"boltSCV_CheckB_CheckWheels",
							"boltSCV_CheckB_CheckBudgets"
							};
	
	
	window -height 307 -width 208 -title "Super Car Validator" -toolbox 1 $windowName;
	//create window
		frameLayout -mw 0 -mh 0 -bv 0 -lv 0;
			columnLayout;
				
				frameLayout  -collapsable 1 -label "Tools:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -l "Fix Corrupt Objects" -w 140 -h 20 -ann "Can fix corrupted objects that are inexplicably loosing shaders when attached together. Uses the 'attach to cube' hack on selected objects." -c "boltFixCorruptObjectGUI()";
							button -l "Reapply All Shaders" -w 140 -h 20 -ann "Completely destroys all shading groups in scene, applies initialShadingGroup, and then re-applies all materials" -c "python(\"superShaderTools.reapplyAllMaterials()\"); boltTidyShaders;";
						setParent ..;
					setParent ..;
				setParent ..;
				
				frameLayout  -collapsable 1 -label "File Management:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Save backup to C:\\SCVbackup.mb" 		-ann "Saves a backup of your file before attempting to clean it. Recommended incase anything goes wrong"		boltSCV_CheckB_Backup;
							button -l "" -w 40 -h 15 -c "boltSCV.backup" 																																	boltSCV_Button_Backup;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Change paths to M:" 	-ann "Changes all texture and shader paths in the file to be M: based"	boltSCV_CheckB_MPaths;
	    					button -l "" -w 40 -h 15 -c "boltRepathTextures" 																		boltSCV_Button_MPaths;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check stats and budgets"	-ann "Prints texture and polygon usage, warns if over budget"	boltSCV_CheckB_CheckBudgets;
							button -l "" -w 40 -h 15 -c "boltGetStats" 																			boltSCV_Button_CheckBudgets;
						setParent ..;
				
					setParent ..;
				setParent ..;
				
				frameLayout  -collapsable 1 -label "Scene Cleanup:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Correct shape node names" -ann "Ensures that all shape nodes are correctly named"		boltSCV_CheckB_RenameShapes;
							button -l "" -w 40 -h 15 -c "boltRenameShapesOrig" 																boltSCV_Button_RenameShapes;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Delete Havok nodes from LODs + Damage" 	-ann "Ensures that no LOD or damage parts have havok enabled"	boltSCV_CheckB_DeleteHavok;
							button -l "" -w 40 -h 15 -c "boltSCV.cleanHavok" 																					boltSCV_Button_DeleteHavok;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Delete construction history" 	-ann "Removes as much construction history as possible from nodes in the scene"	boltSCV_CheckB_DeleteHistory;
							button -l "" -w 40 -h 15 -c "boltSCV.deleteHistory" 																					boltSCV_Button_DeleteHistory;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Run Maya Optimise Scene functions" 	-ann "Runs Maya's optimise scene funtions to remove various redundant nodes from the file"	boltSCV_CheckB_MayaClean;
							button -l "" -w 40 -h 15 -c "boltSCV.mayaClean" 																											boltSCV_Button_MayaClean;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Run Evos cleanup functions" 	-ann "Runs various evoCleanup functions to optimise the scene"	boltSCV_CheckB_EvoClean;
							button -l "" -w 40 -h 15 -c "boltSCV.evoClean" 																			boltSCV_Button_EvoClean;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Run SCEE Tools cleanup functions" 	-ann "Removes even more stray nodes from the scene (scene purge)"		boltSCV_CheckB_SceeClean;
							button -l "" -w 40 -h 15 -c "boltSCV.sceeClean" 																						boltSCV_Button_SceeClean;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Delete all layers in scene" 	-ann "Removes all layers from the scene - they cause quite a few problems for us"	boltSCV_CheckB_DeleteLayers;
							button -l "" -w 40 -h 15 -c "boltSCV.deleteLayers" 																							boltSCV_Button_DeleteLayers;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Delete world tool nodes and cameras" 	-ann "Removes nodes that may have been placed in the scene by the evo world tools"	boltSCV_CheckB_DeleteWTK;
							button -l "" -w 40 -h 15 -c "boltSCV.deleteWTK" 																									boltSCV_Button_DeleteWTK;
						setParent ..;
						
					setParent ..;
				setParent ..;
				
				frameLayout  -collapsable 1 -label "Texture and shader checks:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;	
				
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test and Fix broken shading groups" 	-ann "Tests for multiple shaders per face, and missing shaders. Fixes redundant SG connections"	boltSCV_CheckB_CorruptSGs;
							button -l "" -w 40 -h 15 -c "boltSCV.corruptSGs" 																			boltSCV_Button_CorruptSGs;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Fix out of range vertex colours" 	-ann "Clamps any vertex colours or alphas that are above 1 or below 0"	boltSCV_CheckB_FixVertexCols;
							button -l "" -w 40 -h 15 -c "boltSCV.fixVertexColours" 																				boltSCV_Button_FixVertexCols;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test mud and occlusion" 	-ann "Checks that mud and occlusion have been done on all parts, reports on any problems found"	boltSCV_CheckB_TestMud;
							button -l "" -w 40 -h 15 -c "boltSCV.testMud" 																										boltSCV_Button_TestMud;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Delete unused shaders, fix case" 	-ann "Deletes unused shaders, and renames all shaders to lowercase (ensures they are listed alphabetically)"	boltSCV_CheckB_TidyShaders;
							button -l "" -w 40 -h 15 -c "boltSCV.tidyShaders" 																															boltSCV_Button_TidyShaders;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Delete Unused Textures" 	-ann "Deletes unused textures and shading groups."	boltSCV_CheckB_DeleteTextures;
							button -l "" -w 40 -h 15 -c "boltMLdeleteUnused" 													boltSCV_Button_DeleteTextures;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test texture formats and paths" 	-ann "Checks for valid texture sizes, formats and paths"	boltSCV_CheckB_CheckTextures;
							button -l "" -w 40 -h 15 -c "boltCheckTextures" 																		boltSCV_Button_CheckTextures;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check UV and Colour sets" 	-ann "Removes any un-needed vertex colour sets, checks UV and Colour sets for naming errors"	boltSCV_CheckB_CheckUVSets;
							button -l "" -w 40 -h 15 -c "boltSCV.CheckUVAndColourSets" 																								boltSCV_Button_CheckUVSets;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check for UV Errors" 	-ann "Checks for flipped normal map UVs, UV ratios, and UV positions"	boltSCV_CheckB_FlippedUVs;
							button -l "" -w 40 -h 15 -c "boltCheckUVs"														boltSCV_Button_FlippedUVs;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check for unmapped verts" 	-ann "Checks for verts with no UV mapping co-ordinates, warns if found"	boltSCV_CheckB_CheckUnmapped;
							button -l "" -w 40 -h 15 -c "boltCheckForUnmappedVerts" 																				boltSCV_Button_CheckUnmapped;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check for shader errors" 	-ann "Checks for unshaded polys, broken shading groups, wrong shaders etc"	boltSCV_CheckB_CheckShaderErrors;
							button -l "" -w 40 -h 15 -c "boltCheckShaders" 																				boltSCV_Button_CheckShaderErrors;
						setParent ..;
						//rowLayout -numberOfColumns 2 -cw2 240 40;
						//	checkBox -value 1 -label "Check locked normals" 	-ann "Checks for objects with incorrectly locked normals"	boltSCV_CheckB_CheckLockedNorms;
						//	button -l "" -w 40 -h 15 -c "boltCheckLockedNormals" 															boltSCV_Button_CheckLockedNorms;
						//setParent ..;
					setParent ..;	
	    		setParent ..;	
				
				frameLayout  -collapsable 1 -label "Hierarchy and game readiness checks" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
	    			    
	    			    rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Set BODY and WHEEL pivots" 	-ann "Makes sure BODY and BODY_COL pivots are positioned correctly. Matches various nodes to body pivot. Sets wheels to outside of tyre"	boltSCV_CheckB_PlacePivots;
							button -l "" -w 40 -h 15 -c "boltZeroMeshPivotOffsets; boltTestPivotPlacements"		boltSCV_Button_PlacePivots;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Zero pivot offsets on mesh transforms" 	-ann "Zeros local space pivot offsets for all objects in the scene"	boltSCV_CheckB_ZeroPivots;
							button -l "" -w 40 -h 15 -c "boltZeroMeshPivotOffsets;" 																				boltSCV_Button_ZeroPivots;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Remove scale from all mesh transforms" 	-ann "Sets all mesh transform scales to 1 1 1"	boltSCV_CheckB_CheckScales;
							button -l "" -w 40 -h 15 -c "boltSCV.CheckScales" 																		boltSCV_Button_CheckScales;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test symmetry" 	-ann "Reports on the symmetry of various components. Can be ignored if vehicle is intentionally asymmetrical"	boltSCV_CheckB_TestSymmetry;
							button -l "" -w 40 -h 15 -c "boltSCV.TestSymmetry" 																											boltSCV_Button_TestSymmetry;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test + fix existing LODs" 	-ann "Looks for problems in the any exisitng LOD hierarchy and attempts to repair them. Matches lod pivot positions, tests for sub-pixel edges"	boltSCV_CheckB_TestLODs;
							button -l "" -w 40 -h 15 -c "boltSCV.testLODs" 																																	boltSCV_Button_TestLODs;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check all LODs are present" 	-ann "Verifies that all lods are present in the scene"	boltSCV_CheckB_TestAllLODs;
							button -l "" -w 40 -h 15 -c "boltTestAllLods" 																boltSCV_Button_TestAllLODs;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test + fix dead shapes" 	-ann "Checks and fixes dead shape naming and hierarchy errors"	boltSCV_CheckB_TestDeads;
							button -l "" -w 40 -h 15 -c "boltCheckDeadShapes" 																	boltSCV_Button_TestDeads;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test for necessary hierarchy" 	-ann "Tests that certain key components are present and correctly linked"	boltSCV_CheckB_TestHierarchy;
							button -l "" -w 40 -h 15 -c "boltTestHierarchy" 																						boltSCV_Button_TestHierarchy;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Test for necessary physics nodes" 	-ann "Tests for necessary physics nodes in the scene, now including particle collison boxes, and clingon locs"	boltSCV_CheckB_TestPhysics;
							button -l "" -w 40 -h 15 -c "boltTestPhysics" 																																	boltSCV_Button_TestPhysics;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check Lighting + Reflections" 	-ann "Tests everything to do with lightprobes, spotlights, windscreen reflections and ao volumes is set up correctly"	boltSCV_CheckB_TestLights;
							button -l "" -w 40 -h 15 -c "boltTestLights" 																													boltSCV_Button_TestLights;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check object names" 	-ann "Warn about non-standard part names"	boltSCV_CheckB_CheckPartNames;
							button -l "" -w 40 -h 15 -c "boltCheckPartNames" 											boltSCV_Button_CheckPartNames;
						setParent ..;
						rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check animation locators" 	-ann "Warn about missing or incorrectly positioned animation locators"	boltSCV_CheckB_CheckAnimLocs;
							button -l "" -w 40 -h 15 -c "boltSCV.checkAnimationLocators" 																	boltSCV_Button_CheckAnimLocs;
						setParent ..;
	    			    rowLayout -numberOfColumns 2 -cw2 240 40;
							checkBox -value 1 -label "Check wheel positions" 	-ann "Checks that the wheels and hubs are correctly positioned in the scene"	boltSCV_CheckB_CheckWheels;
							button -l "" -w 40 -h 15 -c "boltValidateChassis" 																					boltSCV_Button_CheckWheels;
						setParent ..;
										
					setParent ..;	
	    		setParent ..;	
				
				frameLayout  -collapsable 1 -label "Presets:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
				
						rowLayout -numberOfColumns 8;
							button -height 20 -width 38 -recomputeSize 0 -label "All On" 	-command "boltSwitchSCVOptions 1" -ann "Turns everything on";
							button -height 20 -width 38 -recomputeSize 0 -label "All Off" 	-command "boltSwitchSCVOptions 0" -ann "Turns everything off";
							text -h 20 -w 42 -l "Stage:";
							button -height 20 -width 30 -recomputeSize 0 -label "5" 	-command "boltSwitchSCVOptions 5" -ann "Outsource Stage 5 (LOD0 WIP model)";
							button -height 20 -width 30 -recomputeSize 0 -label "7" 	-command "boltSwitchSCVOptions 7" -ann "Outsource Stage 7 (LOD0 Complete)";
							button -height 20 -width 30 -recomputeSize 0 -label "10" 	-command "boltSwitchSCVOptions 10" -ann "Outsource Stage 10 (LOD1 Complete)";
							button -height 20 -width 30 -recomputeSize 0 -label "12" 	-command "boltSwitchSCVOptions 12" -ann "Outsource Stage 12 (All lods and shadows)";
							button -height 20 -width 30 -recomputeSize 0 -label "15" 	-command "boltSwitchSCVOptions 15" -ann "Outsource Stage 15 (Damage and Customisation)";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 283 -recomputeSize 0 -label "RUN Super Car Validator" -command "boltSuperCarValidate" -ann "Runs Super Car Validator with the specified options";
						setParent ..;
					setParent ..;	
	    		setParent ..;
				
				/*
				frameLayout  -collapsable 1 -label "Generate Reports" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
				
						rowLayout -numberOfColumns 2 -cw 1 125 -cw 2 125;
							button -height 20 -width 125  -recomputeSize 0 -label "          Print Stats"    -ann "Prints poly count, nodes and texture budget per livery" -command "boltCarStats";
							button -height 20 -width 125  -recomputeSize 0 -label "        Print Textures" -ann "Lists textures used by current livery, excluding generics and hdr cubemaps." -command "boltPrintTextureSizes";
						setParent ..;
						rowLayout -numberOfColumns 2 -cw 1 125 -cw 2 125;
							button -height 20 -width 125  -recomputeSize 0 -label "     Build XML Log File" -ann "Combines all vehicle logs into a single XML file, suitable for importing into Excel" -command "boltUpdateXMLLogFile";
							button -height 20 -width 125  -recomputeSize 0 -label "     Open Excel Log File" -ann "Opens the Excel spreadsheet containing the vehicle XML data table and graphs" -command "boltOpenExcelLog";
						setParent ..;
						
					setParent ..;	
	    		setParent ..;
				*/
				
				
			setParent ..;
		setParent ..;
	setParent ..;
						
	showWindow boltSuperCarValidatorWindow;
	//display the window
	
	window -e -height 760 -width 200 $windowName;    

}

global proc boltSwitchSCVOptions (int $state)
//switches all check boxes on/off
{
	global string $gBoltSCV_Checkboxes[];
	
	if ($state <= 1)
	{
		for ($cb in $gBoltSCV_Checkboxes)
		{
			if (`checkBox -exists $cb`) checkBox -edit -value $state $cb;
		}
		return;
	}
	
	if ($state==5)
	{
		boltSwitchSCVOptions 1;
	
		string $disable_Checkboxes[] = {"boltSCV_CheckB_TestMud",
						"boltSCV_CheckB_TidyShaders",
						"boltSCV_CheckB_DeleteTextures",
						"boltSCV_CheckB_FlippedUVs",
						"boltSCV_CheckB_CheckUnmapped",
						"boltSCV_CheckB_TestAllLODs",
						"boltSCV_CheckB_TestDeads",
						"boltSCV_CheckB_TestLights",
						"boltSCV_CheckB_TestPhysics"
						};
		for ($cb in $disable_Checkboxes)
		{
			if (`checkBox -exists $cb`) checkBox -edit -value 0 $cb;
		}
		return;
	}
	
	if ($state==7)
	{
		boltSwitchSCVOptions 1;
	
				string $disable_Checkboxes[] = {"boltSCV_CheckB_TestMud",
						"boltSCV_CheckB_TidyShaders",
						"boltSCV_CheckB_DeleteTextures",
						"boltSCV_CheckB_TestAllLODs",
						"boltSCV_CheckB_TestDeads",
						"boltSCV_CheckB_TestLights",
						"boltSCV_CheckB_TestPhysics"
						};
		for ($cb in $disable_Checkboxes)
		{
			if (`checkBox -exists $cb`) checkBox -edit -value 0 $cb;
		}
		return;
	}
		
	if ($state==10)
	{
		boltSwitchSCVOptions 1;
	
		string $disable_Checkboxes[] = {"boltSCV_CheckB_TestAllLODs", "boltSCV_CheckB_TestLights"};
		
		for ($cb in $disable_Checkboxes)
		{
			if (`checkBox -exists $cb`) checkBox -edit -value 0 $cb;
		}
		return;
	}
	
	
	if ($state==12)
	{
		boltSwitchSCVOptions 1;
		return;
	}
	
	if ($state==15)
	{
		boltSwitchSCVOptions 1;
		return;
	}
	
}

proc boltForceDelete(string $objs[])
{
	for ($obj in $objs)
	{
		lockNode -lock off $obj;
		delete $obj;
	}
}

proc string boltFindM()
//returns the real path of the m: drive using the dos subst command
{
	string $result = system("subst");
	//store results of the dos subst command

	string $buffer[]; tokenize($result, $buffer);
	//tokenise the result
	
	int $i = sFindItem($buffer, "M:\\:");
	//find this token

	string $path = $buffer[($i+2)];	
	//path is the token after next
	
	return $path;
}

//imported from exporter script for GE.
proc string boltConvertFromMPath(string $path)
//converts an M: based path to a real path - needed by perforce.
{
	if (`startsWith $path "M:"`)
	{
		$path = toNativePath($path);
		//make sure the path is dos compatible
		string $mPath = `boltFindM`;
		$path = `substitute "M:" $path $mPath`;
		$path = fromNativePath($path);
		//convert back to maya path slashes
	}
	if (`startsWith $path "m:"`)
	{
		$path = toNativePath($path);
		//make sure the path is dos compatible
		string $mPath = `boltFindM`;
		$path = `substitute "m:" $path $mPath`;
		$path = fromNativePath($path);
		//convert back to maya path slashes
	}
	return $path;
}



global proc boltSCV.fatal(string $msg)
{
	print "\n===================================================================================================================================================================================================";	   
	print "\nSUPER CAR VALIDATOR - FATAL ERROR!"; 
	print "\n===================================================================================================================================================================================================";	   
	print "\n  "; print $msg;
	print "\n===================================================================================================================================================================================================";	   
	error "";
}

	
global proc boltSuperCarValidate()
//super car validator
{
	global string $gBoltWarnings;
	$gBoltWarnings = "";
	// set up the string for warning messages
	
	global string $gBoltWarningsLow;
	$gBoltWarningsLow = "";
	//This string contains all low priority warnings found, to be printed seperately at the end
	
	//REMOVED FOR 2013 - not working
	//global string $gCommandWindow;
	//showWindow $gCommandWindow;
	//scriptEditorInfo -ch;
	//shows and clears the history window in script editor
	
	global string $gBoltSCV_Checkboxes[];
	
	int $wheelFile = 0;
	string $filePath = `file -q -sn`;
	if (`gmatch $filePath "*_WHEELS.mb"`) $wheelFile = 1;
	//detect whether we are checking a wheel file
	
	
	print "\n===================================================================================================================================================================================================";	   
	print "\n=== SUPER CAR VALIDATOR === SUPER CAR VALIDATOR === SUPER CAR VALIDATOR === SUPER CAR VALIDATOR === SUPER CAR VALIDATOR === SUPER CAR VALIDATOR === SUPER CAR VALIDATOR === SUPER CAR VALIDATOR ===";
	print "\n===================================================================================================================================================================================================\n";  
	print "\n__________________________________________________________________________________________________________________________________________________________________________________________________";
	print "\nUnhiding all...";
	showHidden -all;
	//unhide everything
	
	print "\nRestoring techniques and hierarchy...";
	boltRestoreTechniques;
	boltRestoreHierarchy;
	
	//throw an error if duplicate parts found	
	string $dupes = boltCheckForDupes();
	if ($dupes != "") boltSCV.fatal ("Could not run Validation due to duplicate part name(s) in scene -" + $dupes); 
	
	
	//carry out the commands for all ticked check boxes
	for ($cb in $gBoltSCV_Checkboxes)
	{
		if ( `checkBox -q -v $cb` == 1 )
		{
			print "\n__________________________________________________________________________________________________________________________________________________________________________________________________";	
			print ("\n" + `checkBox -q -label $cb`);
			print ("\n    " + `checkBox -q -ann $cb` +"\n\n");
			
			string $button = `substitute "_CheckB_" $cb "_Button_"`;
			string $cmd = `button -q -c $button`;
			eval $cmd;
			
		}
	}
	
	print "\n\n==================================================================================================================================================================================================";  
	print "\nWARNINGS...";
	
	if ($gBoltWarningsLow == "")
	{
		print "\nNo Warnings";
	}
	else
	{
		print "\n\nThese errors may cause visual or performance issues, and should ideally be fixed, but they won't affect export or functionality:\n";
		print $gBoltWarningsLow;
	}
	
	print "\n__________________________________________________________________________________________________________________________________________________________________________________________________";  
	print "\nERRORS...";	

	if ($gBoltWarnings == "")
	{
		print "\nNo Warnings";
	}
	else
	{
		print "\n\nThe following errors must be fixed:\n";
		print $gBoltWarnings;
	}
	
	print "\n==================================================================================================================================================================================================";  
	print "\nSUPER CAR VALIDATOR COMPLETE";	
	print "\n==================================================================================================================================================================================================\n";  
	
	
	
}	


/*

	
	if ((`checkBox -q -value boltCheckBox12` == 1)&&($wheelFile==0))
	{
		print "\n__________________________________________________________________________________________________________________________________________________________________________________________________";  
		print "\nWriting Log file to disk...";	
		
		boltWriteSCVLogFile;
		//write export log to disk
		
		boltWriteSwapShapesLogFile;
		//write swap log to disk
		
		string $vehicleType = `boltGetVehicleType`;
		string $filePath = `file -q -sn`;
		string $fileName = `match "[^/\\]*$" $filePath`;
		string $vehicleNo = `match "[0-9]+" $fileName`;
		string $logFileName = ("//motorstorm3/art/vehicles/carvalidatorlogs/" + $vehicleType + $vehicleNo + "_SCV.txt" );
		$fileId=`fopen $logFileName "w"`;
		string $scv = ("<SCVWarnings>\n" + $gBoltWarningsLow + $gBoltWarnings + "\n</SCVWarnings>");
		fprint $fileId $scv;
		fclose $fileId;		
		//write validator warnings to disk
		
	}
	
	*/




global proc boltSCV.checkAnimationLocators()
{
	//boltCheckSteeringAngle;
	//boltValidateLocators??
	
	global string $gBoltWarnings;
	string $msg;		
	
	if (!(objExists("IKWheel")))
	{
		$msg = ("\nAnimation locators - 'IKWheel' animation locator was not found.");
		print $msg; $gBoltWarnings += $msg;
	}
	
	print "\nAnimation locator checks complete.";
}

global proc boltSCV.testLODs()
{
	boltTestLODHierarchy;
	boltDeleteQNANs(); //infinite verts sometimes created by auto lodding
	print "\nLOD tests complete.";
}


global proc boltSCV.TestSymmetry()
{
	//slow and fairly pointless... disabled
	//boltTestAndReportSymmetry("BODY", 		95, {"BODY"});
	//boltTestAndReportSymmetry("BONNET", 	95, {"BONNET"});
	//boltTestAndReportSymmetry("BOOT", 		95, {"BOOT"});
	//boltTestAndReportSymmetry("DOORS", 		95, {"DOOR_FL","DOOR_FR"});
	//boltTestAndReportSymmetry("CAGE", 		95, {"CAGE"});
	//boltTestAndReportSymmetry("SPOILER", 	95, {"SPOILER"});
	//boltTestAndReportSymmetry("WINGS", 		95, {"WING_FL", "WING_FR", "WING_BL", "WING_BR"});
	print "\nSymmetry checks complete.";
}	

global proc boltSCV.CheckScales()
{		
	boltShearWarning;
	boltZeroObjectScales;
	print "\nObjects checked for incorrect scale and shear transforms."; 
}

global proc boltSCV.CheckUVAndColourSets()
{
	//boltRemoveColourSets;
	boltCheckColourSetNames;
	boltCheckUVSetNames;
	print "\nColour and UV set checks complete.";
	
	print "\nSetting tempered glass to a single lookup colour...";
	
	//doesn't work with debug shaders on

	string $windows[] = {"WINDOW_B","WINDOW_B2","WINDOW_BL","WINDOW_BR","WINDOW_FL","WINDOW_FL2","WINDOW_FR","WINDOW_FR2","WINDOW_T","WINDOW_TL","WINDOW_TR",
		"WINDOW_B_LOD1","WINDOW_B2_LOD1","WINDOW_BL_LOD1","WINDOW_BR_LOD1","WINDOW_FL_LOD1","WINDOW_FL2_LOD1","WINDOW_FR_LOD1","WINDOW_FR2_LOD1","WINDOW_T_LOD1","WINDOW_TL_LOD1","WINDOW_TR_LOD1",
		"WINDOW_B_LOD2","WINDOW_B2_LOD2","WINDOW_BL_LOD2","WINDOW_BR_LOD2","WINDOW_FL_LOD2","WINDOW_FL2_LOD2","WINDOW_FR_LOD2","WINDOW_FR2_LOD2","WINDOW_T_LOD2","WINDOW_TL_LOD2","WINDOW_TR_LOD2",
		"WINDOW_B_LOD3","WINDOW_B2_LOD3","WINDOW_BL_LOD3","WINDOW_BR_LOD3","WINDOW_FL_LOD3","WINDOW_FL2_LOD3","WINDOW_FR_LOD3","WINDOW_FR2_LOD3","WINDOW_T_LOD3","WINDOW_TL_LOD3","WINDOW_TR_LOD3",
		"WINDOW_B_LOD4","WINDOW_B2_LOD4","WINDOW_BL_LOD4","WINDOW_BR_LOD4","WINDOW_FL_LOD4","WINDOW_FL2_LOD4","WINDOW_FR_LOD4","WINDOW_FR2_LOD4","WINDOW_T_LOD4","WINDOW_TL_LOD4","WINDOW_TR_LOD4",
		"WINDOW_B_LOD5","WINDOW_B2_LOD5","WINDOW_BL_LOD5","WINDOW_BR_LOD5","WINDOW_FL_LOD5","WINDOW_FL2_LOD5","WINDOW_FR_LOD5","WINDOW_FR2_LOD5","WINDOW_T_LOD5","WINDOW_TL_LOD5","WINDOW_TR_LOD5",
		"WINDOW_B_SHADOW","WINDOW_B2_SHADOW","WINDOW_BL_SHADOW","WINDOW_BR_SHADOW","WINDOW_FL_SHADOW","WINDOW_FL2_SHADOW","WINDOW_FR_SHADOW","WINDOW_FR2_SHADOW","WINDOW_T_SHADOW","WINDOW_TL_SHADOW","WINDOW_TR_SHADOW"};
	$windows = `ls -long -type "transform" $windows`;
	python("import superVertPaint");
	for ($obj in $windows)
	{
		if (objExists($obj))
		{
			
			string $verts[] = `ls -fl ($obj+".vtx[*]")`;
			int $glassAO = 0;
			for ($v in $verts)
			{
				float $cols[] =  `polyColorPerVertex -q -a $v`;
				if ($cols[0] < 0.99) $glassAO = 1;
			}
			global string $gBoltWarnings;
			if ($glassAO)
			{
				$msg = ("\nWindow Occlusion Warning - AO was found on " + $obj + " - this can look bad, try setting all glass AO to 1.0");
				print $msg; $gBoltWarnings += $msg;
			}
			print ("\nChecked window occlusion levels for " + $obj); 
		}
	}
	for ($obj in $windows)
	{
		if (objExists($obj))
		{
			
			string $materials[] = boltGetMaterialsOnObj($obj);
			for ($mat in $materials)
			{
				$xmlpath =  boltGetShaderPreset($mat);
				if ((`gmatch $xmlpath "*glass_toughened_damage.xml"`) ||
				    (`gmatch $xmlpath "*glass_toughened_damage_inside.xml"`) ||
				    (`gmatch $xmlpath "*glass_toughened_damage_outside.xml"`))
				{
					print ("\nPainting single lookup colour to: " + $obj);
					python (("superVertPaint.paintDamageLookup('" + $obj + "',1)"));
				}
			}
		}
	}

}	

global proc boltSCV.testMud()
{
	boltCheckMudOcc;
	//boltTestExhaustColours;
}
	
global proc boltSCV.tidyShaders()
{
	boltDeleteUnusedShaders;
	boltLowerCaseShaders;
}

global proc boltSCV.fixVertexColours()
{
	//fix crazy (20gb+) memory use... despite alread using the -nun flag.
	undoInfo -state on -infinity off -length 200;
	undoInfo -state off;
		
	string $objList[] = `ls -type mesh`;
	$objList = boltShapesToTransformsNoPath($objList);
	$objList = stringArrayRemoveDuplicates($objList);
	
	for ($obj in $objList)
	{
		//print "\n"; print $obj; 
		
		int $vertCounts[] = `polyEvaluate -vertex $obj`;
		int $vertCount = $vertCounts[0];
		//get num of verts
				
		int $fixFlag = 0;
		int $fixFlagRGB = 0;
		
		//FIX FOR 2013 - can't handle lack of colour set
		string $colourSets[] = `polyColorSet -q -currentColorSet $obj`;
		if ($colourSets[0] != "")		
		{
			
			for ( $v = 0; $v < $vertCount; $v++ )
			//for each vert
			{
						
				float $vertA[] 	 = `polyColorPerVertex -q -a -nun ($obj + ".vtx[" + $v +"]")`;
				//get alpha
						
				if ($vertA[0] > 1)
				{
					polyColorPerVertex -a 1 -nun ($obj + ".vtx[" + $v +"]");
					$fixFlag ++;
					$vertA[0] = 1;
				}
				if ($vertA[0] < 0)
				{
					polyColorPerVertex -a 0 -nun ($obj + ".vtx[" + $v +"]");
					$fixFlag ++;
					$vertA[0] = 0;
				}
				//cap this value if necessary.
			
			
				float $vertRGB[] 	 = `polyColorPerVertex -q -rgb -nun ($obj + ".vtx[" + $v +"]")`;
				//get RGB
				int $rgbChanged = 0;
				for ($i = 0; $i < 3; $i++)
				{
					if ($vertRGB[$i] > 1)
					{
						$vertRGB[$i] = 1;
						$rgbChanged = 1;
					}
					if ($vertRGB[$i] < 0)
					{
						$vertRGB[$i] = 0;
						$rgbChanged = 1;
					}
				}
				if ($rgbChanged == 1)
				{
					$fixFlagRGB ++;
					polyColorPerVertex -rgb $vertRGB[0] $vertRGB[1] $vertRGB[2] -a $vertA[0] -nun ($obj + ".vtx[" + $v +"]");
				}
				//only update vert colour if necessary.
			}
		}
				
		if ($fixFlag != 0)
		{
			print ("\n" + $fixFlag + " vertex alphas fixed on " + $obj);
		}
		if ($fixFlagRGB != 0)
		{
			print ("\n" + $fixFlagRGB + " vertex RGBs fixed on " + $obj);
		}
		
		
	}
	
	undoInfo -state on -infinity off -length 200;
	
	print "\nVertex colour fixes complete\n"; 
}

global proc boltSCV.corruptSGs()
{
	global string $gBoltWarnings; 
	
	string $msg = "";
	$objs = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	for ($obj in $objs)
	{
		$msg = boltTestForShadingGroupErrors($obj);
		if ($msg != "")
		{
			print $msg;
			$gBoltWarnings += $msg;
		}
	}
	//boltReApplyAllShaders();
	//new script seems to work faster and fixes dissapearing shaders
	//boltRefreshShaders;
	//refreshes shading groups - fixes problems with lod shaders
	
	boltTidyShaders;
	//removes unused lambertSG links
	
	//miloDelVoidShaderGRPConns2;
	//removes pointless connections
	
	print "\nShading groups checked.";
	
}

global proc string boltTestForShadingGroupErrors(string $obj)
//tests whether multiple shaders are assigned to individual polygons
{
	int $noFaces[] = {};

	if ( catchQuiet($noFaces = `polyEvaluate -face $obj`) )
	{
		return ("\nGeometry Error - No faces found on " + $obj + ". There is a problem with this part.");
	}

	int $shadedFaces = 0;

	string $shaders[] = boltGetMaterialsOnObj($obj);

	for ($shader in $shaders)
	{
		$shadedFaces += size(boltListShadedPolygons( {$obj} , $shader ));
	}

	if ($noFaces[0] != $shadedFaces)
	{
		print ("\n" + $noFaces[0] + " polys found on " + $obj);
		print ("\n" + $shadedFaces + " shaded faces found in SGs on " + $obj);
	}

	if ($shadedFaces>$noFaces[0])
	{
		return ("\nShader Error - " + ($shadedFaces-$noFaces[0]) + " faces on " + $obj + " have more than one shader assigned to them.");
	}
	if ($shadedFaces<$noFaces[0])
	{
		return ("\nShader Error - " + ($noFaces[0]-$shadedFaces) + " faces on " + $obj + " have missing shaders.");
	}

	return "";
}

//backup the file before running SCV
global proc boltSCV.backup()
{
	$oldName = `file -q -exn`;
	file -rename "C:/SCVbackup.mb";
	file -save -type "mayaBinary";
	file -rename $oldName;
	print "\nBackup saved to C:/SCVbackup.mb";
}

//clean havok from lods, shadows and occluders nodes
global proc boltSCV.cleanHavok()
{
	string $lods[] = `ls "*_LOD?"`;
	for ($lod in $lods) boltDeleteHavokNodes $lod;
	
	string $occs[] = `ls "*_OCC"`;
	for ($occ in $occs) boltDeleteHavokNodes $occ;
	
	string $shads[] = `ls "*_SHADOW"`;
	for ($shad in $shads) boltDeleteHavokNodes $shad;
	
	print "\nUnwanted Havok nodes removed";
}

global proc boltSCV.deleteHistory()
{		
		boltRemoveHierarchy;
		boltLockLocs 1;
		delete -all -constructionHistory;
		boltLockLocs 0;
		boltRestoreHierarchy;
		//delete construction history for everything
}

global proc boltSCV.mayaClean()
{
	boltRemoveHierarchy;
	boltLockLocs 1;
	
	putenv "MAYA_TESTING_CLEANUP" "1"; //turns of "OK" requester
	
	source "cleanUpScene.mel";
	scOpt_performOneCleanup( {
		"nurbsSrfOption",
		"nurbsCrvOption",
		//"locatorOption",
		"clipOption",
		"poseOption",
		"ptConOption",
		"pbOption",
		"deformerOption",
		"unusedSkinInfsOption",		
		"expressionOption",
		"groupIDnOption",
		"animationCurveOption",
		"snapshotOption",
		"unitConversionOption",
		//"shaderOption",
		"cachedOption",
		"transformOption",
		"displayLayerOption",
		"renderLayerOption",
		"setsOption",
		"partitionOption",
		"referencedOption",
		"brushOption"
		//"shadingNetworksOption" - results in a ton of ATG spam
	});
	//optimise scene - but don't remove unused shaders / unused locators
	
	putenv "MAYA_TESTING_CLEANUP" ""; //turns "OK" requester back on
	
	boltLockLocs 0;
	boltRestoreHierarchy;
}

global proc boltSCV.deleteLayers()
//removes all layers from scene
{
	//these fix broken default display layers + layer manager from glass egg.
	
	string $layers[] = `ls -type "displayLayerManager"`;
	for ($l in $layers)
	{
		if ($l != "layerManager")
		{
			catchQuiet( `lockNode -lock 0 $l`);
			catchQuiet( `delete $l` );
		}
	}
	string $layers[] = `ls -type "displayLayerManager"`;
	if (size($layers) == 0)
	{
		createNode "displayLayerManager" -n "layerManager";
   		lockNode "layerManager";
   	}
	
	
	string $layers[] = `ls -type "displayLayer"`;
	for ($l in $layers)
	{
		if ($l != "defaultLayer") 
		{
			catchQuiet( `lockNode -lock 0 $l`);
			catchQuiet( `delete $l` );
		}
	} 
	string $layers[] = `ls -type "displayLayer"`;
 	if (size($layers) == 0)
	{
		createDisplayLayer -name "defaultLayer" -empty;
    	lockNode "defaultLayer";
    }
	
	string $layers[] = `ls -type "displayLayer"`;
	string $defaultLayer = $layers[0];
		
	string $object;
	string $objectList[] = `ls -transforms -long`;
	
	for ($object in $objectList)
	{
		editDisplayLayerMembers $defaultLayer $object;
	}
	//move everything to defaultLayer (always exists)
	
	layerEditorSelectUnused; layerEditorDeleteLayer "";
	//delete layers
	print "\nLayers Deleted";
}
	
global proc boltSCV.deleteWTK()
{		
	boltRemoveHierarchy;
	if (size(`ls -transforms "miloCam*"`)) delete `ls -transforms "miloCam*"`;
	string $del[] = `ls "EWT_Locator*"`;
	for ($node in $del)
	{
		lockNode -lock off $node; 
		delete $node;
	}
	string $del[] = `ls "GlobalDrawer*"`;
	for ($node in $del)
	{
		lockNode -lock off $node; 
	delete $node;
	}
	//delete any world tool nodes.
	boltRestoreHierarchy;  
	print "\nWorld Tool Kit Nodes Deleted";
}
	
global proc boltSCV.sceeClean()
//modified version of scee scene purge.
{
	boltRestoreHierarchy;
	boltRestoreTechniques;
	//important to run these first as purge scene deletes the scriptNodes that remember techniques and hierarchy
	
	int $count = 0;
	print "\n// Scene Purge Starting... //\n";

	// custom "optimize scene size"
	print "\n// Optimizing Scene //\n// ================ //\n\n";
	// ** These are ALL Maya out-of-the-box-default scripts:
	catch($count+=`deleteEmptyGroups`);		// TRANSFORMS
	// non DAG:
	catch($count+=`deleteUnusedBrushes`);	// BRUSHES
	catch(`delete(getDefaultBrush())`);		// default brush is not deleted by `deleteUnusedBrushes`
	catch($count+=`deleteUnusedSets`);		// SETS
	catch($count+=`deleteUnusedTrax clips`);	// ANIM CHANNELS
	catch($count+=`deleteUnusedDeformers`);	// DEFORMERS
	catch($count+=`deleteInvalidNurbs 0`);	// INVALID NURBS SURFACES
	catch($count+=`RNdeleteUnused`);		// REFERENCE NODES
	catch($count+=`deleteUnusedExpressions`);	// EXPRESSIONS
	catch($count+=`deleteUnusedCommon "groupId" 0 "Deleting unused groupID nodes"`);
	catch($count+=`deleteUnusedCommon "materialInfo" 1 "Deleting unused materialInfo nodes"`);
	catch($count+=`deleteUnusedCommon "script" 1 "Deleting unused script nodes"`); // scriptNodes
	catch($count+=`deleteUnusedCommon "dagPose" 1 "Deleting unused dagPose nodes"`); // scriptNodes
	catch($count+=`deleteUnusedCommon "objectFilter" 1 "Deleting unused objectFilter nodes"`); // scriptNodes
	catch($count+=`deleteUnusedCommon "unknown" 1 "Deleting unused unknown nodes"`); // unknowns

	// finally, we want to remove any poly history nodes that are not connected to any meshes
	catch($count+=`deleteUnusedCommon "polyBase" 1 "Deleting unused polyBase history nodes"`); // polyModifier

	print ("// Scene Purge Complete - "+$count+" unused nodes Removed. Check Script Editor for Details... //\n");
}	

global proc boltSCV.evoClean()
{
	boltRemoveHierarchy;
	boltLockLocs 1;
	
	boltSCV.evosDeleteEmptyMehses();
	boltSCV.evosDeleteIsolatedMehses();
	boltSCV.evosDeletehkNodeOptions();
	boltSCV.evosDeleteIsolatedDisplayLayers();
	boltSCV.evosDeleteIsolatesShapes();
	boltSCV.evosDeleteUnknownNodes();
	boltSCV.evosDeleteEWTLocatorNodes();
	boltSCV.evosDeleteIsolatedIntermediateMeshes();
	select -clear;
	boltSCV.evosDeleteIsolatedPhysics(); //(relies on selections so select -clear needed)
	select -clear;
	//run Mark's cleanup routines
	
	//delete all imported bookmarks
	delete `ls -type "cameraView"`;
	
			
	//boltSCV.evosSetDefaultConvexRadius();
	//run stuff from evospreflightchecks (not in preflight checks any more)
			
	boltLockLocs 0;
	boltRestoreHierarchy;                                                     
}

//checks scene for multiple name spaces
global proc boltSCV.checkNameSpaces()
{
	global string $gBoltWarnings;
	string $msg;
	
	string $nodes[] = `ls`;
	string $nameSpaces[] = {};
	for ($node in $nodes)
	{
		if (`gmatch $node "*:*"`)
		{
			string $buffer[];  
			tokenize $node ":" $buffer;  
			string $nameSpace = "";
			for ($i=0; $i<(size($buffer)-1); $i++)
			{
    			$nameSpace = $nameSpace + $buffer[$i] + ":";
    		}  
			$nameSpaces[size($nameSpaces)] = $nameSpace;
		}
	}
	$nameSpaces = stringArrayRemoveDuplicates($nameSpaces);
	
	if (size($nameSpaces) > 0)
	{	
		for ($nameSpace in $nameSpaces)
		{
			$msg = ("\nNamespace Warning - '" + $nameSpace + "' namespace was found on nodes in the scene. This is probably caused by bad imports (not using 'Import Clean' tool). ");
			$msg += ("Most of the affected nodes are probably spam - disable 'DAG Objects Only' in Outliner to investigate the problem nodes.");
			print $msg; $gBoltWarnings += $msg;
		}
	}
}		

////////////////////////////////////////////////////from evoscleanup.mel

global proc boltSCV.evosDeleteEmptyMehses()
{
	int $numDeleted = 0;
	print("Deleting empty meshes...\n");
	string $meshes[] = `ls -l -typ mesh`;
	for($mesh in $meshes)
	{
		int $count = 0;

		int $numFaces[];

		//
		// Meshes without any faces cause polyEvaluate to return an error string.
		//
		if (catchQuiet ($numFaces = eval("polyEvaluate -face " + $mesh)))
		{
			print "Empty mesh\n";
		}
		else
		{
			for($i = 0; $i < size($numFaces); $i++)
			{
				$count += $numFaces[0];
			}
		}

		if($count == 0)
		{
			//
			// Meshes may be read-only -> protect with a catch
			//
			if(!catchQuiet( `delete $mesh` ))
				++$numDeleted;
		}	
	}
	print($numDeleted + " nodes deleted.\n");
}

global proc boltSCV.evosDeleteIsolatedMehses()
{
	print("Deleting isolated meshes...\n");
	int $numDeleted = 0;

	string $meshes[] = `ls -l -typ mesh`;
	for($mesh in $meshes)
	{
		string $conn[] = eval("listConnections -d 1 -s 1 " + $mesh); 
		if(size($conn) == 0)
		{
			//
			// Meshes may be read-only -> protect with a catch
			//
			if(!catchQuiet( `delete $mesh` ))
				++$numDeleted;
		}
	}
	print($numDeleted + " nodes deleted.\n");
}

global proc boltSCV.evosDeletehkNodeOptions()
{
	print("Deleting hkNodeOptions nodes...\n");
	int $numDeleted = 0;

	string $nodes[] = `ls -typ hkNodeOptions`;
	for($f in $nodes)
	{
		if(!catchQuiet( `delete $f` ))
			++$numDeleted;
	}
	print($numDeleted + " nodes deleted.\n");
}

global proc boltSCV.evosDeleteIsolatedDisplayLayers()
{
	print("Deleting isolated displayLayer nodes...\n");
	int $numDeleted = 0;

	// Delete isolated displayLayers
	string $nodes[] = `ls -typ displayLayer`;
	for($f in $nodes)
	{
		// Check if the displayLayer is connected to the layer manager.
		string $conns[] = eval("listConnections -source 1 -destination 0 " + $f + ".identification");
		if(size($conns) == 0)
		{
			// No, so we are going to delete it.
			if(!catchQuiet( `delete $f` ))
				++$numDeleted;
		}
	}
	print($numDeleted + " nodes deleted.\n");
}

global proc int boltSCV.evosDeleteIsolatedShapeType(string $nt)
{
	print("Deleting isolated " + $nt + " nodes...\n");
	int $numDeleted = 0;
	string $shapes[] = eval("ls -l -typ " + $nt);
	for($shape in $shapes)
	{
		int $found = 0;
		string $conn[] = eval("listConnections -d 1 -s 0 " + $shape); 
		for($c in $conn)
		{
			string $type = `nodeType $c`;
			if($type == "transform")
				$found = 1;
		}
		if(!$found)
		{
			if(!catchQuiet(`delete $shape`))
				++$numDeleted;
		}
	}
	return $numDeleted;
}

global proc boltSCV.evosDeleteIsolatesShapes()
{
	int $numDeleted = 0;
	$numDeleted += boltSCV.evosDeleteIsolatedShapeType("polySphere");
	$numDeleted += boltSCV.evosDeleteIsolatedShapeType("polyCube");
	$numDeleted += boltSCV.evosDeleteIsolatedShapeType("polyCylinder");
	$numDeleted += boltSCV.evosDeleteIsolatedShapeType("polyCone");
	$numDeleted += boltSCV.evosDeleteIsolatedShapeType("polyPlane");
	$numDeleted += boltSCV.evosDeleteIsolatedShapeType("polyTorus");
	print($numDeleted + " nodes deleted.\n");
}

global proc boltSCV.evosDeleteUnknownNodes()
{
	print("Deleting unknown nodes...\n");
	int $numDeleted = 0;
	string $unknownNodes[] = `ls -l -typ unknown`;
	for($u in $unknownNodes)
	{
		if(!catchQuiet( `delete $u`))
			++$numDeleted;
	}
	print($numDeleted + " unknown nodes deleted.\n");
}

global proc boltSCV.evosDeleteEWTLocatorNodes()
{
	print("Deleting EWTLocator Nodes...\n");
	int $numDeleted = 0;
	//string $sel[] = `ls -l -typ EWT_Locator`;
	string $sel[] = `ls -fl "*EWT_Locator*"`;  // To avoid the need for the plugin to be loaded
	for($s in $sel)
	{
		string $rels[] = `listRelatives -fullPath -parent -typ transform $s`;
		for($r in $rels)
		{
			lockNode -l off $r;
			lockNode -l off $s;
			if(!catchQuiet(`delete $s`))
				++$numDeleted;
			if(!catchQuiet(`delete $r`))
				++$numDeleted;
		}
	}
	print($numDeleted + " nodes deleted.\n");
}

global proc boltSCV.evosDeleteIsolatedIntermediateMeshes()
{
	print("Deleting isolated intermediate meshes...\n");
	int $numDeleted = 0;

	int $numxforms = 0;
	string $rootxforms[];

	string $xforms[] = `ls -l -typ transform`;
	for($x in $xforms)
	{
		// Only interested in root nodes
		string $parents[] = `listRelatives -parent -fullPath $x`;
		if(size($parents) > 0)
			continue;

		$rootxforms[$numxforms] = $x;
		$numxforms++;
	}

	for($x in $rootxforms)
	{
		int $found = 0;
		int $meshFound = 0;

		// find all descendents that are meshes.
		string $rels[] = `listRelatives -allDescendents -fullPath $x`;
		for($r in $rels)
		{
			if(`nodeType $r` == "mesh")
			{
				int $intermediate = eval("getAttr " + $r + ".intermediateObject");
				if($intermediate == 0)
				{
					$found = 1;
					break;	
				}
				$meshFound = 1;
			}
		}

		// If there are meshes as descendents and they are all intermediates, delete everthing.
		if(!$found && $meshFound)
		{
			//
			// Meshes may be read-only -> protect with a catch
			//
			if(!catchQuiet( `delete $x` ))
				++$numDeleted;
		}
	}
	print($numDeleted + " nodes deleted.\n");
}

global proc boltSCV.evosDeleteIsolatedPhysics()
{
	print("Deleting isolated physics nodes...\n");
	int $numDeleted = 0;

	select -cl;
	string $rbs[] = `ls -l -typ hkNodeRigidBody`;
	for($r in $rbs)
	{
		string $parents[] = `listRelatives -fullPath -parent $r`;
		for($p in $parents)
		{
			// Look for descendents that are meshes
			string $desc[] = `listRelatives -allDescendents -type mesh $p`;
			if(size($desc) == 0)
			{
				select -tgl $p;
				++$numDeleted;
			}
		}
	}
	delete;
	print($numDeleted + " deleted.\n");
}
////////////////////////////////////////////////////////////////////////////////////////////////////////////
///////// end of evoscleanup scripts









global proc boltShearWarning()
//warns user if any objects have a shear applied
{
	global string $gBoltWarnings;
	string $msg;		
	
	boltRemoveHierarchy;
	
	$nodes = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	$nodes = stringArrayRemoveDuplicates($nodes);
	
	for ($node in $nodes)
	{
		float $sx = `getAttr ($node + ".shearXY")`;                                                        
		float $sy = `getAttr ($node + ".shearXZ")`;                                                        
		float $sz = `getAttr ($node + ".shearYZ")`; 
		
		int $ex = `equivalentTol $sx 0 0.0001`;
		int $ey = `equivalentTol $sy 0 0.0001`;
		int $ez = `equivalentTol $sz 0 0.0001`;
		//close to 0?
		
		if ( ($ex == 0) || ($ey == 0) || ($ez == 0) )
		//if the shear needs fixing
		{
			$msg = ("\nShear Error - " + $node + " has a non zero shear value. You will need to fix this manually, and also check for any affected child objects.");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	boltRestoreHierarchy;
}

global proc boltZeroObjectScales()
//ensures that none of the meshes in the scene have any scale applied to them
{
	global string $gBoltWarnings;
	string $msg;		
	
	boltRemoveHierarchy;
	
	$nodes = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	$nodes = stringArrayRemoveDuplicates($nodes);
	
	for ($node in $nodes)
	{
		float $sx = `getAttr ($node + ".scaleX")`;                                                        
		float $sy = `getAttr ($node + ".scaleY")`;                                                        
		float $sz = `getAttr ($node + ".scaleZ")`;                                                        
		//get scales
		
		int $ex = `equivalentTol $sx 1 0.0001`;
		int $ey = `equivalentTol $sy 1 0.0001`;
		int $ez = `equivalentTol $sz 1 0.0001`;
		//close to 1?
		
		int $cx = `connectionInfo -isDestination ($node + ".scaleX")`;
		int $cy = `connectionInfo -isDestination ($node + ".scaleY")`;
		int $cz = `connectionInfo -isDestination ($node + ".scaleZ")`;
		//is the scale connected
				                                                                                             
		if ( ($ex == 0) || ($ey == 0) || ($ez == 0) )
		//if the scale needs fixing
		{  
			zeroObjectScale $node;
			                                                                                              
			if (($ex == 0) && ($cx == 1))
			{
				$msg = ("\nScale Error - Could not reset scale for " + $node + ".scaleX - probably due to an animation constraint. To fix this scale you will need to unrig this node, run the validator again, and then re-rig it.");
				print $msg; $gBoltWarnings += $msg;
			}
            if (($ey == 0) && ($cy == 1))
			{
				$msg = ("\nScale Error - Could not reset scale for " + $node + ".scaleY - probably due to an animation constraint. To fix this scale you will need to unrig this node, run the validator again, and then re-rig it.");
				print $msg; $gBoltWarnings += $msg;
			}
			if (($ez == 0) && ($cz == 1))
			{
				$msg = ("\nScale Error - Could not reset scale for " + $node + ".scaleZ - probably due to an animation constraint. To fix this scale you will need to unrig this node, run the validator again, and then re-rig it.");
				print $msg; $gBoltWarnings += $msg;
			}
			//warn about locked nodes with scale
		}
	}                                                                             
	
	boltRestoreHierarchy;
}





global proc boltCheckTextures()
//checks misc texture stuff - dimensions, file format, paths
//missing textures, empty texture bindings
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;
	string $msg;	
	
	//get rid of these WTK swatches - multiple copies spreading through scenes.
	boltForceDelete `ls "*wtkObjectSwatch*"`;
	
	string $textures[] = `ls -type "file"`;
	
	float $okSizes[] = {1,2,4,8,16,32,64,128,256,512,1024,2048,4096};
	for ($texture in $textures)
	{
		float $xSize = `getAttr($texture+".outSizeX")`;
		float $ySize = `getAttr($texture+".outSizeY")`;
		
		string $file = `getAttr ($texture + ".fileTextureName")`;
		string $file = `tolower $file`; //convert to lowercase
		string $file = `fromNativePath $file`; //make sure forward slashes are used
		string $sceneName = `boltSCV.GetVehicleName`;
		$sceneName = `tolower $sceneName`;
		string $root = "m:";
		string $fileName = `basename $file ""`;
		
		if (`substitute " " $file ""` != $file )
		{
			$msg = ("\nTexture Name Error - " + $texture + " (" + $file + ") contains a space in its file name or path - this will cause problems with perforce");
			print $msg; $gBoltWarnings += $msg;
		}
		
		if ($file != ($root + "/art/vehicles/generic_textures/test/" + $fileName)) //don't warn about debug textures
		{		
			if ((`fFindItem $okSizes $xSize` == -1) || (`fFindItem $okSizes $ySize` == -1))
			{
				$msg = ("\nTexture Size Error - " + $texture + " has an invalid width or height");
				print $msg; $gBoltWarnings += $msg;
			}
			//check that texture sizes are valid
		}
		
		if ($file == ($root + "/art/vehicles/" + $sceneName + "/textures/" + $fileName)) //only allow tifs in this folder.
			 //($file == ($root + "/art/vehicles/generic_textures/" + $fileName)) ) 
		{
			if (`match ".tif$" $file` != ".tif")
			{
				$msg = ("\nTexture Format Error - " + $texture + " (" + $file + ") does not appear to be in .tif format.");
				print $msg; $gBoltWarnings += $msg;
			}
			//check for texture format
		}
		else if ($file != ($root + "/art/vehicles/generic_textures/test/" + $fileName))//don't warn about test jpegs
		{
			if ( (`match ".tif$" $file` != ".tif") && (`match ".dds$" $file` != ".dds") )
			{
				$msg = ("\nTexture Format Error - " + $texture + " (" + $file + ") does not appear to be in .tif or .dds format.");
				print $msg; $gBoltWarnings += $msg;
			}
			//check for texture format	
		}
			
		//test mip settings
		string $exemptTextures[] = {
			"frame_buffer_proxy.dds",
			"mudnormal_dirt.dds",
			"damagenormal_scratches.dds",
			"carbon_02_tang.tif",
			"carbon_02_norm.tif",
			"GenericHeadlightMask.tif",
			"headlight_mask.tif",
			"lightlens_data.dds",
			"light_lookup_maya.tif",
			"microfacetdistribution.dds"
			};
		
		string $conns[] = `listConnections $texture`;
		
		if ((sFindItem($exemptTextures, $fileName) == -1)
			&& (sFindItem($conns, "HEADLIGHT_FL") == -1)
			&& (sFindItem($conns, "HEADLIGHT_FR") == -1) 
			&& (gmatch ($file,"*cubemaps*") ==0) 
			&& (gmatch ($file,"*generic_textures*") ==0)) 
		{
			int $wrongMip = 0;
			if (`getAttr ($texture + ".AtgSamplerStateMinFilter")` != 5) $wrongMip = 1;
			if (`getAttr ($texture + ".AtgSamplerStateLodBias")` != 0) $wrongMip = 1;
			
			if ($wrongMip == 1)
			{
				$msg = ("\nTexture Mip Warning - " + $texture + " (" + $file + ") does not use the best MIP settings of 'linear mipmap linear' and lod bias '0'. Please fix unless there is a good reason for the current setting.");
				print $msg; $gBoltWarningsLow += $msg;
			}
		}
		
		int $pathOK = 0;
				
		if ($file == ($root + "/art/vehicles/" + $sceneName + "/textures/" + $fileName)				) $pathOK = 1;
		//if ($file == ($root + "/art/vehicles/wheels/textures/" + $fileName)						) $pathOK = 1;
		if ($file == ($root + "/art/vehicles/generic_textures/" + $fileName)						) $pathOK = 1;
		if ($file == ($root + "/art/vehicles/generic_textures/test/" + $fileName)					) $pathOK = 1;
		if ($file == ($root + "/art/vehicles/generic_textures/paint_colours/" + $fileName)			) $pathOK = 1;
		if ($file == ($root + "/art/cubemaps/" + $fileName)											) $pathOK = 1;
		if ($file == ($root + "/art/shaders/textures/" + $fileName)									) $pathOK = 1;
		if ($file == ($root + "/art/" + $fileName)													) $pathOK = 1;
		if ($file == ($root + "/art/arttech/vehicles/" + $fileName)									) $pathOK = 1;
		if ($file == ($root + "/art/arttech/clouds/" + $fileName)									) $pathOK = 1;
		if ($file == ($root + "/assets/global/" + $fileName)										) $pathOK = 1;
		if ($file == ($root + "/assets/global/pc/" + $fileName)										) $pathOK = 1;
		if ($file == ($root + "/assets/global/textures/" + $fileName)								) $pathOK = 1;
		if ($file == ($root + "/assets/defaulttextures/" + $fileName)								) $pathOK = 1;

		if ($pathOK == 0)
		{
			$msg = ("\nTexture Path Error - " + $file + " is not a valid texture path for this vehicle relative to the scene name `" + $sceneName + "`. \n - Check texture locations and Maya scene name are correct, do not use textures from another vehicle's texture folder. Reference all textures from " + $root);
			print $msg; $gBoltWarnings += $msg;
		}
		
		boltSCV.checkTexturesAreOnPerforce($file);
		
		if ((sFindItem($exemptTextures, $fileName) == -1)
			&& (gmatch ($file,"*cubemaps*") ==0) 
			&& (gmatch ($file,"*.dds") ==0)) 
		{
			boltSCV.checkTifTags($file, $texture);
		}
	}
	
	//check window colour texture sizes
	string $mats[] = `ls -type "ATGMaterial"`;
	string $foundTextures[] = {};
	for ($mat in $mats)
	{
		string $attrs[] = `listAttr $mat`;
		for ($attr in $attrs)
		{
			if (`gmatch $attr "*_texture_OpaqueColourMap*"`)
			{
				print ("\nFound window colour map: " + $mat + "." + $attr);
				string $path = `getAttr ($mat + "." + $attr)`;
				if ($path == "")
				{
					$msg = ("\nShader warning - Empty texture slot found: " + $mat + "." + $attr);
					print $msg; //$gBoltWarnings += $msg;
				}
				else
				{
				 	$foundTextures[size($foundTextures)] = $path;
				}
			}
		}
	}
	$foundTextures = stringArrayRemoveDuplicates($foundTextures);
	
	for ($tex in $foundTextures)
	{
		string $cmd = "superTextureTools.getTextureSize(\"" + $tex + "\")";
		int $size[] = python($cmd);
		int $x = $size[0]; int $y = $size[1]; 
		if (($x > 256) || ($y > 256))
		{
			$msg = ("\nWindow texture size warning - Window colour maps can usually be 256x256 or smaller - " + $tex + " is " + $x + "x" + $y);
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	//check headlamp texture path
	
	for ($lamp in {"HEADLIGHT_FL","HEADLIGHT_FR"})
	{
		if (`objExists $lamp`)
		{
			string $cons[] = `listConnections ($lamp + ".color")`;
			string $path = `getAttr ($cons[0] + ".fileTextureName")`;
			if ($path != "M:/art/vehicles/GENERIC_TEXTURES/headlight_mask.tif")
			{
				$msg = ("\nHeadlamp texture error - " + $lamp + " should be using /GENERIC_TEXTURES/headlight_mask.tif as a colour mask. Found: " + $path);
				print $msg; $gBoltWarnings += $msg;
			}
		}
		else
		{
			$msg = ("\nHeadlamp texture error - " + $lamp + " not found in scene - so couldn't check for correct texture");
			print $msg; $gBoltWarnings += $msg;
		}	
	}
	
	boltSCV.checkForEmptyTextureBindings();
	
	print "\nTexture paths and formats checked.";
}



global proc boltSCV.checkTifTags(string $file, string $texture)
//runs the tif tag checker from evo export
{
	global string $gBoltWarnings;
	string $msg;
	
	python ("import imageMetadata");
	$path = fromNativePath($file);
	
	print ("\ntesting tif tag for " + $path);
	
	if (`filetest -e $path` == 0)
	{
		$msg = ("\nTexture File Error - '" + $path + "' referenced by texture node " + $texture + " does not exist on disk. This will cause the build to fail.");
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	
	if (`gmatch $path "*paint_colours*"`)
	{
		//ignore paint colour swatches - their tif tags are not recognised
		return;
	}
	
	
	$cmd = "imageMetadata.testTifTagsInFiles([\"" + $path + "\"])";
	string $result[] = python ($cmd);
	if (size($result) > 0)
	{
		$msg = ("\nTIFF Tagging Error - '" + $file + "' has missing or incorrect tif tags! This will cause the build to fail.");
		print $msg; $gBoltWarnings += $msg;
	} 
	
	$cmd = "imageMetadata.getTifTag('" + $path + "','" + "mipproc" + "')";
	string $mipproc = python ($cmd);
	if (($mipproc != "catmullrom") && ($mipproc != "catmullrom_sharper"))
	{
		$msg = ("\nTIFF Tagging Error - '" + $file + "' has missing/incorrect 'mipproc' tag! Should be 'mipproc=catmullrom' or 'mipproc=catmullrom_sharper'");
		print $msg; $gBoltWarnings += $msg;
	}
}
	


global proc boltSCV.checkTexturesAreOnPerforce(string $file)
//warns about any textures not submitted to perforce.
{
	global string $gBoltWarnings;
	string $msg;	
	
	string $result = system ("p4 files " + boltConvertFromMPath($file));
	if (gmatch($result,"*no such file(s)*")) 
	{
		$msg = ("\nTexture '" + $file + "' was not found on perforce. This will cause the build to fail.");
		print $msg; $gBoltWarnings += $msg;
	}
}

global proc boltSCV.checkForEmptyTextureBindings()
{
	
	global string $gBoltWarnings;
	string $msg;	
	
	$shaders = `ls -type "ATGMaterial"`;
	
	for ($shader in $shaders)
	{
		string $attrs[] = `listAttr $shader`;
		string $texSlots[] = {};
		for ($attr in $attrs)
		{
			if ( gmatch($attr, "Mat_texture_*") ==1 ) $texSlots[size($texSlots)] = $attr;
		}
		for ($slot in $texSlots)
		{
			//print ("\nchecking slot: " + $shader + $slot);
			string $result = `getAttr ($shader + "." + $slot)`;
			if ($result == "")
			{
				$msg = ("\nTexture Binding Error - Shader '" + $shader + "' has an empty texture binding '" + $slot + "'. This will cause the build to fail.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
}





global proc string boltSCV.GetVehicleName()
//returns the name of the current vehicle, based on folder structure, not file name. eg:
// M:/art/vehicles/AVENTADOR/MAYA/test1.mb returns "AVENTADOR"
{
	string $filePath = `file -q -sn`;
	string $buffer[];
	$numTokens = `tokenize $filePath "/" $buffer`;
	$name = $buffer[size($buffer)-3];

	if ( (toupper($name) == "VEHICLES") || (toupper($name) == "MAYA") )
	{
		error "Could not find vehicle name due to an error in the folder structure. Should be in the format .../VEHICLE_NAME/MAYA/VehicleFile.mb";
	}
	
	return tolower($name);
}


global proc boltGetStats()
//prints various car stats - warns about any problems
{
	int $noLods = 7;
	int $maxTextures = 6; //in mb
	
	global string $gBoltWarnings;
	string $msg;

	//print amount of textures used
	float $textureMem = `boltVehicleTextureMemory`;

	//print texture warnings
	if ($textureMem > $maxTextures)
	{
		//$msg = ("\nTexture memory too high (" + $textureMem + "mb). Needs to be "+$maxTextures+"mb or less.");
		//print $msg; $gBoltWarnings += $msg;
	}
	
	//check poly counts
	print "\n\nPolygon and drawcall counts:";
	
	int $polyCounts[]   = `boltGetAllPolyCounts ""`;
	int $lodTargetsTotal[] = `boltGetPolyCounts_Car`;  
	int $lodTargetsExt[]   = `boltGetPolyCounts_Ext`;  
	int $lodTargetsInt[]   = `boltGetPolyCounts_Int`;  
	int $lodTargetsTech[]  = `boltGetPolyCounts_Tech`; 
	int $lodTargetsWheel[] = `boltGetPolyCounts_Wheel`;
	int $lodTargetsDrawcalls[] = `boltGetPolyCounts_Drawcalls`;
	int $lodTargetsUnknown[] = {0,0,0,0,0,0,0,0};
	
	//check all total poly counts	
	for ($i=0; $i<$noLods; $i++)
	{
		print ("\nLod" + $i + " Triangles: " + $polyCounts[$i]);
		
		if ($polyCounts[$i] > $lodTargetsTotal[$i])
		{
			$msg = ("\nPoly Count Error - Lod" + $i + " TOTAL polycount (" + $polyCounts[$i] + ") is too high. Should be " + $lodTargetsTotal[$i] + " polys or less");
			print $msg; $gBoltWarnings += $msg;
		}
	}
		
	//check lod 0 interior
	if ($polyCounts[16] > $lodTargetsInt[0])
	{
		$msg = ("\nPoly Count Error - Lod0 INTERIOR polycount (" + $polyCounts[16] + ") is too high. Should be " + $lodTargetsInt[0] + " polys or less");
		print $msg; $gBoltWarnings += $msg;
	}		
	
	//check wheels to lod 4
	for ($i=0; $i<5; $i++)
	{
		if ($polyCounts[$i+24] > $lodTargetsWheel[$i])
		{
			$msg = ("\nPoly Count Error - Lod" + $i + " WHEEL polycount (" + $polyCounts[$i+24] + ") is too high. Should be " + $lodTargetsWheel[$i] + " polys or less");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	//check unknowns
	for ($i=0; $i<$noLods; $i++)
	{
		if ($polyCounts[$i+32] > $lodTargetsUnknown[$i])
		{
			$msg = ("\nPoly Count Error - Lod" + $i + " UNKNOWN polycount (" + $polyCounts[$i+32] + ") is too high. Should be " + $lodTargetsUnknown[$i] + " polys or less");
			print $msg; $gBoltWarnings += $msg;
		}
	}

	//check drawcalls
	for ($i=0; $i<$noLods; $i++)
	{
		print ("\nDrawcall Error - Lod" + $i + " Drawcalls: " + $polyCounts[$i+48]);
		
		if ($polyCounts[$i+48] > $lodTargetsDrawcalls[$i])
		{
			$msg = ("\nLod" + $i + " drawcalls (" + $polyCounts[$i+48] + ") is too high. Should be " + $lodTargetsDrawcalls[$i] + " or less");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
}



global proc float boltVehicleTextureMemory()
//prints amount of texture memory used by current vehicle
{
	string $shaders[] = `boltGetUsedShaders`;
	string $files[]   = `boltGetShaderFiles $shaders`;

	float $textureMemory = 0;
	float $genericTexturesPerCar = 0;
	
	float $pixels = 0; 
	
	print "\nNon Generic Textures:";
	
	for ($file in $files)
	{
		string $path = `getAttr ($file+".fileTextureName")`;
		
		if ( (`gmatch $path "*cubemaps*"` == 0)
			&& (`gmatch $path "*CubeMaps*"` == 0)
			&& (`gmatch $path "*generic_textures*"` == 0)
			&& (`gmatch $path "*GENERIC_TEXTURES*"` == 0)
			&& (`gmatch $path "*art?arttech*"` == 0)
			&& (`gmatch $path "*art?artTech*"` == 0)
			&& (`gmatch $path "*assets?defaulttextures*"` == 0)
			&& (`gmatch $path "*microfacetdistribution*"` == 0)
			&& (`gmatch $path "?:?art?white_zeroalpha.dds"` == 0)
			&& (`gmatch $path "?:?art?white.dds"` == 0)
			&& (`gmatch $path "?:?art?black.dds"` == 0)
			&& (`gmatch $path "?:?art?blank_normal.dds"` == 0)
			&& (`gmatch $path "*WHEELS?TEXTURES*"` == 0)
			&& (`gmatch $path "*shaders?textures*"` == 0)
			&& (size($path) > 0))
		//don't count cube maps or generics or empty textures
		{
			
			float $x = `getAttr ($file+".outSizeX")`;
			float $y = `getAttr ($file+".outSizeY")`;
			$pixels += ($x * $y);
			string $size = ($x + " * " + $y);
			print ("\n   " + $size + "     " + $file + "     " + $path);
					
		}
	}
	
	float $maps = $pixels / (1024*1024);
	print ("\n" + $maps + " 1k*1k texture maps or equivalent used.");
	print ("\n" + ($maps * 1.3) + "mb (approx) in memory (assuming 8bpp BC7 + mips)");
	print ("\n" + ($maps * 0.5) + "mb (approx) on disk (assuming 4bpp jpeg2000, no mips.");
	
	return ($maps * 1.3);
}




		
		


global proc float boltGetColourIntensity(string $attr)
//returns the rgb average of a given colour attibute. Returns 0 if attrib not found 
{
	if (!objExists($attr)) return 0;
	float $colour[] = `getAttr $attr`;
	float $avg = (($colour[0] + $colour[1] + $colour[2])/3);
	return $avg;
}


global proc boltCheckPartNames()
//checks that all part names are valid
{	
	global string $boltCarArray[];                 
	global int $boltCarArrayLength;     
	global string $gBoltWarnings;
	string $msg;	
	
	print "\nChecking for duplicate node names...";
	boltCheckForDuplicateNodeNames;
		
	string $suffixes[] = {"", "_LOD1", "_LOD2", "_LOD3", "_LOD4", "_LOD5","_LOD6","_DEAD","_DEAD_LOD1","_DEAD_LOD2","_DEAD_LOD3","_DEAD_LOD4","_DEAD_LOD5","_SHADOW","_DEAD_SHADOW"};
	
	string $nodes[];
	$nodes = boltShapesToTransforms(`ls -long -type "mesh"`);
	$nodes = stringArrayRemoveDuplicates($nodes);
	$dams = `ls -long -type "transform" "*_DAM*"`;
	$nodes = `stringArrayRemove $dams $nodes`;
	$swps = `ls -long -type "transform" "*_SWP*"`;
	$nodes = `stringArrayRemove $swps $nodes`;
	
	for ($node in $nodes)
	{
		int $nodeFound = 0;
			
		for ($i = 0; $i < $boltCarArrayLength; $i++)
		{
			string $partName = `boltGetArray "boltCarArray" $i 0`;
			
			for ($suffix in $suffixes)
			{
				if (`match "[^|]*$" $node` == ($partName + $suffix))
				{
					$nodeFound = 1;
					break;
				}
			}
			//check with all suffixes
			
			if ($nodeFound == 1) break;
		}
		//check against all part names
		
		if ($nodeFound == 0)
		{
			if (`referenceQuery -isNodeReferenced $node` == 0)
			//ignore referenced nodes like wheels
			{
				$msg = ("\nObject Name Error - " + $node + " is unrecognised. Try to use part names from the list in gametools>vehicle management");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	
	print "\nObject name checks complete.";
}



global proc boltTestCams()
//tests various camera things
{
	global string $gBoltWarnings;
	string $msg;	
	
	boltRemoveHierarchy;
	
	$cams = `ls -type "transform" "CAM_*"`;
		
	for ($cam in $cams)
	{
		string $camNodes[] = `listRelatives -type "camera" $cam`;
		if (size($camNodes) == 0)
		{
			$msg = ("\nCamera Error - " + $cam + " doesn't seem to be a camera.");
			print $msg; $gBoltWarnings += $msg;
		}
		//test if cams are actually cameras.
		else
		{
			
			boltLockCam $cam 0;  //unlock
			
			float $rot[] = `getAttr ($cam + ".rotate")`;
			float $sca[] = `getAttr ($cam + ".scale")`;
			float $tra[] = `getAttr ($cam + ".translate")`;
			makeIdentity -apply false -t 1 -r 1 -s 1 $cam;
			setAttr ($cam + ".rotate") 		$rot[0] $rot[1] $rot[2];
			setAttr ($cam + ".scale")  		$sca[0] $sca[1] $sca[2];
			setAttr ($cam + ".translate")	$tra[0] $tra[1] $tra[2];
			//strange frig to fix dodgy camera pivots
			   
 			boltLockCam $cam 1;  //lock
 			
		    //reset pivot offsets and lock all game cams
			
		}   
	} 
	boltRestoreHierarchy;
	
	if (objExists("CAM_BONNET"))
	{
		float $bonY = `getAttr "CAM_BONNET.translateY"`;
		string $camsToCheck[] = {"CAM_LOOK_BACK_L", "CAM_LOOK_BACK_R", "CAM_REARVIEW", "CAM_LOOK_LEFT", "CAM_LOOK_RIGHT"};
		for ($cam in $camsToCheck)
		{
			if (objExists($cam))
			{
				float $camY = `getAttr ($cam + ".translateY")`;
				if (!`equivalentTol $camY $bonY 0.1`)
				{
					$msg = ("\nCAM_BONNET and " + $cam + " should be at about the same height.");
					print $msg; $gBoltWarnings += $msg;
				}
			}
		}
	}
	//check that bonnet / lookaround cams are all about the same height
}           





global proc boltCenterPivot(string $node)
//centers the pivot of a given node, + resets offsets. Assumes hierarchy is removed.
{
	xform -cp $node;
	boltZeroPivotOffsetVertCheck $node;
}
	
global proc boltParentWarn(string $node, string $parent)
// atempts to parent two objects. warns if not possible	
{	
	global string $gBoltWarnings;
	string $msg;
	
	if (objExists($parent))
	{
		string $currentParent[] = `listRelatives -parent $node`;
		if ($currentParent[0] != $parent)
		{
			parent $node $parent;
		}
	}
	else
	{
		$msg = ("\nHierarchy Error - Could not find correct parent " + $parent + " for node " + $node); 
		print $msg; 
		$gBoltWarnings += $msg;
	}
}




global proc boltTestPhysics()
//tests that various physics stuff is set up ok
//sets body col attribs as recommended by markL to prevent lodding
//tests for ride height
//now also test for valid particle collison
{
	global string $gBoltWarnings;
	string $msg;	
	
	boltIsHavokWarn "BODY_COL";
	//boltIsHavokWarn "BONNET";
	//boltIsHavokWarn "BUMPER_F";
	//boltIsHavokWarn "BUMPER_B";
	//boltIsHavokWarn "DOOR_FL";
	//boltIsHavokWarn "DOOR_FR";
	//boltIsHavokWarn "DOOR_BL";
	//boltIsHavokWarn "DOOR_BR";
	//boltIsHavokWarn "WING_FL";
	//boltIsHavokWarn "WING_FR";
	//boltIsHavokWarn "WING_BL";
	//boltIsHavokWarn "WING_BR";
	//boltIsHavokWarn "SPOILER";
	//boltIsHavokWarn "BOOT";
	
	
	if (objExists("BODY_COLShape")==0)
	{
		$msg = ("\nPhysics Error - 'BODY_COLShape' not found, does this vehicle have a collison volume?");
		print $msg; $gBoltWarnings += $msg;
	}
	
	if (objExists("BODY_COL"))
	{
		string $hkNode[] = `listRelatives -type "hkNodeShape" "BODY_COL"`;
		if (`size $hkNode` != 0)
		{
			setAttr ($hkNode[0] + ".changeExtraRadius") 1;
			setAttr ($hkNode[0] + ".extraRadius") 0;
		}
	}
	//fix to prevent BODY_COL lodding on export
	
	/*
	string $ragdollObjs[] = {"DOOR_FL", "DOOR_FR", "BUMPER_B"};
	for ($obj in $ragdollObjs)
	{
		if (objExists($obj))
		{
			string $nodes[] = `listRelatives -type "hkNodeRagDollConstraint" $obj`;
			if (size($nodes) < 1)
			{
				$msg = ("\nNo ragdoll constraint found for " + $obj + ". Make sure that latest havok setup has been run on this vehicle");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	//check that latest havok ragdoll nodes are present on doors and bumper_b
	*/
	
	/*
	if (objExists("BODY_COL"))
	{
		float $rideHeight = `boltGetRideHeight`;
		float $rampHeight = `boltGetRampHeight`;
		
		boltRemoveHierarchy;
		float $bb[] = `xform -q -ws -bb ("BODY_COL")`;
		boltRestoreHierarchy;
		//get bounding box for collision
			
		if (equivalentTol($bb[1], $rideHeight, 0.005)==0)
		{
			$msg = ("\nGround clearance out of range for vehicle class. Set base of BODY_COL to " + $rideHeight + " high.");
			print $msg; $gBoltWarnings += $msg;
		}
		else if (`boltReturnVertsAtHeight $rideHeight "BODY_COL"` < 4)
		{
			$msg = ("\nIncorrectly constructed collison box detected. Should be at least 4 verts at " + $rideHeight + " high.");
			print $msg; $gBoltWarnings += $msg;
		}
		
		if ($rampHeight != 0)
		{
			if (`boltReturnVertsAtHeight $rampHeight "BODY_COL"` < 4)
			{
				$msg = ("\nIncorrectly constructed collison box detected. This vehicle requires a collision volume that ramps from\n"
						 + $rampHeight + " down to " + $rideHeight + " high. Could not find at least 4 verts at " + $rampHeight + " high.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
		
		string $doors[] = {"DOOR_FL", "DOOR_FR", "DOOR_BL", "DOOR_BR"};
		for ($door in $doors)
		{
			if (objExists($door))
			{
				boltTestHingeConsistency $door;
			}
		}
		//test whether ragdoll and hinge constraints match up
	}
	*/
	
	//boltCheckForTinyPlaceholders;	
	boltCheckMaterialsOnCollision;
	
	print "\nPhysics checks complete.";
}

global proc int boltReturnVertsAtHeight(float $height, string $obj)
//returns the number of verts found in an object at a given height
//0.005 tollerance
//used to check construction of vehicle colision box "ramps"
{
	int $count = 0;
	string $verts[] = `ls -fl ($obj + ".vtx[*]")`;
	for ($vert in $verts)
	{
		float $pos[] = `xform -q -t -ws $vert`;
		if (`equivalentTol $pos[1] $height 0.005`) $count ++;
	}
	return $count;
} 



global proc boltTestHingeConsistency(string $obj)
// tests that the hkHingeConstraint of the node is consistent with the hkRagDollConstraint
// prevents doors from opening inwards due to only one hinge being edited by the user. 
{
	global string $gBoltWarnings;
	string $msg;
	
	string $hinge[]   = `listRelatives -type "hkNodeHingeConstraint" $obj`;
	string $ragdoll[] = `listRelatives -type "hkNodeRagDollConstraint" $obj`;
	//get the havok hinge nodes
	
	if ( (size($hinge)!=1) || (size($ragdoll)!=1) )
	{
		print ("\nCouldn't tests hinge consistency on " + $obj);
		return;
	}

	float $hStart = `getAttr ($hinge[0] + ".limitMin")`;
	float $hEnd   = `getAttr ($hinge[0] + ".limitMax")`;
	float $rStart = `getAttr ($ragdoll[0] + ".twistMin")`;
	float $rEnd   = `getAttr ($ragdoll[0] + ".twistMax")`;
	
	int $startTest = `equivalentTol $hStart $rStart 11`;
	int $endTest   = `equivalentTol $hEnd $rEnd 0.1`;
	
	if (($startTest == 0) || ($endTest == 0))
	{
		$msg = ("\nHavok hinge constraint does not match ragdoll constraint on " + $obj);
		$msg+=  "\n   If this is a standard hinge then remove/add fresh havok nodes to fix.";
		$msg+=	"\n   If this is a custom hinge then you will need to fix by hand, ensuring that the start and end angles for each hinge are the same.";
		$msg+= 	"\n   Nb: \"twist min\" on the ragdoll constraint should be about +/-10, to prevent intersection of drooping door with car bodywork";
		print $msg; 
		$gBoltWarnings += $msg;
	}
}
		

global proc boltIsHavokWarn(string $node)
//given a transform node, tests it to see if it has havok rb and shape nodes, warns if not
{
	global string $gBoltWarnings;
	string $msg;
	
	if (objExists($node))
	{
		if (`boltIsHavok $node` == 0)
		{
			$msg = ("\nPhysics Error - Havok shape and/or rigid body nodes are missing from " + $node);
			print $msg; 
			$gBoltWarnings += $msg;
		}
	}
}

global proc int boltIsHavok(string $node)
//given a transform node, tests it to see if it has havok rb and shape nodes.
{
	string $havok1[] = `listRelatives -type "hkNodeRigidBody" $node`;
	string $havok2[] = `listRelatives -type "hkNodeShape" 	  $node`;
	
	if ( (size($havok1) > 0) && (size($havok2) > 0)	)
	{
		return 1;	
	}
	else 
	{
		return 0;
	}
}

global proc boltTestHierarchy()
//test for various required parts of the hierarchy
{
	global string $gBoltWarnings;
	string $msg;
		
	boltLookFor "|BODY_COL";
	boltLookFor "|BODY_COL|BODY";
	//all vehicles

	boltLookFor "|BODY_COL|BODY|INTERIOR_SHELL";
	//look for car interiors + driver locators

	boltLookFor "|BODY_COL|BODY|HUB_BL";
	boltLookFor "|BODY_COL|BODY|HUB_BR";
	boltLookFor "|BODY_COL|BODY|WHEEL_BL";
	boltLookFor "|BODY_COL|BODY|WHEEL_BR";
	boltLookFor "|BODY_COL|BODY|HUB_BL|DISC_BL";
	boltLookFor "|BODY_COL|BODY|HUB_BR|DISC_BR";
	//look for back wheels

	boltLookFor "|BODY_COL|BODY|HUB_FL";
	boltLookFor "|BODY_COL|BODY|HUB_FR";
	boltLookFor "|BODY_COL|BODY|WHEEL_FL";
	boltLookFor "|BODY_COL|BODY|WHEEL_FR";
	boltLookFor "|BODY_COL|BODY|HUB_FL|DISC_FL";
	boltLookFor "|BODY_COL|BODY|HUB_FR|DISC_FR";
	//look for front wheels
	
	
	if ( size(`ls -type "AtgEnvironment"`) > 8 )
	{
		$msg = ("\nATG Environment Error - Corrupt or duplicate ATG Environments found (usually caused by incorrect scene imports). Delete all nodes in 'Hypershade > Utilities' tab, and apply a new environment using 'Evolution shelf > Preview' tool.");
		print $msg; $gBoltWarnings += $msg;
	}
	
	print "\nHierarchy checked";
	
}


global proc boltLookFor(string $node)
//tests for specified part of the vehicle hierarchy.
{
	global string $gBoltWarnings;
	string $msg;
	
	if (!(`objExists $node`))
	{
		$msg = "\nHierarchy Error - Could not find " + $node + " in the hierarchy. Part is either missing or incorrectly parented.";
		print $msg; 
		$gBoltWarnings += $msg;
	}
}

global proc boltDamageTestRebuild()
//rebuilds damage, tests geometry, naming conventions, pivots 
{
	global string $gBoltWarnings;
	string $msg;
	
	if (size(`ls "*_DAM*"`) == 0)
	{
		$msg = "\nNo damage blendshapes found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	//test damage is present
	
	boltRemoveHierarchy;	
	
	print "\nReseting damage and deleting Blendshapes...";	
	int $i; for ($i=0; $i<11; $i++) boltDamageDown;
	//ensure damage is off on main model
		
	string  $deleteList[] = `ls -type "blendShape"`;
	for ($node in $deleteList) 
	{
		lockNode -lock off $node;
		delete $node;
	}
	//delete blend shapes.

	boltDamageRelinkWarn;
	
	boltRestoreHierarchy;	
		
	print "\nRestoring damage group...";
	boltAddDamageGroup;
}

	

global proc boltDamageRelinkWarn()
//relinks blend shapes between damaged and undamaged geometry - warn if errors found
{
	showHidden -all;
	global string $gBoltWarnings;
	
	string $damObjs[] = `ls -type "transform" "*_DAM"`;
		
	for ($damObj in $damObjs)
	{
		if (`match "Shape" $damObj` == "Shape")
		{
			string $newName = `substitute "Shape" $damObj ""`;
			print ("\nRenaming " + $damObj + " to " + $newName);
			rename $damObj $newName;
			$damObj = $newName;
		}
		//stops crashes cause by confusion over shape nodes.
		
		string $unDam = `substitute "_DAM" $damObj ""`;
		
		if (objExists($unDam))
		{
			boltMovePivotTest $damObj $unDam <<-4,0,0>>;
			//ensure pivots are correct
			
			int $damObjV[] = `polyEvaluate -vertex $damObj`;
			int $unDamV[]  = `polyEvaluate -vertex $unDam`;
			
			if ( $damObjV[0] == $unDamV[0])
			{
				boltDeleteHavokNodes ($damObj);
				if (`objExists ("blendShape_" + $damObj)`) delete ("blendShape_" + $damObj); 
				catchQuiet(`blendShape -name ("blendShape_" + $damObj) $damObj $unDam`);
				print ("\n" + $damObj + " reconnected");
			}
			else
			{
				print ("\nCould not connect " + $damObj + " to " + $unDam + " - different vertex counts");
				$gBoltWarnings += ("\nCould not connect " + $damObj + " to " + $unDam + " - different vertex counts");
			}
		}
		else
		{
			print ("\nCould find object " + $unDam + " to connect " + $damObj + " blendshape to");
			$gBoltWarnings += ("\nCould find object " + $unDam + " to connect " + $damObj + " blendshape to");
		}		
		
	}
	
	hide top front side persp;
	if (`window -exists boltVehicleDisplayManagerWindow`) boltUpdateVehicleDisplay;
		
	print ("\nDamage Blendshapes relinked");
}


global proc boltDeleteUnusedShaders()
//deletes unused shaders, except _LV shaders and default shaders
{
	string $shaders[] = `ls -materials`;
	string $usedShaders[] = `boltGetUsedShaders`;
	string $mayaShaders[] = {"lambert1", "shaderGlow1", "particleCloud1"};
	string $unusedShaders[] = `stringArrayRemove $usedShaders $shaders`;
	$unusedShaders = `stringArrayRemove $mayaShaders $unusedShaders`;

	for ($shader in $unusedShaders)
	{
		if (`match "_LV" $shader` != "_LV")
		{
			catchQuiet(`delete $shader`);
			print ("\nRemoved unused shader " + $shader);
		}
	}
	print "\nRemoved unused Shaders";
}

global proc boltLowerCaseShaders()
//converts all shader names to lower case, except for "_LV"
{
	string $shaders[] = `ls -materials`;
	
	string $mayaShaders[] = {"lambert1", "shaderGlow1", "particleCloud1", "TEMP_DEBUG_SHADER", "ENV_CUBE_SHADER"};
	$shaders = `stringArrayRemove $mayaShaders $shaders`;
	//remove default shaders
	
	int $count = 0;
	
	for ($shader in $shaders)
	{
		string $newName =`tolower $shader`;
		if (`match "_lv" $newName` == "_lv") 
		{
			$newName = `substitute "_lv" $newName "_LV"`;
		}
		
		
		if ($shader != $newName)
		{
		 	rename $shader $newName;
		 	$count ++;
		}
	}
	print ("\nRenamed " + $count + " shaders to lowercase");
}
		







global proc boltCheckDeadShapes()
//checks dead shapes for corresponding undead shapes and correct hierarchy.
{
	global string $gBoltWarnings;
	
	string $deadShapes[] = `ls -type "transform" "*_DEAD"`;
	
	for ($deadShape in $deadShapes)
	{
		$unDeadShape =  `match ".*[^_DEAD]" $deadShape`;
		
		if (!(`objExists $unDeadShape`))
		{
			print ("\nCould not find corresponding un-dead shape for " + $deadShape);
			$gBoltWarnings += ("\nCould not find corresponding un-dead shape for " + $deadShape);
		}
		//check if undead exists
		else
		{
			string $deadShapeP[]   = `listRelatives -type "transform" -parent $deadShape`;
			string $unDeadShapeP[] = `listRelatives -type "transform" -parent $unDeadShape`;
		
			if ($deadShapeP[0] != $unDeadShapeP[0])
			{
				parent $deadShape $unDeadShapeP[0];
				print ("\n" + $deadShape + " was linked to the same parent (" + $unDeadShapeP[0] + ") as " + $unDeadShape);
			}
		}
		//check parents are the same
	}

	print "\nChecking _DEAD pivots match undead pivots...";
	boltRemoveHierarchy;
	
	for ($deadShape in $deadShapes)
	{
		$unDeadShape =  `match ".*[^_DEAD]" $deadShape`;
		if (!(`objExists $unDeadShape`))
		{
			print ("\nCould not find corresponding un-dead shape for " + $deadShape);
		}
		//check if undead exists
		else
		{
			boltMovePivotTest $deadShape $unDeadShape <<0,0,0>>;
		}
		//correct the pivot if necessary
	}
	boltRestoreHierarchy;		
	print "\nFinished checking dead shapes";
}

global proc boltCheckSwapShapes()
//checks swap shape naming and hierarchy.
{
	global string $gBoltWarnings;
	
	string $allSwaps[] = `ls -transforms "*_SWP*"`;
	
	string $swaps[] = {};
	for ($swap in $allSwaps)
	{
		if (`gmatch $swap "*_SWP??"`)
		{
			$swaps[size($swaps)] = $swap;
		}
	}
	//gets list excluding all lods
		
	for ($swap in $swaps)
	{
		string $basePart = `boltGetBasePartName $swap`;
		
		if (!(`objExists $basePart`))
		{
			string $msg = ("\nCould not find corresponding basePart (" + $basePart + ") for swap shape " + $swap);
			print $msg;
			$gBoltWarnings += $msg;
		}
		else
		{
			string $swapP[] = `listRelatives -type "transform" -parent $swap`;
			string $baseP[] = `listRelatives -type "transform" -parent $basePart`;
			
			if ($swapP[0] != $baseP[0])
			{
				if ($baseP[0] == "") 
				{
					parent -world $swap;
					print ("\n" + $swap + " was linked to the same parent (world) as " + $basePart);
				
				}
				else
				{
					parent $swap $baseP[0];
					print ("\n" + $swap + " was linked to the same parent (" + $baseP[0] + ") as " + $basePart);
				}
			}
		}
		//Fix parents of swap parts, warn if no basepart found
		
		boltParentRefWheels;
		//fixes wheel ref parents, usefull if new wheels have been added to ref file.
		
	}


	print "\nChecking _SWP pivots match basepart pivots...";
	boltRemoveHierarchy;
	for ($swap in $swaps)
	{
		string $basePart = `boltGetBasePartName $swap`;
		if (!(`objExists $basePart`))
		{
			print ("\nMatch pivot failed - Could not find corresponding basepart for " + $swap);
		}
		//check if basepart exists
		else
		{
			if ((`gmatch $swap "BOOST_*"`==0)) //&&(`gmatch $swap "EXHAUST_*"`==0))
			{
				boltMovePivotTest $swap $basePart <<0,0,0>>;
			}
		}
		//correct the pivot if necessary - avoid boost pivots
	}
	boltRestoreHierarchy;		
	print "\nSwap shape pivots corrected...";
	
	
	
	for ($swap in $allSwaps)
	{
		int $ok = 0;
		if (`gmatch $swap "*_SWP??"`) $ok = 1;
		if (`gmatch $swap "*_SWP??_LOD?"`) $ok = 1;
		if (`gmatch $swap "*_SWP??_SHADOW"`) $ok = 1;
		if (`gmatch $swap "*_SWP??_DEAD"`) $ok = 0;
		if (`gmatch $swap "*_SWP??_DEAD_LOD?"`) $ok = 0;
		if (`gmatch $swap "*_SWP??_DEAD_SHADOW"`) $ok = 0;
		
		if ($ok == 0)
		{
			string $msg = ("\n" + $swap + " is incorrectly named. Any name suffixes should be in this order and format: _DEAD_SWP##_LOD#");
			print $msg;
			$gBoltWarnings += $msg;
		}
		if (`gmatch $swap "*_SWP00*"`)
		{
			string $msg = ("\nError - '_SWP00' is not a valid swap part name - found on " + $swap);
			print $msg;
			$gBoltWarnings += $msg;
		}
		
	}
	print "\nSwap names checked...";
	
	
	
	
	string $baseParts[] = {};
	for ($swap in $swaps)
	{
		$baseParts[size($baseParts)] = `boltGetBasePartName $swap`;
	}
	$baseParts = stringArrayRemoveDuplicates($baseParts);
	
	string $lodExts[] = {"_LOD1","_LOD2","_LOD3","_LOD4","_LOD5","_LOD6"};
	
	string $msgs[] = {}; //list of error messages.
	
	for ($basePart in $baseParts)
	{
		if (!(`gmatch $basePart "BOOST*"`)) //ignore boosts - missing boosts allowed
		{
			string $swapOptions[] = boltGetSwappableOptionsForPart($basePart);
		
			for ($swapOption in $swapOptions)//for all swappable options for this part
			{
				for ($lodExt in $lodExts)//check all lod extentions
				{
					if (objExists($swapOption + $lodExt))//if a lod is found
					{
						for ($swapOption2 in $swapOptions) //check it exists in all other swaps
						{
							if ( objExists($swapOption2 + $lodExt) == 0 ) //if it doesn exist then warn
							{
								$msgs[size($msgs)] = ("\nLods do not correspond across swap shapes - " + $swapOption2 + $lodExt + " not found!");
							}
						}
					}
				}
			}  
		}
	}
	
	$msgs = stringArrayRemoveDuplicates($msgs);
	
	for ($msg in $msgs)
	{
		print $msg;
		$gBoltWarnings += $msg;
	}
	
	print "\nSwap lods checked...";
	
	
	
	
			
	print "\nFinished checking swap shapes";
}


global proc boltRenameShapesOrig()
//renames shapes to [transform name]Shape. Preserves damage "orig"  shapes
{
	
	string $meshes[]= `ls -type "mesh" -type "spotLight"`;                            
	//get mesh shapes + spots                                    

    for ($mesh in $meshes)
    {              
    	string $trans[] = `listRelatives -type "transform" -parent $mesh`; 
		//get the transform node for the mesh    
   
        if (`match "Orig$" $mesh` == "Orig")
        {
        	if ($mesh != ($trans[0]+"ShapeOrig"))
        	{
				catchQuiet(`rename $mesh ($trans[0] + "ShapeOrig")`);
				print ("\n" + $mesh + " renamed to " + $trans[0] + "ShapeOrig");
			}
		}
		else
		{
			if ($mesh != ($trans[0]+"Shape"))
        	{
				catchQuiet(`rename $mesh ($trans[0] + "Shape")`);
				print ("\n" + $mesh + " renamed to " + $trans[0] + "Shape");
			}
		}
		
	}
	print "\nShapes renamed";
}



global proc boltTestPivotPlacements()
//test + fix body and body col pivot position
{
	global string $gBoltWarnings;
	string $msg;
	
	if ( (!objExists("BODY")) || (!objExists("BODY_COL")) )
	{
		$msg = "\nPivot Error - Could not find BODY and/or BODY_COL - cannot set pivots";
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	//check for body + body col
	
		
	//check for BODY_PIVOT_LOC, if not found, create pivot loc at body / body_col position
	
	if (!`objExists "BODY_PIVOT_LOC"`)
	{
		float $t[] = `getAttr "BODY_COL.t"`;
		spaceLocator -n "BODY_PIVOT_LOC";
		setAttr "BODY_PIVOT_LOC.t" $t[0] $t[1] $t[2];
		setAttr -l true "BODY_PIVOT_LOC.t";
		setAttr -l true "BODY_PIVOT_LOC.r";
		setAttr -l true "BODY_PIVOT_LOC.s";
		
		$msg = "\nPivot Warning - BODY_PIVOT_LOC not found in scene - a new pivot has been created based on BODY_COL position";
		print $msg; $gBoltWarnings += $msg;
	}
	
	//ensure body and body_col are snapped to pivot
	boltRemoveHierarchy;
	boltMovePivotTest "BODY" 		"BODY_PIVOT_LOC" <<0,0,0>>;
	boltMovePivotTest "BODY_COL" 	"BODY_PIVOT_LOC" <<0,0,0>>;
	//boltZeroPivotOffsetVertCheck("BODY");
	//boltZeroPivotOffsetVertCheck("BODY_COL");
	boltRestoreHierarchy;
	
	print "\nBODY and BODY_COL pivots aligned with BODY_PIVOT_LOC.";
	
	
	print "\n\nMatching pivots to BODY to prevent gaps caused by accuracy problems...";
	
	boltRemoveHierarchy;
	string $body = "BODY";
	string $objsToMove[] = {"BUMPER_F", "BUMPER_B", "BONNET", "BOOT", "CHASSIS", "INTERIOR_SHELL", "LIGHT_BL", "LIGHT_BR", "LIGHT_FL", "LIGHT_FR"};
	for ($obj in $objsToMove)
	{
		if (objExists($obj))
		{
			print ("\nTesting pivot on: " + $obj);
			boltMovePivotTest $obj $body <<0,0,0>>;
		}
	}
	boltRestoreHierarchy;
	
	
	print "\n\nMoving pivots on WHEELS to outside of tyre sidewall...";
	boltRemoveHierarchy;
	string $wheels[] = {"WHEEL_FL","WHEEL_FR","WHEEL_BL","WHEEL_BR"};
	
	for ($wheel in $wheels)
	{
		
		string $tyreShader = "";
		string $materials[] = boltGetMaterialsOnObj($wheel);
		for ($mat in $materials)
		{
			$xmlpath =  boltGetShaderPreset($mat);
			if (`gmatch $xmlpath "*tyre_*.xml"`) $tyreShader = $mat;
		}
		
		if ($tyreShader != "")
		{
			//get tyre polys
			string $objectSet = `sets -fc 1 ($wheel + ".f[*]")`;
			string $sgs[] = getSGFromMaterial($tyreShader);
			string $tyrePolys[] = `sets -intersection $sgs[0] $objectSet`;
					
			//get bounding box of selection
			select -r $tyrePolys;
			float $bb[] = `polyEvaluate -boundingBoxComponent`; //xmin xmax ymin ymax zmin zmax
			
			float $pivot[] = {};
			if (`endsWith $wheel "L"`)
			{
				$pivot = { $bb[1], (($bb[2]+$bb[3])/2), (($bb[4]+$bb[5])/2) };
			}
			else
			{
				$pivot = { $bb[0], (($bb[2]+$bb[3])/2), (($bb[4]+$bb[5])/2) };
			}
			
			string $tempLoc[] = `spaceLocator`;
			setAttr ($tempLoc[0] + ".t") $pivot[0] $pivot[1] $pivot[2];
			boltMovePivotTest $wheel $tempLoc[0] <<0,0,0>>;
			delete $tempLoc[0];
		}
		else
		{
			$msg = ("\nError - Tyre Shader could not be found on " + $wheel + ". Could not set tyre pivot");
			print $msg; $gBoltWarnings += $msg;
		}
			
		select -cl;
	}	
	boltRestoreHierarchy;
	
	
	boltRemoveHierarchy;
	string $windows[] = {"LIGHT_LENS_BL","LIGHT_LENS_Br","LIGHT_LENS_FL","LIGHT_LENS_FR","WINDOW_B", "WINDOW_B2","WINDOW_BL","WINDOW_BR","WINDOW_F","WINDOW_FL","WINDOW_FL2","WINDOW_FR","WINDOW_FR2","WINDOW_T","WINDOW_TL","WINDOW_TR"};
	
	for ($win in $windows)
	{
		if (objExists($win))
		{
			float $p[] = `getAttr ($win + ".t")`;
			float $bb[] = `polyEvaluate -boundingBox $win`; // xmin xmax ymin ymax zmin zmax
			
			if (  !( ($p[0] >= $bb[0]) && ($p[0] <= $bb[1])
				&& ($p[1] >= $bb[2]) && ($p[1] <= $bb[3])
				&& ($p[2] >= $bb[4]) && ($p[2] <= $bb[5]) ) )
			{
				$msg = ("\nGlass Pivot Error - " + $win + " pivot was not within its own bounding box. For best sorting results, transparent objects should have pivots centered to geometry.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	boltRestoreHierarchy;
	
	print "\n\nPivot alignment and checks complete";	
	
	
	
}



global proc string boltGetVehicleTypeWarn()
//returns vehicle type from file name. Adds a warning if vehicle type not found
{
	global string $gBoltWarnings;
	
	string $type = `boltGetVehicleType`;
	if ($type == "")
	{
		print "\nVehicle type not recognised - check vehicle path and file name are correct";	
		if (`match "*Vehicle type not recognised*" $gBoltWarnings` == "")
		{
			$gBoltWarnings += "\nVehicle type not recognised - check vehicle path and file name are correct";
		}
		//add a warning if not already done.
	}
	return $type;
}

global proc boltTestExhaustColours()
{
	global string $gBoltWarnings;	
	
	string $objList[] = {"EXHAUST_TAILPIPE_L", "EXHAUST_TAILPIPE_R",
							"EXHAUST_TAILPIPE_L2", "EXHAUST_TAILPIPE_R2",
							"EXHAUST_TAILPIPE_L3", "EXHAUST_TAILPIPE_R3",
							"EXHAUST_TAILPIPE_L4", "EXHAUST_TAILPIPE_R4"};
		
	for ($obj in $objList)
	{	
		if (objExists($obj))
		{
			string $shapes[] = `listRelatives -type "mesh" $obj`;
			if (size($shapes) > 0)
			{
				int $vertCounts[] = `polyEvaluate -vertex $obj`;
				int $vertCount = $vertCounts[0];
				//get num of verts
				
				int $mudFlag = 0;
				int $alpFlag = 0;
					
				for ( $v = 0; $v < $vertCount; $v++ )
				//for each vert
				{
					float $vertA[] 	 = `polyColorPerVertex -q -a -nun ($obj + ".vtx[" + $v +"]")`;
					if ($vertA[0] == 0)
					{
						$alpFlag = 1;
					}
					//black alpha vert found
					
					float $vertR[] = `polyColorPerVertex -q -r -nun ($obj + ".vtx[" + $v +"]")`;
					if ($vertR[0] == 0)
					{
						$mudFlag = 1;
					}
					//mud free vert found
				}
				
				if ($alpFlag == 0)
				{
					print ("\nBlack alpha occlusion should be used on " + $obj + " exhaust hole");
					$gBoltWarnings += ("\nBlack alpha occlusion should be used on " + $obj + " exhaust hole");	
				}
				if ($mudFlag == 0)
				{
					print ("\nZero mud should be used on " + $obj + " exhaust hole");
					$gBoltWarnings += ("\nZero mud should be used on " + $obj + " exhaust hole");	
				} 
			}
		
		}
	}
	print "\nExhaust colour test complete\n"; 
}


global proc boltTestAllLods()
//this check is for stage 15, and will warn about any missing lods.
{
	string $msg;
	global string $gBoltWarnings;	
	
	if (size(`ls "*_LOD1*"`) == 0)
	{
		$msg = "\nLOD Error - No LOD1 parts found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	if (size(`ls "*_LOD2*"`) == 0)
	{
		$msg = "\nLOD Error - No LOD2 parts found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	if (size(`ls "*_LOD3*"`) == 0)
	{
		$msg = "\nLOD Error - No LOD3 parts found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	if (size(`ls "*_LOD4*"`) == 0)
	{
		$msg = "\nLOD Error - No LOD4 parts found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	if (size(`ls "*_LOD5*"`) == 0)
	{
		$msg = "\nLOD Error - No LOD5 parts found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	if (size(`ls "*_LOD6*"`) == 0)
	{
		$msg = "\nLOD Error - No LOD6 parts found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	if (size(`ls "*_SHADOW*"`) == 0)
	{
		$msg = "\nLOD Error - No Shadow proxies found in the scene";
		print $msg; $gBoltWarnings += $msg;
	}
	//if (size(`ls "*_OCC*"`) == 0)
	//{
	//	$msg = "\nNo Occlusion objects found in the scene";
	//	print $msg; $gBoltWarnings += $msg;
	//}
	//test lods are present
	
	string $LODs[] = `ls -type "transform" "*_LOD?"`;
	
	print "\nChecking For Placeholder Lods...";
	
	int $placeholdersFound = 0;
	for ($LOD in $LODs)
	{
		if (attributeExists("placeholderLOD" , $LOD))
		{
			$placeholdersFound = 1;
		}
	}
		
	if ($placeholdersFound)
	{		
		print ("\nPlaceholder lods found in scene. These must be replaced before Gold Master.");
		$gBoltWarnings = $gBoltWarnings + ("\nPlaceholder lods found in scene. These must be replaced before Gold Master.");
	}
	
	print "\nFull lod check complete.";
	
	
}


global proc boltTestLODHierarchy()
{
	string $msg;
	global string $gBoltWarnings;	
	
	//print "\nDeleteing Unnecessary Placeholder Lods..";
	//boltPlaceholderLods.Prune();
	
	
	//correct any nodes with LOD_DEAD instead of DEAD_LOD
	string $wrong[] = `ls -type "transform" "*_LOD1_DEAD"`;
	for ($node in $wrong)
	{
		string $newName = `substitute "_LOD1_DEAD" $node "_DEAD_LOD1"`;
		print ("\nRenaming " + $node + " to " + $newName);
		rename $node $newName;
	}
	string $wrong[] = `ls -type "transform" "*_LOD2_DEAD"`;
	for ($node in $wrong)
	{	
		string $newName = `substitute "_LOD2_DEAD" $node "_DEAD_LOD2"`;
		print ("\nRenaming " + $node + " to " + $newName);
		rename $node $newName;
	}
	
	
	//get list of all lods
	string $LOD1s[] = `ls -type "transform" "*_LOD1"`; 
	string $LOD2s[] = `ls -type "transform" "*_LOD2"`; 
	string $LOD3s[] = `ls -type "transform" "*_LOD3"`; 
	string $LOD4s[] = `ls -type "transform" "*_LOD4"`; 
	string $LOD5s[] = `ls -type "transform" "*_LOD5"`; 
	string $LODs[] = `ls -type "transform" "*_LOD?"`;
	string $shads[] = `ls -type "transform" "*_SHADOW"`;
	string $occs[] = `ls -type "transform" "*_OCC"`;
	string $LODss[] = `ls -type "transform" "*_LOD*"`; // help to find unrecognised lod names - eg _LOD04
	
	
	for ($LOD in $LODs)
	{
		//check parent exists, warn if not
		string $parent =  `substitute "_LOD.$" $LOD ""`;
		if (!(objExists($parent)))
		{
			print ("\nCannot find correct parent (" + $parent + ") for " + $LOD);
			$gBoltWarnings = $gBoltWarnings + ("\nLOD Hierarchy warning - Cannot find correct parent (" + $parent + ") for " + $LOD);
		}
		//correct the parent if necessary
		else
		{
			if (`nodeType $parent` == "transform")
			{
				string $currentParent[] = `listRelatives -p $LOD`;
				if ($currentParent[0] != $parent)
				{
					print ("\nCorrecting Parent of " + $LOD + " to " + $parent);
					catchQuiet(`parent $LOD $parent`);
				}
			}
			//stop it crashing with lods called "PARTShape_LOD1" - tries to parent to a shape
			else
			{
				print ("\nExpected parent (" + $parent + ") of node "+ $LOD + " is not a transform node - please check names of LOD and parent are correct");
				$gBoltWarnings = $gBoltWarnings + ("\nLOD Hierarchy warning - Cannot find correct parent (" + $parent + ") for " + $LOD);
			}
		}
		
		// check that the lod has no children
		string $children[] = {};
		$children = `listRelatives -type "transform" -children $LOD`;
		if (size($children) > 0)
		{
			$msg = ("\nLOD Hierarchy warning - Child transforms found beneath " + $LOD + ". LODs should never have children - this will break the game.");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	
	for ($shad in $shads)
	{
		string $parent =  `substitute "_SHADOW" $shad ""`;
		string $parentLod1 =  `substitute "_SHADOW" $shad "_LOD1"`;
		
		//check parent exists, warn if not
		if (!(objExists($parent)))
		{
			$msg = ("\nLOD Hierarchy warning - Cannot find correct parent (" + $parent + ") for " + $shad);
			print $msg; $gBoltWarnings += $msg;
		}
		//check parent exists, warn if not
		if (!(objExists($parentLod1)))
		{
			$msg = ("\nLOD Hierarchy Warning - could not find a LOD1 version of " + $shad + ". This will cause holes in the shadow. This can probably be fixed by merging the part to BODY_SHADOW.");
			print $msg; $gBoltWarnings += $msg;
		}
		//correct the parent if necessary
		else
		{
			if (`nodeType $parent` == "transform")
			{
				string $currentParent[] = `listRelatives -p $shad`;
				if ($currentParent[0] != $parent)
				{
					print ("\nCorrecting Parent of " + $shad + " to " + $parent);
					catchQuiet(`parent $shad $parent`);
				}
			}
			//stops it crashing with lods called "PARTShape_LOD1" - tries to parent to a shape
			else
			{
				$msg = ("\nExpected parent (" + $parent + ") of node "+ $shad + " is not a transform node - please check names of LOD and parent are correct");
				print $msg; $gBoltWarnings += $msg;
			}
		}
		
		// check that the shadow has no children
		string $children[] = {};
		$children = `listRelatives -type "transform" -children $shad`;
		if (size($children) > 0)
		{
			$msg = ("\nChild transforms found beneath " + $shad + ". Shadows should never have children - this will break the game.");
			print $msg; $gBoltWarnings += $msg;
		}
		
	}
	
	
	print "\nChecking Occluders are valid...";
	for ($occ in $occs)
	{
		int $v[] = `polyEvaluate -vertex $occ`;
		int $p[] = `polyEvaluate -triangle $occ`;
		
		
		if ($v[0]>8)
		{
			$msg = ("\nMax vert count of 8 exceeded for occluder " + $occ);
			print $msg; $gBoltWarnings += $msg;
		}
		if ($p[0]>16)
		{
			$msg = ("\nMax triangle count of 16 exceeded for occluder " + $occ);
			print $msg; $gBoltWarnings += $msg;
		}
		
		string $parent[] = `listRelatives -parent $occ`;
		if ($parent[0] != "BODY_COL")
		{
			$msg = ("\n" + $occ + " was not parented to BODY_COL");
			print $msg; $gBoltWarnings += $msg;
		}
		
	}
	
	
		

	
	
	//check for supported lod names
	for ($l in $LODss)
	{
		int $ok = 0;
		if (gmatch($l,"*_LOD1")) $ok=1;
		if (gmatch($l,"*_LOD2")) $ok=1;
		if (gmatch($l,"*_LOD3")) $ok=1;
		if (gmatch($l,"*_LOD4")) $ok=1;
		if (gmatch($l,"*_LOD5")) $ok=1;
		if (gmatch($l,"*_LOD6")) $ok=1;
		
		if ($ok==0)
		{
			$msg = ("\nUnsupported lod name found in scene: " + $l);
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	string $nonLODs[] = stringArrayRemove($LODss,`ls -type "transform"`);
	
	for ($n in $nonLODs)
	{
		int $gapFound = 0;
		
		//check every lod for existance
		for ($i=1; $i<10; $i++)
		{
			//if a lod doesn't exist
			if (!`objExists ($n + "_LOD" + $i)`)
			{
				//check all lods after it
				for ($j=$i; $j<10; $j++)
				{
					//if a lod exists after a missing lod, then we have found a gap
					if (`objExists ($n + "_LOD" + $j)`)
					{
						$gapFound = 1;
					}
				}
			}
		}
		if ($gapFound == 1)
		{
			$msg = ("\nA gap was found in the lod chain of object: " + $n + " This will cause the export to fail!");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	
	
	
	
	
	
	
	
	
	
	
	print "\n\nChecking LOD pivots match LOD0...";
	
	boltRemoveHierarchy;
	for ($LOD in $LODs)
	{
		print ("\nTesting pivot on: " + $LOD);
		
		string $parent =  `substitute "_LOD.$" $LOD ""`;
		if (!(objExists($parent)))
		{
			print ("\nCannot find correct parent (" + $parent + ") for " + $LOD);
		}
		//check parent exists, warn if not
		else
		{
			if (`nodeType $parent` == "transform")
			{
				boltMovePivotTest $LOD $parent <<0,0,0>>;
			}
			//correct the pivot if necessary
			else
			{
				print ("\nExpected parent (" + $parent + ") of node "+ $LOD + " is not a transform node - please check names of LOD and parent are correct");
				$gBoltWarnings = $gBoltWarnings + ("\nCannot find correct parent (" + $parent + ") for " + $LOD);
			}
			//stops it crashing with lods called "PARTShape_LOD1" - tries to parent to a shape
		}
	}
	boltRestoreHierarchy;
	boltRemoveHierarchy;
	for ($shad in $shads)
	{
		string $parent =  `substitute "_SHADOW" $shad ""`;
		if (!(objExists($parent)))
		{
			print ("\nCannot find correct parent (" + $parent + ") for " + $shad);
		}
		//check parent exists, warn if not
		else
		{
			if (`nodeType $parent` == "transform")
			{
				boltMovePivotTest $shad $parent <<0,0,0>>;
			}
			//correct the pivot if necessary
			else
			{
				print ("\nExpected parent (" + $parent + ") of node "+ $shad + " is not a transform node - please check names of LOD and parent are correct");
				$gBoltWarnings = $gBoltWarnings + ("\nCannot find correct parent (" + $parent + ") for " + $shad);
			}
			//stops it crashing with lods called "PARTShape_LOD1" - tries to parent to a shape
		}
	}
	
	
	boltRestoreHierarchy;		
	print "\n\nLOD pivots corrected...";	
	
	print "\n\nTesting for sub-pixel-length edges....";
	boltEdgeLengthValidatorCheck;
	
	print "\n\nOptimising geometry on low lods....";
	boltOptimiseLowLods;
	
		
}

	



global proc boltTestAndReportSymmetry(string $name, int $warnAt, string $objList[])
{
	global string $gBoltWarningsLow;
	
	float $tolerance = 0.001;
	float $result = boltTestSymmetry($objList, $tolerance);
	
	if ($result != -1)
	{
		print ("\n" + $name + " " + $result + "% Symmetrical.");
	
		if ($result < $warnAt)
		{
			$gBoltWarningsLow += ("\nSymmetry warning - " + $name +" only " + $result + "% Symmetrical.");
		}
	}
}


global proc float boltTestSymmetry(string $objList[], float $tolerance)
//returns symetry of given objects as a percentage. Returns -1 if objs not found
{
	vector $vertList[] = {};
	int $totalVerts = 0;	//total no of verts in all objs for %age calc
	
	string $newObjList[] = $objList;
	for ($obj in $objList)
	{
		if (!(objExists($obj)))
		{
			$newObjList = stringArrayRemove({$obj}, $newObjList);
		}
	}
	$objList = $newObjList;
	if (size($objList) == 0)
	{
		return -1;
	}	
	//remove missing objects, return -1 if no objects to test
	
	for ($obj in $objList)
	{
		print ("\n"+$obj);
		int $noVerts[] = `polyEvaluate -v $obj`;
		$totalVerts = $totalVerts + $noVerts[0];
		for($k=0 ; $k < $noVerts[0]; $k++)
		{
			$vertList[size($vertList)] =  `pointPosition -w ($obj+".vtx["+$k+"]")`;
		}
	}
	//get a vector array of all verts in all objects.
	
	int $symmetryCount = 0;
	
	for ($v in $vertList)
	{
		for ($v2 in $vertList)
		{
			if (abs($v.y - $v2.y) < $tolerance)
			{
				if (abs($v.z - $v2.z) < $tolerance)
				{
					if (abs($v.x - (-1*$v2.x)) < $tolerance)
					{
						$symmetryCount++;
						break;
						//break prevents couniting multiple verts and getting more than 100%
					}
				}
			}
		}
	}
	//count points within the tolerance
	
	vector $vertList[] = {};
	//empty this array
	
	float $a = $symmetryCount;
	float $b = $totalVerts;
	//these need to be floats for calc below

	float $percentage = (($a/$b)*100);
	//print ("\nModel is " + $percentage + "% Symmetrical.");
	return $percentage;
		
	
}

global proc boltZeroMeshPivotOffsets()
{
	
	boltRemoveHierarchy;
	string $meshes[]= `ls -type "mesh"`;                            
                   
    for ($mesh in $meshes)
    {              
    	string $trans[] = `listRelatives -type "transform" -parent $mesh`; 
		//get the transform node for the mesh    
	
		if (`boltCheckForOffset $trans[0]` == 1)
		{
			print ("\nCorrecting pivot offset on " + $trans[0]);
			boltZeroPivotOffsetVertCheck $trans[0];
		}
		//check for offset and correct if needed.
	}
	
	boltRestoreHierarchy;
	print "\nPivot offset check complete";
	
}

global proc int boltCheckForOffset(string $node)
//tests for pivot offset, returns 1 if found
{
	//print "\nChecking for pivot offset on "; print $node;
	int $offset = 0;	
	if (`equivalentTol 0 (getAttr(($node + ".scalePivotX"))) 0.00001` == 0)  $offset = 1;
	if (`equivalentTol 0 (getAttr(($node + ".scalePivotY"))) 0.00001` == 0)  $offset = 1;
	if (`equivalentTol 0 (getAttr(($node + ".scalePivotZ"))) 0.00001` == 0)  $offset = 1;
	if (`equivalentTol 0 (getAttr(($node + ".rotatePivotX"))) 0.00001` == 0)  $offset = 1;
	if (`equivalentTol 0 (getAttr(($node + ".rotatePivotY"))) 0.00001` == 0)  $offset = 1;
	if (`equivalentTol 0 (getAttr(($node + ".rotatePivotZ"))) 0.00001` == 0)  $offset = 1;
	//check for any pivot offset
		
	return $offset;
}

		

global proc boltMovePivotTest(string $nodeToAlign, string $target, vector $offset)
//performs a test before moving pivot to see if it needs to be done - speeds things up.
{
	if (`boltCheckForOffset $target` == 1) 			boltZeroPivotOffsetVertCheck $target;
	if (`boltCheckForOffset $nodeToAlign` == 1) 	boltZeroPivotOffsetVertCheck $nodeToAlign;
	//zero pivot offsets only if needed
		
	float $matrixUnd[] = `xform -q -m $target`;
	float $matrixDam[] = `xform -q -m $nodeToAlign`;
	
	int $bad = 0;
	
	int $i; for ($i=0; $i<12; $i++)
	{
		if (`equivalentTol $matrixUnd[$i] $matrixDam[$i] 0.0001` == 0) $bad = ($i+1);
	}
			
	if (`equivalentTol $matrixUnd[12] ($matrixDam[12] - ($offset.x)) 0.0001` == 0) $bad = 13;
	if (`equivalentTol $matrixUnd[13] ($matrixDam[13] - ($offset.y)) 0.0001` == 0) $bad = 14;
	if (`equivalentTol $matrixUnd[14] ($matrixDam[14] - ($offset.z)) 0.0001` == 0) $bad = 15;
	
	if ($bad > 0)
	{
		print ("\n  Fixing pivot on: " + $nodeToAlign);
		boltMovePivot $nodeToAlign $target $offset;
	}
}


global proc int boltCloseTo (float $num1, float $num2, float $tol)
//tests wether two numbers are equal, within a given tollerance // USE maya equivalentTol()
{
	if ( (($num1-$num2) < $tol) && (($num1-$num2) > (-1 * $tol)) ) return 1;
	else return 0;
}


global proc int boltAreRotationsSimilar(string $node1, string $node2, float $tol)
//returns 1 if given transforms are close in rotation - using given $tol
{
	float $x1 = `getAttr ($node1 + ".rotateX")`;
	float $y1 = `getAttr ($node1 + ".rotateY")`;
	float $z1 = `getAttr ($node1 + ".rotateZ")`;
	float $x2 = `getAttr ($node2 + ".rotateX")`;
	float $y2 = `getAttr ($node2 + ".rotateY")`;
	float $z2 = `getAttr ($node2 + ".rotateZ")`;
	
	if ( (`equivalentTol $x1 $x2 $tol`) && (`equivalentTol $y1 $y2 $tol`) && (`equivalentTol $z1 $z2 $tol`) )
	{
		return 1;
	}
	return 0;
}
	
	
		
global proc boltMovePivot(string $nodeToAlign, string $target, vector $offset)
// moves the object's pivot to the same position as the target object, plus the offset
// must remove hierarchy before using
//added locked normals preservation code (fixed for multi locked normals per vert)
//now only rotates normals if needed (faster)
{
	//zero pivot offsets if needed
	
	python( ("superVertPaint.zeroPivotOffsetVertCheck('" + $target + "')") );
	python( ("superVertPaint.zeroPivotOffsetVertCheck('" + $nodeToAlign + "')") ); 
	//boltZeroPivotOffsetVertCheck $nodeToAlign;
	
	//is there any rotation needed?
	int $rotationsSimilar = `boltAreRotationsSimilar $nodeToAlign $target 0.0001`;
	
	if ($rotationsSimilar==1)
	{
		//run fast python pivot move
		python( ("superVertPaint.movePivot('"+$nodeToAlign+"', '"+$target+"')") );
	}
	else
	{
		//run slow mel normal correction script... openMaya is crashing a lot when reading nomals :(
		print "\nNormal rotation needed - running slow mel pivot match...";
		
		//get the target transform matrix as a string
		float $matrix[] = `xform -q -m $target`;
		string $matrixString = "";
		for ($m in $matrix) $matrixString = ($matrixString + " " + $m);

		//store vertex positions
		string $vtxList[] = `boltGetVerts $nodeToAlign`;
		float $vtxArray[];
		for ($n=0; $n<(size($vtxList)); $n++)
		{
			float $vtxPos[3]=`pointPosition -w $vtxList[$n]`;
			$vtxArray[$n*3+0]=$vtxPos[0];
			$vtxArray[$n*3+1]=$vtxPos[1];
			$vtxArray[$n*3+2]=$vtxPos[2];
		}

		string $vfList[] = {};     
		string $vfList2[] = {};    
		vector $normalList[] = {}; 

		//store any locked normals
		$vfList = `ls -fl ($nodeToAlign+".vtxFace[*][*]")`;
		for ($n=0; $n<(size($vfList)); $n++)
		{
			$isFrozen = `polyNormalPerVertex -q -freezeNormal $vfList[$n]`;
			if ($isFrozen[0] == 1)
			{
				//print ("\n" + $vfList[$n]);
				float $vec[] = `polyNormalPerVertex -q -xyz $vfList[$n]`;
				if (size($vec)>3)
				{
					print ("\nWARNING - $vfList[$n] has more than one normal - suggests locked normals are corrupted!");
					$vec = {$vec[0],$vec[1],$vec[2]};
				}
				$normalList[size($normalList)] = vector($vec);     
				$vfList2[size($vfList2)] = $vfList[$n];
				//print ($vfList[$n] + " " + $normalList[$n] + " stored! \n");
			}
		}

		//store the original transform matrix
		matrix $m1[4][4];
		$m1 = bolt.getWorldMatrix($nodeToAlign,0);
		
		//apply transform matrix to node
		eval ("xform -m " + $matrixString + " " + $nodeToAlign);	
		//offset the pivot
		move -ws -relative ($offset.x) ($offset.y) ($offset.z) $nodeToAlign;
		//move verts back into place
		for ($n=0; $n<(size($vtxList)); $n++)
		{
			move -a $vtxArray[$n*3+0] $vtxArray[$n*3+1] $vtxArray[$n*3+2] $vtxList[$n];
		}
	
		//store the new transform matrix
		matrix $m2[4][4];
		matrix $m3[4][4];
		$m2 = bolt.getWorldMatrix($nodeToAlign,1);
		$m3 = $m1 * $m2;
		float $m3List[] = bolt.MatrixToFloat($m3);
		
		if ( size($vfList2) > 0 )
		{
			//move locked normals back to original positions
			global string $gMainProgressBar;  // This is defined on maya startup
			progressBar -e -beginProgress -isInterruptable true -status "Rotating locked normals:" -maxValue (size($vfList2)) $gMainProgressBar;
			//string $hardEdges[] = boltNorms.getHardEdges($nodeToAlign);
			for ($n=0; $n<(size($vfList2)); $n++)
			{
				float $norm[] = $normalList[$n];
				$norm = pointMatrixMult($norm,$m3List);
				polyNormalPerVertex -xyz ($norm[0]) ($norm[1]) ($norm[2]) $vfList2[$n];
				//print ($vfList[$n] + " " + $normalList[$n] + " re-stored! \n");
				progressBar -edit -step 1 $gMainProgressBar;
			}
			
			//this hack needed to properly makes the soft edges soft
			select $nodeToAlign;
			boltNorms.SelectHard(0);
			if (size(`ls -sl`)>0) polySoftEdge -a 180 -ch 0;
			select -cl;
			
			//boltNorms.setHardEdges($nodeToAlign, $hardEdges);
			progressBar -e -endProgress $gMainProgressBar;
		}
		clear $vfList; clear $vfList2; clear $normalList;  
		clear $vtxArray; clear $vtxList;
		//clear arrays
	}
	
	select $nodeToAlign;
	selectPref -xns 0;	// re-enable object selecting
	select -cl;
	
	
	
}



global proc boltLockLocs(int $lock)
//1 locks, 0 unlocks locators and lattices in scene to prevent deletion
{
	string $lattices[] = `ls -type "lattice" -type "baseLattice"`;
	for ($lat in $lattices) lockNode -lock $lock $lat;
	//lock/unlock lattices to prevent deletion
		
	string $locs[] = `ls -type "locator"`;
	for ($loc in $locs) lockNode -lock $lock $loc;
	//lock/unlock locators to prevent deletion
	
	if ($lock == 1) print "\nLocators locked";
	if ($lock == 0) print "\nLocators unlocked";
}
	
	
global proc boltCheckMudOcc()
//checks whether mud and occlusion have been done
{
	global string $gBoltWarnings;
	string $msg;
		
	string $nodes[];
	$nodes = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	$nodes = stringArrayRemoveDuplicates($nodes);
	$dams = `ls -type "transform" "*_DAM*"`;
	$nodes = `stringArrayRemove $dams $nodes`;
	$cols = `ls -type "transform" "*_COL"`;
	$nodes = `stringArrayRemove $cols $nodes`;
	$zone = `ls -type "transform" "*ZONE*"`;
	$nodes = `stringArrayRemove $zone $nodes`;
	$boost = `ls -type "transform" "BOOST_*"`;
	$nodes = `stringArrayRemove $boost $nodes`;
	$occ = `ls -type "transform" "*_OCC"`;
	$nodes = `stringArrayRemove $occ $nodes`;
	
	//print $nodes;
	
	for ($node in $nodes)
	{
		//test for colour set
		string $cset[] = `polyColorSet -q -currentColorSet $node`;
		if ($cset[0] == "")
		{
			$msg = ("\nNo colour set found on " + $node);
			print $msg; $gBoltWarnings += $msg;
			continue;
		}
		
		int $vertCounts[] = `polyEvaluate -vertex $node`;
		int $vertCount = $vertCounts[0];
		//get num of verts
		
		int $flagMud = 0;
		int $flagOcc = 0;
		
		for ( $v = 0; $v < $vertCount; $v++ )
		//for each vert
		{
			//print "\n"; print $node;
			//print "\n"; print $v;	
						
			
			float $vertA[] 	 = `polyColorPerVertex -q -a -nun ($node + ".vtx[" + $v +"]")`;
			//get alpha
						
			if ($vertA[0] != 1)
			{
				$flagOcc = 1;
			}
			//flag if alpha other than 1 is found
			
			//float $vertR[] 	 = `polyColorPerVertex -q -r -nun ($node + ".vtx[" + $v +"]")`;
			////get R
			//
			//if (($vertR[0] != 1)&&($vertR[0] != 0))
			//{
			//	$flagMud = 1;
			//}
			////flag if mud other than 1 or 0 is found
						
		}
		
		if ($flagOcc == 0)
		{
			if ((`match "BULB_*" $node` != "BULB_")&&(`match "WINDOW_*" $node` != "WINDOW_")&&(`gmatch $node "*_SHADOW*"` != 1))
			//allow bulbs + windows, shadows to have no occlusion
			{
				$msg = "\nVertex alphas on " + $node + " all set to white. Has occlusion been done on this part?";
				print $msg; $gBoltWarnings += $msg;
			}
		}
		
		//if ($flagMud == 0)
		//{
			//$msg = "\nVertex mud on " + $node + " all set to white or black. Has mud been applied to this part?";
			//print $msg; $gBoltWarnings += $msg;
		//}
		//too many false warnings - disabled
			
	}
	print "\nMud and occlusion colour test complete.";
}







global proc boltAlignBoxPivot(string $box)
//aligns the pivot of a box shape.
{
	global string $gBoltWarnings;
	string $msg;
	
	string $shapes[] = `listRelatives -children -type "mesh" $box`;
	if ( size($shapes)==0 )
	{
		$msg = "\n" + $box + " Did not have a shape node. Pivot could not be aligned.";
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	
	int $v[] = `polyEvaluate -vertex $box`;
	int $e[] = `polyEvaluate -edge $box`;
	int $f[] = `polyEvaluate -face $box`;
	if (($v[0] != 8)||($e[0] != 12)||($f[0] != 6))
	{
		$msg = "\n" + $box + " was not a valid box shape built from quads. Pivot could not be aligned.";
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	//warn and quit if this is not a valid quad box.
	
	
	if (`boltAreAllCornersSquare $box`!=1)
	{
		$msg = "\n" + $box + " had 1 or more non-square corners. Pivot could not be aligned.";
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	
	boltAlignCornerPivot ($box + ".vtx[0]");
}

global proc int boltAreAllCornersSquare(string $box)
//returns 1 if all corners of the provided box are square (within 0.5 degrees)
{
	string $corners[] = `ls -fl ($box + "*.vtx[*]")`;
	
	for ($corner in $corners)
	{
		string $edges[] = `polyListComponentConversion -fromVertex -toEdge $corner`;
		$edges = `ls -flatten $edges`;
		if (size($edges) != 3)
		{
			print ("\nError - " + $corner + " needs to have three edges in order for squareness to be checked");
			return 0;
		} 
		string $axisPoints[] = {};
		for ($edge in $edges)
		{
			string $verts[] = `polyListComponentConversion -fromEdge -toVertex $edge`;
			$verts = `ls -flatten $verts`;
			for ($vert in $verts)
			{
				if (($vert != $corner)) // may need to check cornershape.vtx too???
				{
					$axisPoints[size($axisPoints)] = $vert;
				}
			}
		}
		//gets the 3 axis points related to our corner point.
		//print "\nAxis verts are: "; print $axisPoints;
		
  		float $pivPNT[] = `pointPosition -w $corner`;
  		float $xPNT[]   = `pointPosition -w $axisPoints[0]`;
  		float $yPNT[]   = `pointPosition -w $axisPoints[1]`;
  		float $zPNT[]   = `pointPosition -w $axisPoints[2]`;
  		//gets co-ords for the 3 points we are using
  	
  		vector $toX = << $xPNT[0]-$pivPNT[0],$xPNT[1]-$pivPNT[1],$xPNT[2]-$pivPNT[2] >>;
  		vector $toY = << $yPNT[0]-$pivPNT[0],$yPNT[1]-$pivPNT[1],$yPNT[2]-$pivPNT[2] >>;
  		vector $toZ = << $zPNT[0]-$pivPNT[0],$zPNT[1]-$pivPNT[1],$zPNT[2]-$pivPNT[2] >>;
  		
  		float $angXY = `angle $toX $toY`;
  		float $angYZ = `angle $toY $toZ`;
  		float $angZX = `angle $toZ $toX`;
  		//get angles between all vectors
  	
  		$angXY =  `rad_to_deg $angXY`;
  	    $angYZ =  `rad_to_deg $angYZ`;
  	    $angZX =  `rad_to_deg $angZX`;
  	  	   
  	  	if (!`equivalentTol $angXY 90 0.5`) return 0;
  	  	if (!`equivalentTol $angYZ 90 0.5`) return 0;
  	  	if (!`equivalentTol $angZX 90 0.5`) return 0; 
  	  	
  	}
  	
  	return 1;
  	//all corners must be square
  	
}

	


	
global proc boltAlignCornerPivot(string $corner)
//aligns the pivot to a right angled corner pivot, given an object and a corner vertex
//any hierarchy should be removed first
//Based on:  Script Name: mdAlignPivot v1.0, Author: Mark Doberenz
{	
	global string $gBoltWarnings;
	string $msg;
	
	string $tokens[];
	tokenize $corner "\." $tokens;
	string $obj = $tokens[0];
	string $vert = $tokens[1];
	string $s[] = `listRelatives -type "mesh" $obj`;
	string $shape = $s[0];
	string $cornerShape = ($shape + "." + $vert);
	//work out some shapes verts etc	
		
	string $edges[] = `polyListComponentConversion -fromVertex -toEdge $corner`;
	$edges = `ls -flatten $edges`;
	if (size($edges) != 3)
	{
		print ("\nError - " + $corner + " needs to have three edges in order for the pivot to be aligned to it");
		return;
	} 
	string $axisPoints[] = {};
	for ($edge in $edges)
	{
		string $verts[] = `polyListComponentConversion -fromEdge -toVertex $edge`;
		$verts = `ls -flatten $verts`;
		for ($vert in $verts)
		{
			if (($vert != $corner)&&($vert != $cornerShape))
			{
				$axisPoints[size($axisPoints)] = $vert;
			}
		}
	}
	//gets the 3 axis points related to our corner point.
	//print "\nAxis verts are: "; print $axisPoints;
	
	
  	float $pivPNT[] = `pointPosition -w $corner`;
  	float $zPNT[]   = `pointPosition -w $axisPoints[0]`;
  	float $xPNT[]   = `pointPosition -w $axisPoints[1]`;
  	//gets co-ords for the 3 points we are using
  	
  	vector $toZ = << $zPNT[0]-$pivPNT[0],$zPNT[1]-$pivPNT[1],$zPNT[2]-$pivPNT[2] >>;
  	vector $toX = << $xPNT[0]-$pivPNT[0],$xPNT[1]-$pivPNT[1],$xPNT[2]-$pivPNT[2] >>;
  	float $tmpFlt = `angle $toZ $toX`;
  	// CALCULATE VECTORS AND ANGLE FROM PIVOT POINT
  	
  	float $angleBetweenVectors = `rad_to_deg $tmpFlt`;
  	if (!`equivalentTol $angleBetweenVectors 90 0.5`)
  	{
  		$msg = "\n" + $corner + " had non right-angled edges (" + $angleBetweenVectors + " degrees). Pivot could not be aligned to this vertex.";
		print $msg; $gBoltWarnings += $msg;
		return;
  	}
  	//warn if non right angled corner is found
  	//print("\nAngle between vectors: " + `rad_to_deg $tmpFlt`);


  	string $tmp = `joint -p $xPNT[0] $xPNT[1] $xPNT[2] -n tmpJNT_1`;
  	joint -p $pivPNT[0] $pivPNT[1] $pivPNT[2] -n tmpJNT_2;
  	joint -e -zso -oj xyz tmpJNT_1;
  	joint -p $zPNT[0] $zPNT[1] $zPNT[2] -n tmpJNT_3;
  	joint -e -zso -oj xyz tmpJNT_2;
	// CREATE JOINTS AT THE 3 POINTS

 	$rotVal = `xform -q -ws -ro tmpJNT_2`;
 	// GET WORLD ROTATION VALUES OF JOINT 2
 	delete $tmp;
  	// DELETE THE TEMP JOINTS
  	 
  	string $vtxList[] = `boltGetVerts $obj`;
	float $vtxArray[];
	for ($n=0; $n<(size($vtxList)); $n++)
	{
		float $vtxPos[3]=`pointPosition -w $vtxList[$n]`;
		$vtxArray[$n*3+0]=$vtxPos[0];
		$vtxArray[$n*3+1]=$vtxPos[1];
		$vtxArray[$n*3+2]=$vtxPos[2];
	}
	//store vertex positions
  	
  	rotate -a $rotVal[0] $rotVal[1] $rotVal[2] $obj;
	//rotate the shape into position
  	  	
  	for ($n=0; $n<(size($vtxList)); $n++)
	move -a $vtxArray[$n*3+0] $vtxArray[$n*3+1] $vtxArray[$n*3+2] $vtxList[$n];
	//move verts back into place
		
	clear $vtxArray; clear $vtxList;
	//clear arrays

}


global proc boltRemoveColourSets()
//removes any surplus vertex colour sets
{
	string $objs[];
	$objs = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	$objs = stringArrayRemoveDuplicates($objs);
	
	for ($obj in $objs)
	{
		
		string $cSets[] = `polyColorSet -q -allColorSets $obj`;
		if (size($cSets) > 1)
		{
			for ($i=1; $i<(size($cSets));$i++)
			{
				polyColorSet -colorSet $cSets[$i] -delete $obj;
				print ("\nDeleted " + $cSets[$i] + " from " + $obj); 
			}
		}
	}
}



global proc vector boltReturnObjectCentre(string $obj)
//returns the average of all verts in an object
{
	int $vertCounts[] = `polyEvaluate -vertex $obj`;
	int $vertCount = $vertCounts[0];
	//get num of verts
	
	vector $centre = <<0,0,0>>;
			
	for ( $v = 0; $v < $vertCount; $v++ ) //for each vert
	{
		vector $p = `pointPosition -w ($obj+".vtx["+$v+"]")`;
		$centre = $centre + $p;
	}
	$centre = $centre / $vertCount;
	return $centre;
}


global proc boltCheckUVs()
{
	//check uv coords
	string $paintShaders[] = {"body_paint_metal","body_paint_carbon"};
	for ($paintShader in $paintShaders)
	{
		boltCheckUVCoords($paintShader);
	}
		
	//check uv ratios
	boltCheckUVRatios();
	
	//check flipped
	boltCheckForFlippedUVs();
}


global proc boltCheckForFlippedUVs()
//checks for flipped UVs, UV ratios and UV 0-1 for bodypaint.
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;

	string $objs[] = boltShapesToTransformsNoPath(`ls -type "mesh"`);
			
	string $shadersWithNoXmlInfo[] = {};
		
	for ($obj in $objs)
	{
		//print ("\nObject: " + $obj);   
		if (boltGetLodAndShadowNumber($obj) <= 4) //ignore lod 5 6 and shadows
		{
			string $objectSet = `sets -fc 1 ($obj + ".f[*]")`;
			string $shaders[] = boltGetMaterialsOnObj($obj);
				
			for ($shader in $shaders)
			{
				//print ("\nShader: " + $shader);
				int $uvMirror = boltGetUVMirrorFromXML($shader);
			
				if ($uvMirror == -1) 
				{
					$shadersWithNoXmlInfo[size($shadersWithNoXmlInfo)] = $shader;
				}
				if ($uvMirror == 0) //shader can't have flipped UVs
				{	
					//print ("Shader: " + $shader);
					string $sgs[] = getSGFromMaterial($shader);
					string $shadedPolys[] = `sets -intersection $sgs[0] $objectSet`;
					$shadedPolys = `ls -fl $shadedPolys`;
					int $flippedPolys = 0;
					for ($poly in $shadedPolys)
					{
						if (boltReturnUVWinding2(boltGetVertexOrder($poly)) == 1)
						{
							$flippedPolys++;
						}
					}
					
					if ( ($flippedPolys>=5) && ($flippedPolys<100) )
					{
						$msg = ("\nFlipped UVs Warning - " + $flippedPolys + " flipped UVs found on '" + $obj + "' using shader '" + $shader + "'. Use 'UV Tools > Edit UVs > Flipped UVs' to highlight.");
						print $msg; $gBoltWarningsLow += $msg;
					}
					if ($flippedPolys>=100)
					{
						$msg = ("\nFlipped UVs Error - " + $flippedPolys + " flipped UVs found on '" + $obj + "' using shader '" + $shader + "'. Use 'UV Tools > Edit UVs > Flipped UVs' to highlight.");
						print $msg; $gBoltWarnings += $msg;
					}
					
				}
			}
		}
	}
	$shadersWithNoXmlInfo = stringArrayRemoveDuplicates($shadersWithNoXmlInfo);
	
	
	for ($s in $shadersWithNoXmlInfo)
	{
		string $preset = boltGetShaderPreset($s);
		if (($s != "lambert1") && ($preset != "") )
		{
			if (`gmatch $preset "*.xml"`==1)
			{
				$msg = ("\nMaterial Preset Error - No UVMirror info found for " + $s + ". Please report error to Andy Bolt.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	
	print "\nFlipped UV checks complete.";

}


global proc int boltGetLodAndShadowNumber(string $part)
//returns the lod number of a given part name
{
	string $lod = `match "_LOD." $part`;
	string $no  = `match "[0-9]+" $lod`;
	
	if (`gmatch $part "*_SHADOW"`) $no = "7";
		
	if (size($no))
	{
		int $lodNo = $no;
		return $lodNo;
	}
	else
	{
		return 0;
	}
}



global proc boltCheckUVRatios()
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;
	
	string $objs[] = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	
	string $shadersWithNoXmlInfo[] = {};
	
	//get a set of all polys to check
	string $polySet = `sets -facets 1 -empty`;
	string $objs[] = boltShapesToTransformsNoPath(`ls -type "mesh"`);
	for ($obj in $objs)
	{
		if ( (boltGetLodAndShadowNumber($obj) <= 4) && (`gmatch $obj "*_DAM"` == 0) ) //ignore lod 5 6 and shadows, _DAM 
		{
			sets -add $polySet ($obj + ".f[*]");
		}
	}
	
	
	$shaders = `ls -type "ATGMaterial"`;
	for ($shader in $shaders)
	{
		string $errorShells = "";
		int $errorCount = 0;
		
		int $uvRatio = boltGetUVRatioFromXML($shader);
		
		if ($uvRatio == -1) 
		{
			$shadersWithNoXmlInfo[size($shadersWithNoXmlInfo)] = $shader;
		}
		if ($uvRatio == 1)
		{	
			//print ("Shader: " + $shader);
			string $sgs[] = getSGFromMaterial($shader);
			
			if (size($sgs)==0)
			{
				$msg = ("\nUV Ratio Error - Material '" + $shader + "' has no shading group - suggests corrupt scene or missing shaders.");
				print $msg; print "\n"; $gBoltWarnings += $msg; 
				continue;
			}
			
			string $shadedPolys[] = `sets -intersection $sgs[0] $polySet`;
			string $shadedPolys[] = `ls -fl $shadedPolys`;
			
			int $whileLimit = size($shadedPolys);
			while (size($shadedPolys) > 0)
			{
				
				// get uv shell of first face in list
				select -r $shadedPolys[0];
				polySelectConstraint -type 0;
				polySelectConstraint -shell 1 -border 0 -mode 2;
				string $uvShell[] = `ls -sl -fl`;
				polySelectConstraint -sh 0 -bo 0 -m 0;

				//get ratio of still selected shell faces
				float $ratio = python("uvratio.get_sel_faces_UV_ratio(2)");
				if (equivalentTol($ratio,0,0.000001)==0) $ratio = 1/$ratio;
				
				if (equivalentTol($ratio,25,4)==0)
				{
					$errorShells = $errorShells + $shadedPolys[0] + "(" + $ratio + "), ";
					$errorCount++;
				}
				// remove these faces from the original list of faces.
				$shadedPolys = stringArrayRemoveExact($uvShell, $shadedPolys);
				
				$whileLimit --;
				if ($whileLimit < 0) error "Stuck in UV shell loop!";
				
			}
			
			if ($errorShells != "")
			{
				$msg = ("\nUV Ratio Error - Material '" + $shader + "' has " + $errorCount + " UV shells with incorrect UV Ratios:     " + $errorShells);
				print $msg; print "\n"; $gBoltWarnings += $msg; 
			}
		}
	}
	$shadersWithNoXmlInfo = stringArrayRemoveDuplicates($shadersWithNoXmlInfo);
	for ($s in $shadersWithNoXmlInfo)
	{
		string $preset = boltGetShaderPreset($s);
		if (($s != "lambert1") && ($preset != "") )
		{
			if (`gmatch $preset "*.xml"`==1)
			{
				$msg = ("\nMaterial Preset Error - No UVRatio info found for " + $s + ". Please report error to Andy Bolt.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	select -cl;
}


global proc int boltGetUVRatioFromXML(string $shader)
//reads the uv ratio flag out of the shader xml file. returns -1 if none found.
{	
	string $xmlpath =  boltGetShaderPreset($shader);
	if ($xmlpath == "") return -1;
	string $xmlstring[] = boltLoadTextFile ($xmlpath);
	string $test = "";
	$test = boltGetStringFromXML("bolt_uratio=", $xmlstring);
	if ($test == "") return -1;
	int $uvRatio = $test;
	return $uvRatio;
}

global proc int boltGetUVMirrorFromXML(string $shader)
//reads the uv mirror flag out of the shader xml file. returns -1 if none found.
// 1= uvs on shader are mirrorable 
{	
	string $xmlpath =  boltGetShaderPreset($shader);
	if ($xmlpath == "") return -1;
	string $xmlstring[] = boltLoadTextFile ($xmlpath);
	string $test = "";
	$test = boltGetStringFromXML("bolt_mirror=", $xmlstring);
	if ($test == "") return -1;
	int $mirror = $test;
	return $mirror;
}



global proc boltCheckUVCoords(string $shader)
//warns if the uv coords of the specified shader are not between 0 and 1
{
	global string $gBoltWarnings;
	
	if (`objExists $shader` == 0) return;
	
	string $sgs[] = getSGFromMaterial($shader);
	string $sel[] = `ls -sl`;
	select -r $sgs[0];
	float $bb[] = `polyEvaluate -boundingBoxComponent2d`;
	//xmin xmax ymin ymax
			
	if ( ($bb[0]<0) || ($bb[1]>1) || ($bb[2]<0) || ($bb[3]>1) )
	{
		$msg = ("\nUV Mapping Error - UVs on " + $shader + " found outside the 0-1 space");
		print $msg; $gBoltWarnings += $msg;
	}
	select -r $sel;
}





global proc boltCheckForUnmappedVerts()
{
	global string $gBoltWarnings;
	string $msg;
	
	string $shapes[] = `ls -type "mesh"`;
	string $objs[] = `boltShapesToTransformsNoPath $shapes`;
	
	for ($obj in $objs)
	{
		if (!(`gmatch $obj "BODY*_COL*"`)) //ignore collison shapes
		{
			string $verts[] = `boltListUnmappedVerts $obj`;
			if (size($verts)>0)
			{
				$msg = ("\n" + size($verts) + " unmapped verts found on " + $obj + ". Use 'UV Tools > Edit UVs > Unmapped Verts' to highlight.");
				print $msg; $gBoltWarnings += $msg;
			} 
		}
	}
	print "\nUnmapped vert check complete.";
}

		
global proc boltWriteSCVLogFile()
{	
	string $log = "";
	$log += ("<Vehicle>");
	
	string $vehicleType = `boltGetVehicleType`;
	string $filePath = `file -q -sn`;
	string $fileName = `match "[^/\\]*$" $filePath`;
	string $vehicleNo = `match "[0-9]+" $fileName`;
	
	if ($vehicleType == "") return; //don't write a log if vehicle type not found
	
	$log += ("\n<Name>" + $vehicleType + $vehicleNo + "</Name>");
	$log += ("\n<Path>" + $filePath + "</Path>");
	//vehicle name and number + path
	
	string $userName = `system("echo %username%")`;
	$userName = `match "^[^(\r\n)]*" $userName`; //strip trailing CRs
	$log += ("\n<User>" + $userName + "</User>");
	//username
	
	string $date = `date -format "DD/MM/YYYY"`;
	string $time = `date -format "hh:mm"`;
	
	$log += ("\n<Date>" + $date + "</Date>");	
	$log += ("\n<Time>" + $time + "</Time>");
	//date + time
	
	int $noLods = 6;
	int $polyCounts[];
	int $nodeCounts[];
			
	for ($i=0; $i<$noLods; $i++)
	{
		$polyCounts[$i] = `boltGetPolyCount ("_LOD"+$i) "CAR"`;
		$nodeCounts[$i] = `boltGetNodeCount ("_LOD"+$i)`;		
	}
	
	for ($i=0; $i<$noLods; $i++)
	{
		$log += ("\n<Lod"+$i+"Polys>" + $polyCounts[$i] + "</Lod"+$i+"Polys>");
	}
	//print polycount info
	
	for ($i=0; $i<$noLods; $i++)
	{
		$log += ("\n<Lod"+$i+"Nodes>" + $nodeCounts[$i] + "</Lod"+$i+"Nodes>");
	}
	//print nodecount info
		
	string $currentLivery[] = `boltGetCurrentLivery`;
	int $liverySizes[] = {};
	int $liveryShaders[] = {};
	string $liveryNos[] = `boltGetSceneLiveryNos`;
	
	boltSwitchLivery 1;
	refresh;
	$liverySizes[0] = `boltVehicleTextureMemory`;
	$liveryShaders[0] = size(`boltGetUsedShaders`);
	
	//get size and no shaders on first livery
	
	string $no = `match "[0-9]+" $currentLivery[0]`;
	boltSwitchLivery $no;
	//restore original livery
		
	$log += ("\n<LV01Memory>" + $liverySizes[0] + "</LV01Memory>");
	$log += ("\n<LV01Shaders>" + $liveryShaders[0] + "</LV01Shaders>");
	//get + print amount of textures and shaders used for each livery	
	
	float $dims[] = `boltGetDimensions`;
	//returns {ride height, height, width, length, wheelbase} based on BODY_COL
	
	int $layout = `boltGetVehicleLayout`;
	
	int $xres = 2048;
	int $yres = 1024;
	if ( $layout==2 || $layout==3 || $layout==4 ) 
	{
		$xres = 1024;
		$yres = 1024;
	}
	//set lower res for bike classes
		
	float $aspect[] = `boltGetBodypaintAspect $xres $yres`;
			
	$log += ("\n<Width>" + 		`boltFloatToString $dims[2] 3` + "</Width>");
	$log += ("\n<Length>" + 	`boltFloatToString $dims[3] 3` + "</Length>");
	$log += ("\n<Height>" + 	`boltFloatToString $dims[1] 3` + "</Height>");
	$log += ("\n<RideHeight>" + `boltFloatToString $dims[0] 3` + "</RideHeight>");
	$log += ("\n<Wheelbase>" + 	`boltFloatToString $dims[4] 3` + "</Wheelbase>");
	$log += ("\n<TexelAspect>" +  `boltFloatToString $aspect[0] 3` + "</TexelAspect>");
	$log += ("\n<TexelDensity>" + `boltFloatToString $aspect[1] 1` + "</TexelDensity>");
	
	//list of disabled scv options
	
	string $logFileName = ("//motorstorm3/art/vehicles/carvalidatorlogs/" + $vehicleType + $vehicleNo + "_LOG.txt" );
	$fileId=`fopen $logFileName "w"`;
	fprint $fileId $log;
	fclose $fileId;		
	//write log to disk
	
	print ("\nLog file written to: " + $logFileName);
	
}


global proc boltWriteSwapShapesLogFile()
//writes audit file to disk for currently loaded vehicle
{	
	string $log = "";
	
	string $vehicleType = `boltGetVehicleType`;
	string $filePath = `file -q -sn`;
	string $fileName = `match "[^/\\]*$" $filePath`;
	string $vehicleNo = `match "[0-9]+" $fileName`;
	
	if ($vehicleType == "") return; //don't write a log if vehicle type not found
	
	string $baseSwaps[] = boltGetSwappableBaseParts();
	
	for ($baseSwap in $baseSwaps)
	{		
		$swapOptions = boltGetSwappableOptionsForPart($baseSwap);
		
		$log += size($swapOptions);
		
		for ($swapOption in $swapOptions)
		{
			$log += (" " + $swapOption);
		}
		$log += "\n";
	}			
		
	string $logFileName = ("//motorstorm3/art/vehicles/carvalidatorlogs/swapshapelogs/" + $vehicleType + $vehicleNo + "_SWP.txt" );
	$fileId=`fopen $logFileName "w"`;
	fprint $fileId $log;
	fclose $fileId;		
	//write log to disk
	
	print ("\nSWP Log file written to: " + $logFileName);
}



global proc boltUpdateXMLLogFile()
//scans the server for vehicle logs, and then combines them into 1 large xml file 
{
	$xmlFile = "//motorstorm3/art/vehicles/carvalidatorlogs/AllVehicleLogs.xml";
	$xmlPath = "//motorstorm3/art/vehicles/carvalidatorlogs/";
		
	string $logs[] = `getFileList -filespec "*_LOG.txt" -folder $xmlPath`;
	string $scvs[] = `getFileList -filespec "*_SCV.txt" -folder $xmlPath`;
	string $gpus[] = `getFileList -filespec "*_GPU.txt" -folder $xmlPath`;
	
	string $xml = "<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>";
	$xml += "\n<SuperCarValidatorReports>\n\n";
		
	for ($log in $logs)
	{
		$fileId=`fopen ($xmlPath + $log) "r"`;
		string $nextLine = `fgetline $fileId`;
		$xml += $nextLine;
		while ( size( $nextLine ) > 0 ) 
   		{
   	 		$nextLine = `fgetline $fileId`;
   	 		$xml += $nextLine;
   		}
		fclose $fileId;
		
		
		string $gpu = `substitute "_LOG.txt" $log "_GPU.txt"`;
		
		if (`sFindItem $gpus $gpu` != -1)
		//if the gpu report log exists
		{
			$fileId=`fopen ($xmlPath + $gpu) "r"`;
			string $nextLine = `fgetline $fileId`;
			
			for ($i=0; $i<9; $i++)
			{
				if (`gmatch $nextLine "LOD*"`)
				{
					string $buffer[];
					$numTokens = `tokenize $nextLine $buffer`;
					$xml += "\n<"+ $buffer[0] + "GPU>" + $buffer[1] + "</"+ $buffer[0] + "GPU>";
				}
				$nextLine = `fgetline $fileId`;
			}
		}
		else
		//add a blank SCV log entry
		{
			$xml += "\n<LOD0GPU>0</LOD0GPU>";
			$xml += "\n<LOD1GPU>0</LOD1GPU>";
			$xml += "\n<LOD2GPU>0</LOD2GPU>";
			$xml += "\n<LOD3GPU>0</LOD3GPU>";
			$xml += "\n<LOD4GPU>0</LOD4GPU>";
			$xml += "\n<LOD5GPU>0</LOD5GPU>";
			$xml += "\n<LOD6GPU>0</LOD6GPU>";
		}
		
		
		
		string $scv = `substitute "_LOG.txt" $log "_SCV.txt"`;
		
		if (`sFindItem $scvs $scv` != -1)
		//if the scv error log exists
		{
			$fileId=`fopen ($xmlPath + $scv) "r"`;
			string $nextLine = `fgetline $fileId`;
			string $scvErrorString = ("\n" + $nextLine);
			
			int $shortEdges[] = {0,0,0,0,0,0,0};
				
			while ( size( $nextLine ) > 0 ) 
   			{
   	 			$nextLine = `fgetline $fileId`;
   	 			$scvErrorString += $nextLine;
   				
   				for ($lod=0;$lod<7;$lod++)
   				{
   					if (`gmatch $nextLine ("*sub-pixel-length edges found on LOD" + $lod + "*")`)
   					{
   						string $buffer[]; tokenize $nextLine $buffer;
   						$shortEdges[$lod] = $buffer[0];	
   					}
   				}
   				//write out num short edges to array
   				   				
   			}
			fclose $fileId;
			
			for ($lod=0;$lod<7;$lod++)
   			{
   				$xml += "\n<LOD" + $lod + "ShortEdges>" + $shortEdges[$lod] + "</LOD" + $lod + "ShortEdges>";		
   			}	
   			//write out num short edges to xml. Any missing lods will be set to zero.
				
			$xml += $scvErrorString;
			
		}
		else
		//add a blank SCV log entry
		{
			$xml += "\n<LOD0ShortEdges>0</LOD0ShortEdges>";	
			$xml += "\n<LOD1ShortEdges>0</LOD1ShortEdges>";	
			$xml += "\n<LOD2ShortEdges>0</LOD2ShortEdges>";	
			$xml += "\n<LOD3ShortEdges>0</LOD3ShortEdges>";	
			$xml += "\n<LOD4ShortEdges>0</LOD4ShortEdges>";	
			$xml += "\n<LOD5ShortEdges>0</LOD5ShortEdges>";		
   			$xml += "\n<LOD6ShortEdges>0</LOD6ShortEdges>";			
			$xml += "\n<SCVWarnings>";
			$xml += "\n</SCVWarnings>";
		}
		
		$xml += ("\n</Vehicle>");
		$xml += "\n\n";
	}
	
	$xml += "</SuperCarValidatorReports>";
	
	$fileId=`fopen $xmlFile "w"`;
	fprint $fileId $xml;
	fclose $fileId;		
	//write xml to disk
	
	print ("\nXML written to: " + $xmlFile);
		
}


global proc float boltGetWheelbase()
//returns the wheelsbase of any car or bike
{
	string $fWheels[] = `ls -type "transform" "WHEEL_F*"`;
	string $bWheels[] = `ls -type "transform" "WHEEL_B*"`;

	if ((size($fWheels))&&(size($bWheels)))
	{
		float $fWheelPos[] = `xform -q -ws -t $fWheels[0]`;
		float $bWheelPos[] = `xform -q -ws -t $bWheels[0]`;
		float $wheelbase = `abs ($fWheelPos[2] - $bWheelPos[2])`;
		return $wheelbase;
	}
	else
	{
		return 0;
	}
}

global proc float[] boltGetDimensions()
//returns {ride height, height, width, length, wheelbase} based on BODY_COL
{
	if (objExists("BODY_COL") && objExists("BODY_COLShape"))
	{
		float $dims[] = {};
		float $bb[] = `polyEvaluate -boundingBox "BODY_COL"`;
		
		$dims[0] = $bb[2];
		$dims[1] = $bb[3];
		$dims[2] = `abs ($bb[0] - $bb[1])`;
		$dims[3] = `abs ($bb[4] - $bb[5])`;
		$dims[4] = `boltGetWheelbase`;
		
		return $dims;
	}
	else
	{
		return {0.0,0.0,0.0,0.0,0.0};
	}
}



global proc boltOpenExcelLog()
{
	system "load \\\\motorstorm3\\art\\vehicles\\CarValidatorLogs\\AllVehicleLogs.xlsx";
}



global proc boltValidateChassis()
//checks that the position of all wheels and hubs is correct.
{
	boltCompareWheelPositions "WHEEL_FL" "WHEEL_BL" "Z" 0.005 -1;
	boltCompareWheelPositions "WHEEL_FR" "WHEEL_BR" "Z" 0.005 -1;
	boltCompareWheelPositions "WHEEL_FL" "WHEEL_FR" "Z" 0.005 1; 
	boltCompareWheelPositions "WHEEL_BL" "WHEEL_BR" "Z" 0.005 1;
	boltCompareWheelPositions "WHEEL_FL" "WHEEL_FR" "X" 0.005 -1;
	boltCompareWheelPositions "WHEEL_BL" "WHEEL_BR" "X" 0.005 -1;
		
	boltCompareWheelPositions "HUB_FL" "HUB_BL" "Z" 0.005 -1;
	boltCompareWheelPositions "HUB_FR" "HUB_BR" "Z" 0.005 -1;
	boltCompareWheelPositions "HUB_FL" "HUB_FR" "Z" 0.005 1; 
	boltCompareWheelPositions "HUB_BL" "HUB_BR" "Z" 0.005 1;
	boltCompareWheelPositions "HUB_FL" "HUB_FR" "X" 0.005 -1;
	boltCompareWheelPositions "HUB_BL" "HUB_BR" "X" 0.005 -1;
	//check wheel and hub positional symmetry on x and z axis
	
	print "\nWheel locations checked.";
}

global proc boltCompareWheelPositions (string $node1, string $node2, string $axis, float $tolerance, int $sign)
//compares two nodes to check that their positions are mirrored.
{
	global string $gBoltWarnings;
	string $msg;
	
	if ((`objExists $node1` == 0)||(`objExists $node2` == 0))
	{
		$msg = ("\nError comparing " + $node1 + " and " + $node2 + " positions. One of the nodes is missing.");
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	//warn + quit if objects are missing
	
	int $axisIndex = 0;
	if ($axis == "X") $axisIndex = 0;
	if ($axis == "Y") $axisIndex = 1;
	if ($axis == "Z") $axisIndex = 2;
	
	float $node1Pos[] = `xform -q -ws -t $node1`;
	float $node2Pos[] = `xform -q -ws -t $node2`;	

	if (`equivalentTol $node1Pos[$axisIndex] ($node2Pos[$axisIndex]*$sign) $tolerance` == 0)
	{
		$msg = ("\n" + $node1 + " and " + $node2 + " are not the same distance from 0 on the " + $axis + "-axis.");
		print $msg; $gBoltWarnings += $msg;
	}
}



global proc boltCheckWheelPositions (string $node, int $xSign, int $zSign, int $hub)
//checks if node is within wheel tolerances
//x and y sign determine which quadrant wheel/hub is in.
//$hub flags hub object. 0=wheel 1=hub
{
	global string $gBoltWarnings;
	string $msg;
	
	if (`objExists $node` == 0)
	{
		$msg = ("\nError checking " + $node + " position. The node is missing.");
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	//warn + quit if objects are missing
		
	float $dimensions[] = `boltGetChassisDimensionsForClass`;
	float $nodePos[] = `xform -q -ws -t $node`;   
    
    float $ZMin = ($dimensions[0]*$zSign)-($dimensions[0]*0.075);
    float $ZMax = ($dimensions[0]*$zSign)+($dimensions[0]*0.075);
    
    float $FWheelXMin = (($dimensions[1]+$dimensions[3])*$xSign)-(($dimensions[1]+$dimensions[3])*0.075); 
    float $FWheelXMax = (($dimensions[1]+$dimensions[3])*$xSign)+(($dimensions[1]+$dimensions[3])*0.075); 
    float $BWheelXMin = (($dimensions[2]+$dimensions[4])*$xSign)-(($dimensions[2]+$dimensions[4])*0.075); 
    float $BWheelXMax = (($dimensions[2]+$dimensions[4])*$xSign)+(($dimensions[2]+$dimensions[4])*0.075); 
   	
   	float $FHubXMin = ($dimensions[1]*$xSign)-($dimensions[1]*0.075); 
    float $FHubXMax = ($dimensions[1]*$xSign)+($dimensions[1]*0.075); 
    float $BHubXMin = ($dimensions[2]*$xSign)-($dimensions[2]*0.075); 
    float $BHubXMax = ($dimensions[2]*$xSign)+($dimensions[2]*0.075); 
      	
   	int $posOK = 1;
   	
   	if ($nodePos[2] > $ZMax) {$posOK = 0;  print "fail zmax";}
   	if ($nodePos[2] < $ZMin) {$posOK = 0;  print "fail zmin";}
   	
   	if ($hub == 0)
   	{
   		if ($zSign > 0) //positive, front wheel
   		{
   			if ($nodePos[0] > $FWheelXMax) $posOK = 0;
   			if ($nodePos[0] < $FWheelXMin) $posOK = 0;
   		}
   		if ($zSign < 0)
   		{
   			if ($nodePos[0] > $BWheelXMax) $posOK = 0;
   			if ($nodePos[0] < $BWheelXMin) $posOK = 0;
   		}
   	}
   	
   	if ($hub == 1)
   	{
   		if ($zSign > 0) //positive, front wheel
   		{
   			if ($nodePos[0] > $FHubXMax) {$posOK = 0; print "fail hubF xmax";}
   			if ($nodePos[0] < $FHubXMin) {$posOK = 0; print "fail hubF xmin";}
   		}
   		if ($zSign < 0)
   		{
   			if ($nodePos[0] > $BHubXMax) {$posOK = 0; print "fail hubB xmax";}
   			if ($nodePos[0] < $BHubXMin) {$posOK = 0; print "fail hubB xmin";}
   		}
   	}
   			
   	
   	if ($posOK == 0)
	{
		$msg = ("\n" + $node + " is not within positional tolerances for this vehicle class. Use '+ Chassis Guides' to check limits.");
		print $msg; $gBoltWarnings += $msg;
	}
}
    
global proc boltCheckBikeWheelPositions (string $node, int $zSign)
//checks if node is within wheel tolerances
//zsign determines front or back wheel

{
	global string $gBoltWarnings;
	string $msg;
	
	if (`objExists $node` == 0)
	{
		$msg = ("\nError checking " + $node + " position. The node is missing.");
		print $msg; $gBoltWarnings += $msg;
		return;
	}
	//warn + quit if objects are missing
		
	float $dimensions[] = `boltGetChassisDimensionsForClass`;
	float $nodePos[] = `xform -q -ws -t $node`;   
    
    int $posOK = 1;
    
    if (`equivalentTol $nodePos[0] 0 0.005` == 0) $posOK = 0;
    if (`equivalentTol $nodePos[2] ($dimensions[0]*$zSign) 0.005` == 0) $posOK = 0;
    
    if ($posOK == 0)
	{
		$msg = ("\n" + $node + " is not within positional tolerances for this vehicle class. Use '+ Chassis Guides' to check limits.");
		print $msg; $gBoltWarnings += $msg;
	}
}     

global proc boltCreateChassisGuides()
//adds planes to the scene to define the allowable chassis sizes for this class
{
	
	float $dimensions[] = `boltGetChassisDimensionsForClass`;
	int $vehicleLayout = `boltGetVehicleLayout`;
	string $plane[]; //temp variable
	
	float $ZVariation = $dimensions[0]*0.15;
	float $FHubXVariation = $dimensions[1]*0.15;
	float $BHubXVariation = $dimensions[2]*0.15;
	float $FWheelXVariation = ($dimensions[1]+$dimensions[3])*0.15;
	float $BWheelXVariation = ($dimensions[2]+$dimensions[4])*0.15;
	
	if ($vehicleLayout == 0) //unrecognised
	{
		warning "Failed to add chassis guides. Vehicle type not recognised - check filename is correct";
		return;
	}
	
	if ($vehicleLayout == 2) //bikes
	{
		$plane = `polyPlane -h 0.02 -w 0.02 -sx 2 -sy 2 -n "GUIDE_WHEEL_F_PIVOT"`;
		move -absolute 0 -0.3 $dimensions[0] $plane[0];
		$plane = `polyPlane -h 0.02 -w 0.02 -sx 2 -sy 2 -n "GUIDE_WHEEL_B_PIVOT"`;
		move -absolute 0 -0.3 (-1*$dimensions[0]) $plane[0];
			
		return;
	}
	else //4 wheeled vehicles
	{
		$plane = `polyPlane -h $ZVariation -w $FHubXVariation -sx 2 -sy 2 -n "GUIDE_HUB_FL_PIVOT"`;
		move -absolute $dimensions[1] -0.3 $dimensions[0] $plane[0];
		$plane = `polyPlane -h $ZVariation -w $BHubXVariation -sx 2 -sy 2 -n "GUIDE_HUB_BL_PIVOT"`;
		move -absolute $dimensions[2] -0.3 (-1*$dimensions[0]) $plane[0];
		$plane = `polyPlane -h $ZVariation -w $FHubXVariation -sx 2 -sy 2 -n "GUIDE_HUB_FR_PIVOT"`;
		move -absolute (-1*$dimensions[1]) -0.3 $dimensions[0] $plane[0];
		$plane = `polyPlane -h $ZVariation -w $BHubXVariation -sx 2 -sy 2 -n "GUIDE_HUB_BR_PIVOT"`;
		move -absolute (-1*$dimensions[2]) -0.3 (-1*$dimensions[0]) $plane[0];
		
		$plane = `polyPlane -h $ZVariation -w $FWheelXVariation -sx 2 -sy 2 -n "GUIDE_WHEEL_FL_PIVOT"`;
		move -absolute ($dimensions[1]+$dimensions[3]) -0.3 $dimensions[0] $plane[0];
		$plane = `polyPlane -h $ZVariation -w $BWheelXVariation -sx 2 -sy 2 -n "GUIDE_WHEEL_BL_PIVOT"`;
		move -absolute ($dimensions[2]+$dimensions[4]) -0.3 (-1*$dimensions[0]) $plane[0];
		$plane = `polyPlane -h $ZVariation -w $FWheelXVariation -sx 2 -sy 2 -n "GUIDE_WHEEL_FR_PIVOT"`;
		move -absolute (-1*($dimensions[1]+$dimensions[3])) -0.3 $dimensions[0] $plane[0];
		$plane = `polyPlane -h $ZVariation -w $BWheelXVariation -sx 2 -sy 2 -n "GUIDE_WHEEL_BR_PIVOT"`;
		move -absolute (-1*($dimensions[2]+$dimensions[4])) -0.3 (-1*$dimensions[0]) $plane[0];
		
		return;
	}
}	

global proc boltDeleteChassisGuides()
//removes all chassis guides from the scene
{		
	delete "GUIDE_WHEEL_*";
	delete "GUIDE_HUB_*";
}









//modified maya script - doesn't delete unused shaders

////////////////////////////////////////////////////////////////////////////////

// Copyright (C) 1997-2006 Autodesk, Inc., and/or its licensors.
// All rights reserved.
//
// The coded instructions, statements, computer programs, and/or related
// material (collectively the "Data") in these files contain unpublished
// information proprietary to Autodesk, Inc. ("Autodesk") and/or its licensors,
// which is protected by U.S. and Canadian federal copyright law and by
// international treaties.
//
// The Data is provided for use exclusively by You. You have the right to use,
// modify, and incorporate this Data into other products for purposes authorized 
// by the Autodesk software license agreement, without fee.
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND. AUTODESK
// DOES NOT MAKE AND HEREBY DISCLAIMS ANY EXPRESS OR IMPLIED WARRANTIES
// INCLUDING, BUT NOT LIMITED TO, THE WARRANTIES OF NON-INFRINGEMENT,
// MERCHANTABILITY OR FITNESS FOR A PARTICULAR PURPOSE, OR ARISING FROM A COURSE 
// OF DEALING, USAGE, OR TRADE PRACTICE. IN NO EVENT WILL AUTODESK AND/OR ITS
// LICENSORS BE LIABLE FOR ANY LOST REVENUES, DATA, OR PROFITS, OR SPECIAL,
// DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES, EVEN IF AUTODESK AND/OR ITS
// LICENSORS HAS BEEN ADVISED OF THE POSSIBILITY OR PROBABILITY OF SUCH DAMAGES.

////////////////////////////////////////////////////////////////////////////////
//
//  Procedure Name:
//      MLdeleteUnused
//
//  Description:
// 		Delete unused rendering nodes (ML stands for MultiLister, 
//		the old shading interface).
//		
//  Input Arguments:
//      None.
//
//  Return Value:
//      None.
//


proc string[] getRenderNodes()
//
//	Procedure: getRenderNodes()
//
//	Purpose:
//
//		Lists all nodes in the scene that are classified as shading nodes
//		(shaders, textures, utilities, or imageplanes).  Each type of node
//		has a static classification type.  We use listNodeTypes() to get a
//		list of the shading node types, then "ls -type" to list the nodes of
//		those types in the scene.
//
//		This code used to iterate through every node in the scene, checking its
//		classification to see if it is a rendering node.  This was unnecessary, 
//		as classifications are associated with node types, not individual nodes.
//		This new approach is much more efficient.
//
{
	string $renderTypes[] = `listNodeTypes "texture"`;
	$renderTypes = stringArrayCatenate( $renderTypes, `listNodeTypes "utility"` );
	$renderTypes = stringArrayCatenate( $renderTypes, `listNodeTypes "imageplane"` );
	$renderTypes = stringArrayCatenate( $renderTypes, `listNodeTypes "shader"` );

	string $cmd = "ls -long ";
	string $t;
	for( $t in $renderTypes )
	{
		$cmd += (" -type " + $t + " ");
	}

	string $renderNodes[] = eval($cmd);
	$renderNodes = stringArrayCatenate( $renderNodes, `lsThroughFilter "DefaultMrNodesFilter"` );
	return $renderNodes;
};

global proc int boltMLdeleteUnused() 
{
	//	Are we being called during an Optimize Scene Size operation?
	// 	If so, we need to display progress information.  This was done
	//	as a global variable to avoid having to change the signature of
	//	the proc, as that could break many scripts, both internal and
	//	customer-written.
	//
	int $showProgress = cleanUp_ShouldReportProgress();
	
	int $i, $j, $count;

	//------------------------------------------------------------------------
	//	Stage 1: Delete empty shading groups, as well as shading groups that
	//			 have no connected surface, volume, or displacement shaders.
	//
	string $sets[] = `ls -sets`;
	string $objs[];
	$count = `size($sets)`;

	int $numDeleted = 0;
	int $interrupted = 0;

	//	initialize progress bar for stage 1 if required
	//
	if( $showProgress )
	{
		cleanUp_StartProgress( $count, "Rendering Nodes: Deleting empty shading groups", 1 );
	}

	string  $shaders[] = {	".surfaceShader",
							".volumeShader",
							".displacementShader",
							".miMaterialShader",
							".miShadowShader",
							".miVolumeShader",
							".miPhotonShader",
							".miPhotonVolumeShader",
							".miDisplacementShader",
							".miEnvironmentShader",
							".miLightMapShader",
							".miContourShader"
							}; 
	
	for ($i = 0; $i < $count; $i++) 
	{
		//	check for user interrupt if required
		//
		if( $showProgress )
		{
			if( cleanUp_SetProgress( $i ) )
			{
				$interrupted = 1;
				break;
			}
		}

		if (`sets -q -renderable $sets[$i]`) {
			if ($sets[$i] != "initialShadingGroup" &&
				$sets[$i] != "initialParticleSE" &&
				$sets[$i] != "defaultLightSet") {
				
				// connection to dag objects
				$objs = `sets -q $sets[$i]`;
				
				// connection to render layers means that 
				// the shading engine is used as a override
				// or assigned to a render layer member.
				string $layers[] = `listConnections -type renderLayer $sets[$i]`;

				if (size($objs) == 0 && size($layers) == 0) 
				{
					//	empty shading group
					//
					$numDeleted += deleteIfNotReferenced( $sets[$i] );
				} 
				else 
				{
					//	check to make sure at least one shader is connected
					//	to the group
					//	
					int $connected = false;
					for($shader in $shaders)
					{
						if( size(`listConnections ($sets[$i] + $shader)`)>0 )
						{
							$connected = true;
							break;
						}
					}
					if( !$connected ) {
						$numDeleted += deleteIfNotReferenced( $sets[$i] );
					}
				}
			}
		}
		clear $objs;
	}

	//	finalize progress bar for stage 1 if required
	//
	if( $showProgress )
	{
		cleanUp_EndProgress();
	}

	//	if stage 1 was interrupted, skip all subsequent stages
	//
	if( $interrupted )
	{
		return $numDeleted;
	}

	//
	//	End stage 1.
	//-------------------------------------------------------------------

	//------------------------------------------------------------------------
	//	Stage 2: Delete all material nodes (surface, volume, displacement shaders)
	//			 whose outputs are not connected to anything.  Output connections
	//			 from message attributes must be considered specially, since they
	//			 may be irrelevant (like the connection from shader.message to
	//			 defaultMaterialList, for example).  Such connections do not indicate
	//			 that the node is in use.
	//
	//			 Note that this stage will delete shaders that were feeding into empty
	//			 shading groups.  Stage 1 deleted the shadingEngine node for empty shading
	//			 groups, which leaves unconnected the materials that were feeding into it.
	//			 These materials will now be deleted in this stage.  In the next stage, any
	//			 textures/utilities that were feeding into these materials will also be
	//			 deleted.
	//

	// Delete all unconnected materials.
	int $shouldDelete = false;
	int $count2;
	string $materials[] = `ls -long -mat`;
	string $se[];
	string $conn[];
	$count = `size($materials)`;

	//	Initialize progress bar for stage 2 if required.
	//
	if( $showProgress )
	{
		cleanUp_StartProgress( $count, "Rendering Nodes: Deleting unconnected materials", 1 );
	}

	for ($i = 0; $i < $count; $i++) 
	{

		//	check for user interrupt if required.
		//
		if( $showProgress )
		{
			if( cleanUp_SetProgress( $i ) )
			{
				$interrupted = 1;
				break;
			}
		}

		// Now determine if the readOnly connections are done.
		string $currShader = $materials[$i];

		$conn = `listConnections -shapes true -connections true -source false $currShader`;
		// conn is an array of plug/connection pairs 
		$count2 = `size($conn)`;
		for ($j = 0; $j < $count2; $j+=2) {
			clear $se;
			if ($conn[$j] != ($currShader + ".message")) {
				$shouldDelete = false;
				break;
			} else {
				// must explicitly check for a shading engine connection on message
				$se = `listConnections -type shadingEngine ($conn[$j])`;
				if (size($se) != 0) {				
					$shouldDelete = false;
					break;
				} else if ( `isClassified $conn[$j+1] "rendernode/mentalray"`) {
					// for mental ray shaders,
					// even material shader can be connected to non-SG
					// for ex,
					// dgs_material1.message ---> mib_bump_map2.color
					// is a valid shading network,
					// and should not be deleted, 
					// only because dgs_material is not connected to SG directly.
					$shouldDelete = false;
					break;
				} else if ( `isClassified $conn[$j] "rendernode/mentalray"` ) {
					// env shader and volum shader
					// can be connected to camera.
					string $shapes[];
					clear $shapes;
					$shapes = `listConnections -type shape -source false ($conn[$j])`;
					if( size($shapes) !=0 ) {
						$shouldDelete = false;
						break;
					}
				} else {
					$shouldDelete = true;
				}
			}
		}

		if ($shouldDelete) {
			//$numDeleted += deleteIfNotReferenced( $currShader );
			//disabled so that unused shaders are not deleted shaders
		}
			
		$shouldDelete = false;
		clear $conn;
		clear $se;
	}

	//	finalize progress for stage 2 if required.
	//
	if( $showProgress )
	{
		cleanUp_EndProgress();
	}

	//	if interrupted, don't continue to stage 3.
	//
	if( $interrupted )
	{
		return $numDeleted;
	}

	//--------------------------------------------------------------------------
	//
	//	Stage 3: delete all unused texture/utility nodes.  Nodes are unused if 
	//			 they have no relevant output connections.  The algorithm proceeds
	//			 iteratively.  Each iteration considers all shading nodes, and deletes
	//			 the ones with no relevant outputs.  Thus, the iterations will proceed
	//			 through each unused shading network by depth.  We stop iterating when
	//			 the previous iteration did not delete anything.
	//

	int $deleteAnything = true;
	int $oldSizeAll = 0;
	string $all[];
	string $conn[];
	string $type,$node,$connType,$attrName;

	int $it = 0;

	while ($deleteAnything) 
	{
		$it++;
		$deleteAnything = false;

		//	the "getRenderNodes" operation can take a few seconds to run on large scenes.  For this reason,
		//	we give it its own progress bar update that is not interruptable.  We want users to know
		//	what's going on.	
		//

		//	initialize progress bar for listing of rendering nodes
		//
		if( $showProgress )
		{
			cleanUp_StartProgress( -1, ("Rendering Nodes: finding texture/utility nodes (iteration " + $it + ")"), 0 );
		}

		$all = getRenderNodes();

		//	finalize progress bar for listing of rendering nodes
		//
		if( $showProgress )
		{
			cleanUp_EndProgress();
		}

		$count = size($all);

		//	initialize progress bar for deletion of unused rendering nodes.
		//
		if( $showProgress )
		{
			cleanUp_StartProgress( $count, ("Rendering Nodes: deleting unused texture/utility nodes (iteration " + $it + ")"), 1 );
		}

		//	check to see if the previous iteration removed any nodes.  If not, then we are done.
		//
		if($oldSizeAll != $count) 
		{
			for( $i = 0; $i < $count; $i++ )
			{
				$node = $all[$i];

				//	update progress, if required
				//
				if( $showProgress )
				{
					if( cleanUp_SetProgress( $i ) )
					{
						$interrupted = 1;
						break;
					}
				}

				// Deleting one node can delete other connected nodes.
				if (!`objExists $node`)
				    continue;

				$type = `nodeType $node`;

				// A heightField might not have any output connections, so
				// look for an input connection before treating it as
				// just a regular utility node...
				//
				if( $type == "heightField" ) 
				{
					$conn = `listConnections -connections true 
						-source true -shapes true $node`;
					if( size( $conn ) != 0 ) 
					{
						continue;
					}
				}

                // It's a texture, postprocess or utility node.
                // Now determine if the readable connections are done.
                $shouldDelete = true;

				//	decide whether or not the node is unused
				//
                $conn = `listConnections -connections true -source false -shapes true $node`;
                int $connCount = size($conn);
                for ($j = 0; $j < $connCount; $j+=2) 
				{
                    $attrName = match (".message",$conn[$j]);
                    if ($attrName == ".message") 
					{
                        // must explicitly check for the following
                        // destinations on a message attribute:
                        // shading engine, arrayMapper, or a
                        // camera in the case of imagePlane or
                        // cameraView
                        // <directional/spot/point>Light for mental ray light shader
                        // transform for mental ray geometry shader
                        // mentalrayOptions for mental ray contour shader
                        $connType = `nodeType $conn[$j+1]`;
                        if ($connType == "shadingEngine"
                        ||  $connType == "camera"
                        ||  $connType == "imagePlane"
                        ||  $connType == "arrayMapper"
                        ||  $connType == "directionalLight"
                        ||  $connType == "spotLight"
                        ||  $connType == "pointLight"
                        ||  $connType == "transform"
                        ||  $connType == "mentalrayOptions"
                        ||  ($type == "mentalrayTexture" && $connType != "mentalrayGlobals")                       
                         )
                        {
                            $shouldDelete = false;
                        }
                        else if( `isClassified $conn[$j+1] "rendernode/mentalray"`) {
                            $shouldDelete = false;
                        }

                        if (!$shouldDelete)
                            break;
                    }
                    else {
                        $shouldDelete = false;
                        break;
                    }
                } // foreach destination connection
                if ($shouldDelete) 
				{
					$numDeleted += deleteIfNotReferenced( $node );
					$deleteAnything = true;
				}

			$shouldDelete = false;
			} // foreach dependency node
			$oldSizeAll = $count;
		}
        else 
		{
			$deleteAnything = false;
		}

		//	update progress if required. 
		//
		if( $showProgress )
		{
			cleanUp_EndProgress();
		}

		if( $interrupted )
		{
			break;
		}
	}

	//	finalize progress bar for stage 3.
	//
	if( $showProgress )
	{
		cleanUp_EndProgress();
	}

	return $numDeleted;
}


global proc boltWheelFileValidation()
{
	global string $gBoltWarnings;

	//check for spare wheel file
	
	int $layout = `boltGetVehicleLayout`;
	string $wheelList[] = {"WHEEL_FL","WHEEL_FR","WHEEL_BL","WHEEL_BR"};
	if ($layout==2) $wheelList = {"WHEEL_F","WHEEL_B"};
	
	for ($wheel in $wheelList)
	{	
		if (!`objExists $wheel`)
		{
			$msg = ("\n" + $wheel + " not found. This SWP00 wheel must be present in the scene!");
			print $msg; 
			$gBoltWarnings += $msg;
		}
	}
	//check that all SWP00 wheels are present in the scene
	
	
	string $wheels[] = `ls -transforms "WHEEL_*"`;
	for ($wheel in $wheels)
	{
		int $lod = `boltGetLodNumber $wheel`;
		
		int $maxPolys = 0;
		
		if (`gmatch $wheel "WHEEL_F*"`) 
			$maxPolys = `boltGetDefaultWheelPolyCountFront ("_LOD"+$lod)`;
		if (`gmatch $wheel "WHEEL_B*"`) 
			$maxPolys = `boltGetDefaultWheelPolyCount ("_LOD"+$lod)`;
			
		int $polyCount = `boltPolyCount $wheel`;
		
		if ($polyCount > $maxPolys)
		{
			$msg = ("\n" + $wheel + " poly count too high (" + $polyCount + "). Should be below " + $maxPolys + ".");
			print $msg;
			$gBoltWarnings += $msg;
		}
	}
	//check polygon counts of all wheels

	string $shapes[] = `ls -type "mesh"`;
	
	for ($shape in $shapes)
	{
		if (!`gmatch $shape "WHEEL_*"`)
		{
			$msg = ("\n" + $shape + " not a recognised part name. Only shapes named \"WHEEL_*\" are permitted in this file!");
			print $msg;
			$gBoltWarnings += $msg;
		}
	}
	//check for objects that are not wheels
}

global proc boltCheckSteeringAngle()
//warns if steering wheel is at wrong angle.
{
	global string $gBoltWarnings;
	
	if (`objExists "STEERING_WHEEL"`)
	{
		float $correctAngle[] = {15.0,0,0}; 
		float $angle[] = `getAttr "STEERING_WHEEL.r"`;
		
		if (!`equivalentTol $correctAngle[0] $angle[0] 0.001`)
		{
			$msg = ("\nSTEERING_WHEEL x-angle wrong (" + $angle[0] + ")- should be " + $correctAngle[0] + ". Ensure that wheel and its rotation axis are tilted back at 15 degrees, with the z-axis points into the steering column");
			print $msg; $gBoltWarnings += $msg;
		}
		if (!`equivalentTol $correctAngle[1] $angle[1] 0.001`)
		{
			$msg = ("\nSTEERING_WHEEL y-angle wrong (" + $angle[1] + ")- should be " + $correctAngle[1] + ". Ensure that wheel and its rotation axis are tilted back at 15 degrees, with the z-axis points into the steering column");
			print $msg; $gBoltWarnings += $msg;
		}
		if (!`equivalentTol $correctAngle[2] $angle[2] 0.001`)
		{
			$msg = ("\nSTEERING_WHEEL z-angle wrong (" + $angle[2] + ")- should be " + $correctAngle[2] + ". Ensure that wheel and its rotation axis are tilted back at 15 degrees, with the z-axis points into the steering column");
			print $msg; $gBoltWarnings += $msg;
		}
	}
}


global proc boltCheckShaders()
//does various checks to check shaders are present and correct
{
	global string $gBoltWarnings;
	
	string $shapes[] = `ls -type "mesh"`;
	string $objs[] = `boltShapesToTransformsNoPath $shapes`;
	string $lambertObjs[] = `ls -transforms "CRUMPLEZONE_*" "SAFETYZONE_*" "RAGDOLL_*" "BODY*_COL" "*_OCC"`;

	
	//warn about non preset materials
	string $shaders[] = `ls -materials`;
	for ($shader in $shaders)
	{
		if (`nodeType $shader` == "ATGMaterial")
		{
			string $path = `getAttr ($shader + ".RawPath")`;
			if ( (`endsWith $path ".xml"` == 0) || ( `getAttr ($shader + ".SelectMode")` == 1 ) )
			{
				$msg = ("\nShader " + $shader + " is not a preset from the material library.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
		
	}
		
	if ( (!objExists("body_livery_carbon_damage")) && (!objExists("body_livery_metal_damage")) && (!objExists("body_livery_carbon")) && (!objExists("body_livery_metal")) )
	{
		$msg = ("\nCould not find a correctly named livery shader in the scene - there should be 'body_livery_carbon_damage' and/or 'body_livery_metal_damage' for livery system to function.");
		print $msg; $gBoltWarnings += $msg;
	}
	
	for ($obj in $objs)
	{
		if (`gmatch $obj "*_DAM"`) continue; //ignore damage objects
		
		print ("\nChecking shaders on: " + $obj);
		
		string $shaders[] = `boltGetMaterialsOnObj $obj`;
		
		for ($shader in $shaders)
		{
			//warn about SGs not linked to any shader
			if ($shader == "")
			{
				$msg = ("\nA shading group with no shader is applied to " + $obj);
				print $msg; $gBoltWarnings += $msg;
			}
			else if (`nodeType $shader` != "ATGMaterial")
			{
				if (`sFindItem $lambertObjs $obj` == -1)
				{
					$msg = ("\nShader " + $shader + " found on object " + $obj + " is not an ATG Material");
					print $msg; $gBoltWarnings += $msg;
				}
			}
			//will warn about lamberts or non atg shaders assigned to objects.
			//except for exempt objects in $lambertObjs
			
		}
				
		int $polysWithoutSGs = 0;
		int $polysWithSGs = 0;
		string $nonATG[] = {};
		string $problemPolys = "";
		
		int $noPolys[] = `polyEvaluate -face $obj`;
		for ($i=0; $i<$noPolys[0]; $i++)
		//go through all polys
		{
			string $poly = ($obj + ".f[" + $i + "]");
			string $sg = `boltGetFacetSG $poly`;
			if ($sg == "") 
			{
				$polysWithoutSGs += 1;
				$problemPolys = ($problemPolys + " " + $poly);
			}
			else
			{
				$polysWithSGs += 1;
			}

		}
		
		//polys with and without SGs found
		if (($polysWithoutSGs>0) && ($polysWithSGs>0))
		{
			//warn about polys with no shading group assigned.
			$msg = ("\nUnshaded polygons found on " + $obj);
			print $msg; $gBoltWarnings += $msg;
			print ("\nAffected polys: " + $problemPolys);
		}
		
		//if only polys without SGs found
		if (($polysWithoutSGs>0) && ($polysWithSGs==0))
		{
			string $shapes[] = `listRelatives -type "mesh" -children $obj`;
			if (size(`getSGsFromShape $shapes[0]`) == 0)
			{
				$msg = ("\nNo shading groups found on " + $obj);
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	
	boltSCV.checkDiskShaders();
	
	boltSCV.checkAlbedoValues();
		
	print "\nShader error checks complete.";
}



global proc boltCheckLockedNormals()
//reports any shapes in the scene with locked normals
{
	global string $gBoltWarnings;
	
	string $shapes[] = `ls -type "mesh"`;
	for ($shape in $shapes)
	{
		if ((`gmatch $shape "*_SHADOW*"`==0)
			&&(`gmatch $shape "*_LOD4*"`==0)
			&&(`gmatch $shape "*_LOD5*"`==0)
			&&(`gmatch $shape "*_LOD6*"`==0))
		{
			if (boltCheckForBlackLockedNormals($shape)==1)
			{
				$msg = ("\n" + $shape + " has vertex normals locked in the opposite direction to its face normals. This will cause black geometry.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
}



/////////////////repath procs added to BPT as they were disabled in evo tools////////////////

global proc string boltGetNewMPath(string $filePath)
//converts a given path to an m based path. Works on ms1 paths or branched paths depending on flag.
{
	int $stringSize = `size $filePath`;
	print ("\nOld Path: " + $filePath);
					
	string $newPath = "M:";
			
	string $buffer[];
	$numTokens = `tokenize $filePath "/" $buffer`;	
	//splits the path into list of folders
	
	int $branchIndex = `sFindItem $buffer "branches"`;
	if ($branchIndex < 0) $branchIndex = `sFindItem $buffer "Branches"`;
	if ($branchIndex < 0) return $filePath; // quit if branch path not found
	//find out where the "branches" part of the path starts
	
	for ($j=$branchIndex+3 ; $j<$numTokens ; $j++)
	{		
		$newPath = $newPath + "/" + $buffer[$j];
	}
	//builds the new m: based path
	
	print ("\nNew Path: " + $newPath +"\n");
	return $newPath;
}


global proc boltRepathTextures()
{
	
	//Care needs to be taken for References?
	
	string $allFiles[] = `ls -et file`;
	int $sizeAllFiles = `size $allFiles`;
	for ($i=0;$i<$sizeAllFiles;$i++)
	{
		string $filePath = `getAttr ($allFiles[$i]+".fileTextureName")`;
				
		// If the shader isn't loaded from M then strip motorstorm etc.
		int $mDriveQuery = startsWith($filePath, "M:");
		int $branchedQuery = 0;
		if (`gmatch $filePath "*/branches/*"` == 1) $branchedQuery = 1; //check if the file is in a "branches" folder
		if (`gmatch $filePath "*/Branches/*"` == 1) $branchedQuery = 1; //check if the file is in a "branches" folder
		if ($mDriveQuery == 0 && $branchedQuery == 1)
		{
			string $newPath = `boltGetNewMPath $filePath`;
			setAttr -type "string" ($allFiles[$i]+".fileTextureName") $newPath;
		}
	}
	
		print "\nTextures repathed to M:";
	
}
/////////////////repath procs added to BPT as they were disabled in evo tools////////////////


/////added to remove dependancy on evo tools
global proc miloDelVoidShaderGRPConns2()
{
	// List all shading groups
	string $miloShadingGroups[] = `ls -fl -et shadingEngine`;
	int $numBreakages; //Count the breaks!
	
	int $amount = 0;
       
       progressWindow
           -title "Breaking Connections"
           -progress $amount
           -status "Shader GRP#:"
           -isInterruptable true;	

	for ($i=0;$i<`size $miloShadingGroups`;$i++)
	{
		progressWindow -edit 
		-max `size $miloShadingGroups`
		-status ("Shader GRP#: "+$amount);
		
		// For each shading group list all the shapes it's attached to
		string $miloShapeList[] = `listConnections -sh 1 -t shape $miloShadingGroups[$i]`;
		
		// Remove Duplicate Shapes from the list
		string $shorterList[] = stringArrayRemoveDuplicates($miloShapeList);
		string $miloShapeList[] = $shorterList;
		
		//print ("\n"+$miloShapeList[$i]+" Checking against SG: "+$miloShadingGroups[$i]);
		
		//print "\n";
		int $miloKeepConnect;
		// For each shape in the list check whether it is a member of the group
		for ($j=0;$j<`size $miloShapeList`;$j++)
		{
			$miloKeepConnect = 1;
			// List all the faces the shading group holds
			string $faces[]=`sets -q -no $miloShadingGroups[$i]`;		
			
			//print ("\n\n Objects Using Shading Group: ");print $faces;
			
			// For each set of faces check if the shape is a member
			for ($k=0;$k<`size $faces`;$k++)
			{
				/*
				if (`gmatch $faces[$k]($miloShapeList[$j])`==0)
				{
					//print $faces[$k];
					print("\n"+$k+" DISCONNECT "+$miloShapeList[$j]+" FROM "+$miloShadingGroups[$i]);
				}
				*/
				if (`gmatch $faces[$k]($miloShapeList[$j])`==1)
				{
					//print $faces[$k];
					//print("\n"+$k+" KEEP-CONNECTION "+$miloShapeList[$j]+" TO "+$miloShadingGroups[$i]);
					$miloKeepConnect=0;
				}
			}
			//print ("\nBREAK = "+$miloKeepConnect+"\n");
			
				if ($miloKeepConnect==1) // Remove connections between the shape and shade group based on which failed
				{
					//List Connections between objects
					string $breakPointlessConnections[] = `listConnections -p 1 -sh 1 -c 1 $miloShadingGroups[$i]`;
					for ($m=0;$m<`size $breakPointlessConnections`;$m++)
					{
						if (`gmatch $breakPointlessConnections[$m] ($miloShapeList[$j]+".*")`==1)
						{
							//print ("\nBreaking "+ $breakPointlessConnections[$m] + " & " + $miloShapeList[$j]);
							
							// Check whether plug is source or destination?
							// Find Corresponding source or destination
							if (`connectionInfo -id $breakPointlessConnections[$m]` == 0)
							{
								string $miloPlug[] = `connectionInfo -dfs $breakPointlessConnections[$m]`;
								// Disconnect
								disconnectAttr $breakPointlessConnections[$m] $miloPlug[0];
								print ("\nBroken "+ $miloPlug[0] + " & " + $breakPointlessConnections[$m]);
								$numBreakages++;
							}
							if (`connectionInfo -id $breakPointlessConnections[$m]` == 1)
							{
								$miloPlug = `connectionInfo -sfd $breakPointlessConnections[$m]`;
								// Disconnect
								disconnectAttr $miloPlug $breakPointlessConnections[$m];
								print ("\nBroken "+ $breakPointlessConnections[$m] + " & " + $miloPlug);
								$numBreakages++;
							}
						if ( `progressWindow -query -isCancelled` ) break;
						}
					if ( `progressWindow -query -isCancelled` ) break;
					}
				if ( `progressWindow -query -isCancelled` ) break;
				}
		if ( `progressWindow -query -isCancelled` ) break;
		}
	if ( `progressWindow -query -isCancelled` ) break;
	if ( `progressWindow -query -progress` >= `size $miloShadingGroups` ) break;		
	$amount += 1;
	progressWindow -edit 
	-step 1;
	}
	print "\n";
	string $warningMessage = ("Broke "+$numBreakages+" Pointless Shader Connections.");
	warning $warningMessage;
	progressWindow -endProgress;

	// Delete any groupId nodes that are not connected via groupId
	string $groupIds[] = `ls -fl -et "groupId"`;
	int $groupIdDels=0;
	for ($i=0;$i<`size $groupIds`;$i++)
	{
		if(`objExists $groupIds[$i]`)
		{
			int $usefulNode = `connectionInfo -is ($groupIds[$i]+".groupId")`;
			if ($usefulNode == 0)
			{
				if (`reference -isNodeReferenced $groupIds[$i]` == 0)
				//prevents crash on wheel refs
				{
					delete $groupIds[$i];
					$groupIdDels++;
				}
			}
		}
	}
	
	print ("\n"+$groupIdDels+" Redundant groupId Nodes Deleted");
	
	string $groupParts[] = `ls -fl -et "groupParts"`;
	int $groupPartDels=0;
	for ($i=0;$i<`size $groupParts`;$i++)
	{
		if(`objExists $groupParts[$i]`)
		{
			string $usefulNode[] = `listConnections $groupParts[$i]`;
			if (`size $usefulNode` == 0)
			{
				delete $groupParts[$i];
				$groupPartDels++;
			}
			clear $usefulNode;
		}
	}
	
	print ("\n"+$groupPartDels+" Redundant groupParts Nodes Deleted\n");
}





global proc boltEdgeLengthValidatorCheck()
//validator check reports on polygon size of each lod in the scene
{
	global string $gBoltWarnings;
	string $objs[] = `ls -transforms`;
	
	int $sEdges[] = {0,0,0,0,0,0,0}; //counts small edges per lod
	
	for ($obj in $objs)
	{
		string $partInfo[] = boltWhatIsPart($obj);
		for ($i=0; $i<=6; $i++)
		{
			if (`sFindItem $partInfo ("_LOD"+$i)` != -1) $sEdges[$i] = $sEdges[$i] + size(boltGetEdgesTooShortForLod($obj));
		}
	}
	
	for ($i=0; $i<=6; $i++)
	{
		if ( $sEdges[$i] > 0 )
		{
			$msg = ("\n" + $sEdges[$i] + " sub-pixel-length edges found on LOD" + $i + ". The resulting small polys are not likely to be visible, and are bad for performance. Use 'Lod Tools>Get Short Edges' to highlight");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
}




global proc boltVehicleBatch(int $from, int $to)
{
	string $vehicles[] = {"ATV_03","ATV_06","ATV_24", 
						"BIGRIG_40","BIGRIG_41","BIGRIG_42","BIGRIG_44","BIGRIG_45",
						"BIKE_01","BIKE_03","BIKE_04",
						"BUGGY_02","BUGGY_40","BUGGY_41","BUGGY_42",
						"CHOPPER_40","CHOPPER_41","CHOPPER_42","CHOPPER_43",
						"MINI_40","MINI_41","MINI_42","MINI_43","MINI_44","MINI_45",
						"MONSTER_23","MONSTER_27","MONSTER_40","MONSTER_41",
						"MUDPLUGGER_01","MUDPLUGGER_40","MUDPLUGGER_41","MUDPLUGGER_42","MUDPLUGGER_43",
						"MUSCLECAR_01","MUSCLECAR_40","MUSCLECAR_41","MUSCLECAR_42","MUSCLECAR_43",
						"RACETRUCK_03","RACETRUCK_40","RACETRUCK_41","RACETRUCK_42",
						"RALLYCAR_40","RALLYCAR_41","RALLYCAR_42","RALLYCAR_43",
						"SUPERBIKE_40","SUPERBIKE_41","SUPERBIKE_42","SUPERBIKE_43",
						"SUPERCAR_40","SUPERCAR_41","SUPERCAR_42","SUPERCAR_43","SUPERCAR_44","SUPERCAR_45","SUPERCAR_46"};
						
	for ($v=$from; $v<=$to; $v++)
	{
		print ("\nProcessing " + $vehicles[$v] + "(vehicle no: " + $v +")....");
		
		string $file = ("M:/art/vehicles/" + $vehicles[$v] + "/MAYA/" + $vehicles[$v] + ".mb");
		file -open -force $file;
		
		
		
		///////////////////////////////////////////////////////////////////////////
		//do stuff to file
		
		/*
		string $origBoost[] = `ls -type "ATGMaterial" "*boost*"`;
		if (size($origBoost) != 1) error "wrong no of boost shaders found!!!";
		
		$matName = "boost";
		string $shaderNode = `shadingNode -asShader ATGMaterial -name $matName`;                                                                 
		setAttr ($shaderNode + ".SelectMode") 0;                                                        
		setAttr -type "string" ($shaderNode + ".RawPath") "m:/assets/noodle/materials/library/vehicles/boost.xml";
		$shadingGroup = `sets -renderable true -noSurfaceShader true -empty -name ($shaderNode+"SG")`;
		connectAttr -f ($shaderNode+".outColor") ($shadingGroup+".surfaceShader");
		//add a shading group
	
		Replaceshader2($origBoost[0], $shaderNode);
		delete $origBoost[0];
		*/
	
		
		///////////////////////////////////////////////////////////////////////////
		
		
		//check out and save maya file save
		//string $filePath = `file -q -sceneName`;
		//system ("p4 sync " + boltConvertFromMPath($filePath));
		//system ("p4 edit " + boltConvertFromMPath($filePath));
		//catchQuiet(`file -force -save -type "mayaBinary"`);
		
		playbackOptions -min 0 -max 1;
				
		boltExportSwapIntermediates;

	}
	
	print "\nAll files processed!";
}



global proc boltCheckForDuplicateNodeNames()
{
	global string $gBoltWarnings;
	
	string $objs[] = stringArrayCatenate(`ls -long -type "mesh"`,`ls -long -type "transform"`);

	for ($i=0; $i<size($objs); $i++)
	{
		for ($j=($i+1); $j<size($objs); $j++)
		{
			if (`match "[^|]*$" $objs[$i]` == `match "[^|]*$" $objs[$j]`)
			{
				string $msg = ("\n" + $objs[$i] + " has the same name as " + $objs[$j] + ". This will cause problems with Maya tools and in game.");
				print $msg; $gBoltWarnings += $msg;
			}
			
		}
	}
}


global proc boltSmoothColours(string $obj)
//averages vertexface colours into one per vert.
{
	//fix a bug that crashes validator if no colour set found on shadow proxy.
	string $colorSets[] = `polyColorSet -q -allColorSets $obj`;
	if (size($colorSets) == 0) return;
	
	int $vertCounts[] = `polyEvaluate -vertex $obj`;
	int $vertCount = $vertCounts[0];
	//get num of verts
	
	for ( $v = 0; $v < $vertCount; $v++ )
	//for each vert
	{
		//find vertex faces
					
		string $faces[] = `polyListComponentConversion -toFace ($obj + ".vtx[" + $v +"]")`;
		$faces = `ls -flatten $faces`;
		// Faces associated with vertex
		
		string $vertFaces[] = {};
					
		for ( $f = 0; $f < size($faces); $f++ )
		{
			$faceNum = `match "[^\.]*$" $faces[$f]`;
			$faceNum = `match "[0-9]+" $faceNum`;
			//strip face names back to face numbers			
			$vertFaces[$f] = ($obj + ".vtxFace[" + $v + "][" + $faceNum + "]");				
		}
		// get list of vertex faces.
		
		
		
		float $vfR[] = {};
		float $vfG[] = {};
		float $vfB[] = {};
		float $vfA[] = {};
				
		for ($vf in $vertFaces)
		{
			float $temp[] = `polyColorPerVertex -q -r -g -b -a $vf`;
			$vfR[size($vfR)] = $temp[0];
			$vfG[size($vfG)] = $temp[1];
			$vfB[size($vfB)] = $temp[2];
			$vfA[size($vfA)] = $temp[3];
		}
		//store vertex face colours
		
		
		if ( size($vfR) > 0 ) //avoids divide by zero if no cols
		{
		
			float $average[] = {0.0,0.0,0.0,0.0};
					
			for ($i=0; $i<size($vfR); $i++)
			{
				$average[0] += $vfR[$i];
				$average[1] += $vfG[$i];
				$average[2] += $vfB[$i];
				$average[3] += $vfA[$i];
			}
		
			for ($i=0; $i<size($average); $i++)
			{
				$average[$i] = ( $average[$i]/size($vfR) );
			}
			//average colours
		
		
			polyColorPerVertex -notUndoable -r $average[0] -g $average[1] -b $average[2] -a $average[3] ($obj + ".vtx[" + $v +"]");
			//reapply averaged colours
		}
	}
	
}


global proc boltOptimiseLowLods()
//optimises vertex/uv/colour counts on low lods
{
	string $objs[] = `ls -transforms "*_LOD6"`;
	for ($obj in $objs)
	{	
		print ("\nOptimising " + $obj);
		polyMergeVertex  -d 0.1 $obj;
		delete -constructionHistory $obj;
		//polyMergeUV -d 0.3 $obj;
		boltSmoothColours $obj;
		polyAverageNormal $obj; 
		delete -constructionHistory $obj;
	}
	
	/*
	string $objs[] = `ls -transforms "*_LOD5"`;
	for ($obj in $objs)
	{	
		print ("\nOptimising " + $obj);
		polyMergeVertex  -d 0.02 $obj;
		delete -constructionHistory $obj;
		polyMergeUV -d 0.3 $obj;
		boltSmoothColours $obj;
		polyAverageNormal $obj; 
		delete -constructionHistory $obj;
	}

	string $objs[] = `ls -transforms "*_LOD4"`;
	for ($obj in $objs)
	{	
		print ("\nOptimising " + $obj);
		polyMergeVertex  -d 0.01 $obj;
		delete -constructionHistory $obj;
		polyMergeUV -d 0.2 $obj;
		boltSmoothColours $obj;
		polyAverageNormal $obj; 
		delete -constructionHistory $obj;
	}
	*/
	
	string $objs[] = `ls -transforms "*_SHADOW"`;
	for ($obj in $objs)
	{	
		print ("\nOptimising " + $obj);
		polyMergeVertex  -d 0.0005 $obj; // 0.5mm
		delete -constructionHistory $obj;
		polyMergeUV -d 0.2 $obj;
		boltSmoothColours $obj;
		polyAverageNormal $obj; 
		delete -constructionHistory $obj;
	}
	
}


global proc boltCheckForTinyPlaceholders()
//checks for very small meshes that can cause physics to crash
// currently looks for anything less than 10x10x10cm
{
	global string $gBoltWarnings;
	
	string $objs[] = `ls -type "mesh"`;

	for ($obj in $objs)
	{
		float $bb[] = `polyEvaluate -b $obj`;
		float $size[] = { ($bb[1]-$bb[0]) , ($bb[3]-$bb[2]) , ($bb[5]-$bb[4]) };
	
		if ( ($size[0]<0.1) && ($size[1]<0.1) && ($size[2]<0.1) )
		{
			string $msg = ("\n" + $obj + " is very small - if this is a placeholder or physics part then it may cause the game to crash. \n   Placeholders should be full sized boxes generated using 'Swap Tools > +Placeholder Box'");
			print $msg; $gBoltWarnings += $msg;
		}
	}
}


global proc boltCheckMaterialsOnCollision()
//warns if any collsion objects use wrong shader 
{
	global string $gBoltWarnings;
	
	string $cols[] = boltShapesToTransforms(`ls -type "mesh" "*_COLShape*"`); 
	for ($col in $cols)
	{
		string $materials[] = boltGetMaterialsOnObj($col);
		if ( (size($materials) != 1) || ($materials[0] != "lambert1") )
		{
			string $msg = ("\n" + $col + " has wrong shaders applied to it. Found:");
			for ($m in $materials) $msg += (" " + $m);
			$msg += " - should just be lambert1";
			print $msg; $gBoltWarnings += $msg;
		}
	}
}


global proc boltCheckColourSetNames()
//warns if any colour sets have the wrong name, wrong number of sets etc 
{
	global string $gBoltWarnings;
	
	string $objs[] = boltShapesToTransforms(`ls -type "mesh"`); 
	string $cols[] = boltShapesToTransforms(`ls -type "mesh" "*_COL*"`); 
	string $dams[] = boltShapesToTransforms(`ls -type "mesh" "*ZONE_*"`); 
	string $occs[] = boltShapesToTransforms(`ls -type "mesh" "*_OCC*"`); 
	
	$objs = stringArrayRemove($cols,$objs);
	$objs = stringArrayRemove($dams,$objs);
	$objs = stringArrayRemove($occs,$objs);
	$objs = stringArrayRemove({"|ENV_CUBE"},$objs);
	
	for ($obj in $objs)
	{
		if (`gmatch $obj "*_DAM"`) continue; //don't check colours on damage objects
		
		string $colourSets[] = `polyColorSet -q -allColorSets $obj`;
		
		if (size($colourSets) == 0)
		{
			string $msg = ("\nColourset Error - " + $obj + " has no colour set applied to it.");
			print $msg; $gBoltWarnings += $msg;
		}
		
		if (size($colourSets) == 1)
		{
			if ($colourSets[0] != "colorSet1")
			{
				string $msg = ("\nColourset Error - " + $obj + " has incorrectly named colour set - should be 'colorSet1'. Found '" + $colourSets[0] + "'.");
				print $msg; $gBoltWarnings += $msg;
			}
		}	
		
		if (size($colourSets) > 1)
		{	
			string $wrongSets[] = {};
			string $okSets[] = {"colorSet1", "damageLookup_colorSet", "damageVector_colorSet"};
			
			for ($c in $colourSets) 
			{
				if (sFindItem($okSets, $c) == -1)
				{
					$wrongSets[size($wrongSets)] = $c;
				}
			}
			
			if (size($wrongSets) > 0)
			{
				string $msg = ("\nColourset Error - " + $obj + " has unrecognised colour sets applied to it (");
				for ($c in $wrongSets) $msg += (" " + $c);
				$msg += " ) - should just be colorSet1, damageLookup_colorSet, and damageVector_colorSet";
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	
	//don't worry about damage on boost geometry...
	string $boost[] = boltShapesToTransforms(`ls -type "mesh" "*BOOST_*"`);
	$objs = stringArrayRemove($boost,$objs);
	
	for ($obj in $objs)
	{
		if (`gmatch $obj "*_DAM"`) continue; //don't check colours on damage objects
		string $colourSets[] = `polyColorSet -q -allColorSets $obj`;
		
		if (sFindItem($colourSets, "damageLookup_colorSet") == -1)
		{
			string $msg = ("\nColourset Error - " + $obj + " has no 'damageLookup_colorSet' - build will fail unless damage colours are added.");
			print $msg; $gBoltWarnings += $msg;
		}
		if (sFindItem($colourSets, "damageVector_colorSet") == -1)
		{
			string $msg = ("\nColourset Error - " + $obj + " has no 'damageVector_colorSet' - build will fail unless damage colours are added.");
			print $msg; $gBoltWarnings += $msg;
		}
		
	}
}


global proc boltCheckUVSetNames()
//warns if any uv sets have the wrong name, wrong number of sets etc 
{
	global string $gBoltWarnings;
	
	string $objs[] = boltShapesToTransforms(`ls -type "mesh"`); 
	string $cols[] = boltShapesToTransforms(`ls -type "mesh" "*_COL*"`); 
	string $dams[] = boltShapesToTransforms(`ls -type "mesh" "*ZONE_*"`); 
	
	$objs = stringArrayRemove($cols,$objs);
	$objs = stringArrayRemove($dams,$objs);
	
	for ($obj in $objs)
	{
		string $uvSets[] = `polyUVSet -q -allUVSets $obj`;
		
		if (size($uvSets) == 0)
		{
			string $msg = ("\n" + $obj + " has no UV set applied to it.");
			print $msg; $gBoltWarnings += $msg;
		}
		
		if (size($uvSets) == 1)
		{
			if ($uvSets[0] != "map1")
			{
				string $msg = ("\n" + $obj + " has incorrectly named UV set - should be 'map1'. Found '" + $uvSets[0] + "'.");
				print $msg; $gBoltWarnings += $msg;
			}
		}	
		
		if (size($uvSets) > 1)
		{	
			
			string $msg = ("\n" + $obj + " has multiple uv sets applied to it. Found:");
			for ($uv in $uvSets) $msg += (" " + $uv);
			$msg += " - should just be map1";
			print $msg; $gBoltWarnings += $msg;
		}
	}
}


global proc boltCheckTextureMipSettings()
{
	string $texs[] = `ls -type "file"`;
	string $textures[] = {};
	
	for ($tex in $texs)
	{
		string $path = `getAttr ($tex + ".fileTextureName")`;
		
		if (`gmatch $path "*/art/vehicles/*"`)
		{
			$textures[size($textures)] = $tex;
		}
	}
	//filter the list to just vehicle textures
	
	for ($tex in $textures)
	{
		string $path = `getAttr ($tex + ".fileTextureName")`;
		
		if ( (`gmatch $path "*boostNoise.dds"` == 0) &&
		       (`gmatch $path "*metallicFlake.dds"` == 0) )
		{
		
			if (getAttr(($tex + ".AtgSamplerStateLodBias")) != -1) 
			{
				setAttr(($tex + ".AtgSamplerStateLodBias"), -1);
				print ("\n" + $tex + " Lod Bias was set to -1 to prevent blury looking textures. " + $path );
			}
		
			if (getAttr(($tex + ".AtgSamplerStateMinFilter")) != 5) 
			{
				setAttr(($tex + ".AtgSamplerStateMinFilter"), 5);
				print ("\n" + $tex + " Min Filter was set to 'Linear mip-map linear' for best results. " + $path );
			}
		
		}
	}

}




global proc boltDeleteQNANs()
{
	global string $gBoltWarnings;

	print "\nChecking for infinite (QNAN) verts....";
	
	string $shapes[] = `ls -type "mesh"`;
	string $objs[] = `boltShapesToTransformsNoPath $shapes`;
		
	for ($obj in $objs)
	{
		int $verts[] = `polyEvaluate -v $obj`;
						
		for ($i=0; $i<$verts[0]; $i++)
		{
			float $pos[] = `pointPosition -l ($obj+".vtx["+$i+"]")`;
			if ( ($pos[0] == "1.#QNAN") || ($pos[1] == "1.#QNAN") || ($pos[2] == "1.#QNAN") )
			{
				select -cl; select ($obj+".vtx["+$i+"]"); DeleteVertex;
							
				int $newVerts[] = `polyEvaluate -v $obj`;
				
				if ($newVerts[0] == $verts[0])
				{
					$msg = ("\nInfinite vertex found and could not be deleted: " + $obj + ".vtx[" + $i + "]");
					print $msg; $gBoltWarnings += $msg;
				}
				else
				{
					print ("\nInfinite vertex deleted from " + $obj + ".");
					$verts = `polyEvaluate -v $obj`;
					$i = $i-1;
				}
			}
		}
	}
	
	print "\nInfinite vert check complete.";
	
}

global proc int boltCheckForBlackLockedNormals(string $obj)
//finds objects with disparity between face normals and locked vertex normals.
{
	if (boltCheckForLockedNormals($obj)==0)
	{
		return 0;
	}

	string $polys[] = `ls -fl ($obj + ".f[*]")`;

	for ($poly in $polys)
	{
		//get face normal
		string $faceNormals[] = `polyInfo -faceNormals $poly`;
		string $buffer[];
		tokenize($faceNormals[0], $buffer);
		float $x = $buffer[2];
		float $y = $buffer[3];
		float $z = $buffer[4];
		vector $faceNormal = <<$x,$y,$z>>;
		$faceNormal = `unit $faceNormal`;

		string $vfs[] = `polyListComponentConversion -fromFace -toVertexFace $poly`;
		float $vfNormals[] = `polyNormalPerVertex -q -xyz $vfs[0]`;
		float $x = $vfNormals[0];
		float $y = $vfNormals[1];
		float $z = $vfNormals[2];
		vector $vfNormal = <<$x,$y,$z>>;

		float $dot = dot($faceNormal,$vfNormal);
		if ($dot>1) $dot = 1; 
		if ($dot<-1) $dot = -1; //needed to stop floating error crashing acos 
		if ( acos($dot) > 2.5 )
		{
			return 1; //angle is bigger than 0.8pi
		}
	}
	return 0;
}


global proc boltFixCorruptObjectGUI()
{
	string $objs[] = `ls -sl -transforms`;
	for ($obj in $objs) boltFixCorruptObject($obj);
}
	
global proc boltFixCorruptObject(string $obj)
//attempts to fix broken objects by attaching to a cube, deleteing cube - works a lot of the time!
{
	boltRemoveHierarchy;
	
	float $r[] = getAttr($obj+".r");
	float $s[] = getAttr($obj+".s");
	float $t[] = getAttr($obj+".t");
	
	string $cubes[] = `polyCube -ch off -w 1 -h 1 -d 1`;
	string $cube = $cubes[0];
	
	setAttr ($cube+".r") $r[0] $r[1] $r[2];
	setAttr ($cube+".s") $s[0] $s[1] $s[2];
	setAttr ($cube+".t") $t[0] $t[1] $t[2];
	
	//apply shader	
	string $shader = "TEMP_FIX_CUBE";
	string $sg = "";
	if (objExists($shader)) delete $shader;
	$shader = `shadingNode -asShader blinn -name $shader`;
	$sg = `sets -renderable true -noSurfaceShader true -empty`;
	connectAttr -f ($shader+".outColor") ($sg+".surfaceShader");
	setAttr ($shader +".color") -type double3 0 0.8 0;
	setAttr ($shader +".transparency") -type double3 0.9 0.9 0.9;
	sets -fe $sg $cube;
	
	select -r $obj;
	select -add $cube;
	boltCombine 1;
	
	delete `sets -q $sg`;
	delete $sg;
	delete $shader;
	
	rename $cube $obj;
	
	boltRestoreHierarchy;
	
	print ($obj + " was attached to a cube. The cube was then deleted.");
}
	


global proc boltSCV.checkDiskShaders()
//checks for errors with left/right anisotropic disc shaders
{
	global string $gBoltWarnings;
	
	string $diskObjectsL[] = {"WHEEL_FL","WHEEL_BL","DISC_FL","DISC_BL"};
	string $diskObjectsR[] = {"WHEEL_FR","WHEEL_BR","DISC_FR","DISC_BR"};
	string $diskMaterialsL[] = {"disc_ceramic_01_left.xml", "anisotropic_disc_aluminium_l.xml", "anisotropic_disc_steel_l.xml"};
	string $diskMaterialsR[] = {"disc_ceramic_01_right.xml", "anisotropic_disc_aluminium_r.xml", "anisotropic_disc_steel_r.xml"};
	
	for ($obj in $diskObjectsL)
	{
		string $result = boltSCV.doesObjUseShaderPresets($obj, $diskMaterialsR);
		if ($result != "")
		{
			string $msg = ("\n" + $obj + " has right sided anisotropic shaders applied to it (" + $result + ")");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	for ($obj in $diskObjectsR)
	{
		string $result = boltSCV.doesObjUseShaderPresets($obj, $diskMaterialsL);
		if ($result != "")
		{
			string $msg = ("\n" + $obj + " has left sided anisotropic shaders applied to it (" + $result + ")");
			print $msg; $gBoltWarnings += $msg;
		}
	}
}


global proc string boltSCV.doesObjUseShaderPresets(string $obj, string $presets[])
{
	global string $gBoltWarnings;
	
	 string $return = "";
	 string $shaders[] = boltGetMaterialsOnObj($obj);
	 
	 $shaders = `ls -type "ATGMaterial" $shaders`;
	 
	 for ($shader in $shaders)
	 {
	 	$preset = `getAttr ($shader + ".RawPath")`;
	 	$preset = `basename $preset ""`;
	 	
	 	if (sFindItem($presets, $preset) != -1)
	 	{
	 		$return += $shader;
	 	}
	}
	return $return;
}


global proc boltTestLights()
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;
	
	//check lightprobe
	string $lightprobe = "BODY_COL|BODY|EXTERIOR_LIGHTPROBE";
	if (objExists($lightprobe))
	{
		string $children[] = `listRelatives -children $lightprobe`;
		
		$attrSet = `getAttr ($children[0] + ".EvoAttributeSet")`;
		
		if ($attrSet != "LocalLightProbe")
		{
			string $msg = ("\nLightprobe error - evo attribute node was not recognised as a lightprobe.");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	else
	{
		string $msg = ("\nLightprobe error - could not find lightprobe in scene (" + $lightprobe + ").");
		print $msg; $gBoltWarnings += $msg;
	}
	
	//check ao volume
	
	
	string $ao = "BODY_COL|transform1|evoamboccvollocator1";
	if (objExists($ao))
	{
		if ( (`getAttr ($ao + ".amboccvol_x_divisions")` != 32)
			|| (`getAttr ($ao + ".amboccvol_x_divisions")` != 32)
			|| (`getAttr ($ao + ".amboccvol_x_divisions")` != 32))
			{
				string $msg = ("\nAO Volume Error - wrong number of XYZ divisions - please reapply a new AO node and rebake volume texture.");
				print $msg; $gBoltWarnings += $msg;
			}
		string $aoFile = `getAttr ($ao + ".amboccvol_pre_generated_vol")`;
		if ($aoFile == "")
		{
			string $msg = ("\nAO Volume Error - No texture was found assigned to the AO node.");
			print $msg; $gBoltWarnings += $msg;
		}
		else
		{
			string $cmd = "import os; os.path.getsize('" + $aoFile + "')"; 
			string $aoSize = python($cmd);
			if ( (substring($aoSize,1,2) == "32") || (substring($aoSize,1,2) == "33") )
			{
				//size ok
			}
			else
			{
				string $msg = ("\nAO Volume Error - AO Texture was the wrong size on disk - please reapply a new AO node and rebake volume texture.");
				print $msg; $gBoltWarnings += $msg;
			}
		}
	}
	else
	{
		string $msg = ("\nAO Volume Error - could not find AO Volume in scene (" + $ao + ").");
		print $msg; $gBoltWarnings += $msg;
	}
	
	print "\nLight probes and AO volumes checked";
	
	//check vehicle lights
	string $extLights[] = {"HEADLIGHT_FL","HEADLIGHT_FR","COMBILIGHT_BL","COMBILIGHT_BR"};
	string $optionalExtLights[] = {"BRAKELIGHT_B"};
	string $interiorLights[] = {"DASHLIGHT_1","DASHLIGHT_2","DASHLIGHT_3","COURTESYLIGHT_1","COURTESYLIGHT_2","COURTESYLIGHT_3"};
	
	for ($light in $extLights) boltWarnIfNotSpotLight($light);
	for ($light in $optionalExtLights) boltWarnIfNotSpotLight($light);
	for ($light in $interiorLights) boltWarnIfNotSpotLight($light);

	for ($light in $extLights)
	{
		if (!`objExists $light`)
		{
			string $msg = ("\nSpotlight Error - " + $light + " is required in scene.");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	for ($light in $optionalExtLights)
	{
		if (!`objExists $light`)
		{
			string $msg = ("\nSpotlight Warning - Optional spotlight " + $light + " not found. Please make sure this is not needed.");
			print $msg; $gBoltWarningsLow += $msg;
		}
	}
	int $intLightsFound = 0;
	for ($light in $interiorLights)
	{
		if (`objExists $light`) $intLightsFound = 1;
	}
	if ($intLightsFound == 0)
	{
		string $msg = ("\nSpotlight Error - No interior spotlights found in the scene.");
		print $msg; $gBoltWarnings += $msg;
	}
	
	boltTestWindscreenReflections();
	boltTestWindscreenSorting();
	boltCheckLightShaderSetup();
	boltCheckMirrorSetup();
}




global proc boltTestWindscreenSorting()
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;
	
	string $windows[] = {"WINDOW_F"}; //,"WINDOW_B"}; - causing problems on Pagani Huayra
	
	
	if ( (`objExists "WINDOW_F"`) && (!(`objExists "WINDOW_F2"`)) )
	{
		string $msg = ("\nWindscreen Sorting Warning - 'WINDOW_F2' not found, this may cause sorting problems ingame for the windscreen");
		print $msg; $gBoltWarningsLow += $msg;
	}
	for ($window in $windows)
	{
		if ( (`objExists $window`) && (`objExists ($window+"2")`) )
		{
			
			boltRemoveHierarchy;
			boltMovePivotTest ($window+"2") $window <<0,0,0>>;
			boltRestoreHierarchy;
			
			string $p[] = `listRelatives -parent ($window+"2")`;
			if ($p[0] != $window) parent ($window+"2") $window;
			
			string $mats[] = boltGetMaterialsOnObj($window);
			int $found = 0;
			for ($m in $mats) if (`gmatch $m "*_inside*"`) $found = 1;
			if ($found == 0)
			{
				string $msg = ("\nWindscreen Sorting Warning - " + $window + " should have an 'inside' glass shader");
				print $msg; $gBoltWarnings += $msg;
			}
			string $mats[] = boltGetMaterialsOnObj($window+"2");
			int $found = 0;
			for ($m in $mats) if (`gmatch $m "*_outside*"`) $found = 1;
			if ($found == 0)
			{
				string $msg = ("\nWindscreen Sorting Warning - " + $window + "2 should have an 'outside' glass shader");
				print $msg; $gBoltWarnings += $msg;
			}
			
			
		}
	}
	print "\nWindscreen sorting tests complete";
}
	

global proc boltCheckMirrorSetup()
{
	global string $gBoltWarnings;
	
	int $results[] = {0,0,0};
	string $types[] = {"left", "right", "middle"};
	string $evoAttrs[] = `ls -type "evoAttributeNode"`;
	for ($ea in $evoAttrs)
	{
		string $at = `getAttr ($ea + ".EvoAttributeSet")`;
		if ( $at == "MirrorPoint")
		{
			int $type = `getAttr ($ea + ".Position")`;
			$results[$type] = $results[$type] + 1;
		}
	}
	for ($i=0; $i<2; $i++)
	{
		if ($results[$i] == 0)
		{
			string $msg = ("\nMirror Point Evo Attribute Node Error - " + $types[$i] + " mirror node was not found in scene");
			print $msg; $gBoltWarnings += $msg;
		}
		if ($results[$i] > 1)
		{
			string $msg = ("\nMirror Point Evo Attribute Node Error - " + $results[$i] + " " + $types[$i] + " mirror nodes were found in scene");
			print $msg; $gBoltWarnings += $msg;
		}
	}
}

global proc boltWarnIfNotSpotLight(string $light)
//given a transform, warns if it is not a spot light
{
	global string $gBoltWarnings;
	
	if (`objExists $light`)
	{ 
		string $children[] = `listRelatives -children $light`;
		if (`nodeType $children[0]` != "spotLight")
		{
			string $msg = ("\nSpotlight Error - " + $light + " is not a spotlight");
			print $msg; $gBoltWarnings += $msg;
		}
	}
}





global proc boltTestWindscreenReflections()
{
	global string $gBoltWarnings;
	
	//windscreen
	if (objExists("WINDOW_F"))
	{
		if (objExists("REFLECTION_WINDSCREEN"))
		{
			boltTestWindscreenReflectionColours("REFLECTION_WINDSCREEN");
			
			
			float $win_angle = boltGetAngleOfVerts(boltGetCentralVerts("WINDOW_F"));
			float $ref_angle = boltGetAngleOfVerts(boltGetCentralVerts("REFLECTION_WINDSCREEN"));
			
			if ($win_angle < -999)
			{
				string $msg = ("\nWindscreen Reflection Error - Could not establish WINDOW_F angle - does WINDOW_F have a central edge loop?");
				print $msg; $gBoltWarnings += $msg;
			}
			if ($ref_angle < -999)
			{
				string $msg = ("\nWindscreen Reflection Error - Could not establish REFLECTION_WINDSCREEN angle - does REFLECTION_WINDSCREEN have a central edge loop?");
				print $msg; $gBoltWarnings += $msg;
			}
				
			if (($win_angle < 15) && ($win_angle > -999))
			{
				string $msg = ("\nWindscreen Reflection Error - Unusually small angle detected for WINDOW_F (" + $win_angle + " degs). Please make sure no other objects or windows are attached.");
				print $msg; $gBoltWarnings += $msg;
			}
			else if (($win_angle >= 15) && ($ref_angle > -999))
			{
				if (!(equivalentTol($ref_angle, ($win_angle * 2), 5))) //5 degrees tolerance either way
				{
					string $msg = ("\nWindscreen Reflection Error - Wrong angle detected for 'REFLECTION_WINDSCREEN' (" + substring(string($ref_angle),1,5) + " degrees). Should be within 5 degrees of windscreen angle " + substring(string($win_angle),1,5) + " * 2 = " + substring(string(2*$win_angle),1,4) + " degrees. \n     (Error could also be caused by extra geometry or windows attached to the WINDOW_F)" );
					print $msg; $gBoltWarnings += $msg;
				}	
			}
			
			//lock normals upwards
			polyNormalPerVertex -xyz 0 1 0 "REFLECTION_WINDSCREEN";
			
		}
		else
		{
			string $msg = ("\n'Windscreen Reflection Error - REFLECTION_WINDSCREEN' not found in scene");
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	//side window
	if ( (objExists("WINDOW_FL")) || (objExists("WINDOW_FR")) )
	{
		if (objExists("REFLECTION_DOOR"))
		{
			boltTestWindscreenReflectionColours("REFLECTION_DOOR");
			
			//work out if left or right hand side reflection
			float $b[] = `polyEvaluate -b "REFLECTION_DOOR"`;
			string $window = "WINDOW_FL";
			if ($b[0] < 0) $window = "WINDOW_FR";
			
			float $win_angle = boltGetAngleOfSideWindow($window);
			float $ref_angle = boltGetAngleOfSideWindow("REFLECTION_DOOR");
			
			if ($window == "WINDOW_FL")
			{
				$ref_angle = 180 - $ref_angle;
				$win_angle = 180 - $win_angle;
			}
			
			if (!(equivalentTol($ref_angle, ($win_angle * 2), 5))) //5 degrees tolerance either way
			{
					string $msg = ("\nWindscreen Reflection Error - Wrong angle detected for 'REFLECTION_DOOR' (" + substring(string($ref_angle),1,5) + " degrees). Should be within 5 degrees of " + $window + " angle " + substring(string($win_angle),1,5) + " * 2 = " + substring(string(2*$win_angle),1,4) + " degrees. \n     (NB - Error could also be caused if extra geometry or windows are attached to the side window, or if dial reflections have been attached)" );
					print $msg; $gBoltWarnings += $msg;
			}
			
			//lock normals upwards
			polyNormalPerVertex -xyz 0 1 0 "REFLECTION_DOOR";
			
			
		}
		else
		{
			string $msg = ("\nWindscreen Reflection Error - 'REFLECTION_DOOR' not found in scene");
			print $msg; $gBoltWarnings += $msg;
		}
		
	}
	
	
}

//warns if windscreen reflections colours are wrong
global proc boltTestWindscreenReflectionColours(string $obj)
{
	global string $gBoltWarnings;
	
	string $highCols[] = {};
	string $wrongBorderCol[] = {};
	string $verts[] = `ls -fl ($obj+".vtx[*]")`;
	for ($v in $verts)
	{
		float $cols[] = `polyColorPerVertex -q -a $v`;
		if ( $cols[0] > 0.201) $highCols[size($highCols)] = $v;
		  
		if (boltIsBorderVert($v))
		{
			if ((`equivalentTol $cols[0] 0 0.001` != 1) && (`equivalentTol $cols[0] 0.2 0.001` != 1)) $wrongBorderCol[size($wrongBorderCol)] = $v;
		}
	}
	
	if (size($highCols) > 0)
	{
		string $vString = boltGetVertListAsString($highCols);
		string $msg = ("\nWindscreen Reflection Error - Verts with alpha values above 0.2 found - " + $vString);
		print $msg; $gBoltWarnings += $msg;
	}
	if (size($wrongBorderCol) > 0)
	{
		string $vString = boltGetVertListAsString($wrongBorderCol);
		string $msg = ("\nWindscreen Reflection Error - Border Verts incorrect alpha values found. Borders should be either 0 or 0.2 - " + $vString);
		print $msg; $gBoltWarnings += $msg;
	}
	
	print ("\n" + $obj + " Alpha Colours Checked");
}

global proc string boltGetVertListAsString(string $vlist[])
{
	string $vlist2[] = `ls $vlist`;
	string $s;
	for ($v in $vlist2) $s += ($v + " ");
	return $s;
}

		
//returns 1 if a given vert is on a border
global proc int boltIsBorderVert(string $v)
{
	string $edges[] = boltNorms.ToEdges({$v});
	for ($e in $edges)
	{
		string $polys[] = boltNorms.ToFaces({$e});
		if (size($polys) == 1) return 1;
	}
	return 0;
}



global proc float boltGetAngleOfVerts(string $verts[])
//measures angle of windscreen center verts from horizontal
//returns -1000 if error
{
	if (size($verts) < 2) return -1000;	
	
	$sel = `ls -sl`;
	select -r $verts;
	// xmin xmax ymin ymax zmin zmax
	float $bb[] = `polyEvaluate -bc`;
	select -r $sel;
	
	float $v1[] = {0.0, ($bb[2]-$bb[3]), ($bb[5]-$bb[4]) };
	float $v2[] = {0.0,0.0,1.0};
	
	float $angle = acosd(dotProduct( $v1, $v2, 1 ));
	
	float $lean[] = boltGetLeanVector($verts);
	if ($lean[2] > 0) $angle = 180-$angle;
	
	return $angle;
}


global proc float boltGetAngleOfSideWindow(string $obj)
//measures angle of side window from horizontal, can work on whole obj bb
{
	// xmin xmax ymin ymax zmin zmax
	
	float $bb[] = `boltGetWorldSpaceBounds $obj`;
	float $v1[] = {($bb[1]-$bb[0]), ($bb[3]-$bb[2]), 0};
	float $v2[] = {1.0,0.0,0.0};
	float $angle = acosd(dotProduct( $v1, $v2, 1 ));
	
	string $verts[] = `ls -fl ($obj + ".vtx[*]")`;
	float $lean[] = boltGetLeanVector($verts);
	
	if ($lean[0] < 0) $angle = 180-$angle;
	
	return $angle;
	
}

global proc float[] boltGetWorldSpaceBounds(string $obj)
//returns the world space oriented bounding box of given obj - needed for side window angle measurement
// xmin xmax ymin ymax zmin zmax
{
	string $verts[] = `ls -fl ($obj + ".vtx[*]")`;
	float $bb[] = {9999999,-9999999,9999999,-9999999,9999999,-9999999};
	for ($v in $verts)
	{
		float $p[] = `pointPosition -w $v`;
		if ($p[0] < $bb[0]) $bb[0] = $p[0];
		if ($p[0] > $bb[1]) $bb[1] = $p[0];
		if ($p[1] < $bb[2]) $bb[2] = $p[1];
		if ($p[1] > $bb[3]) $bb[3] = $p[1];
		if ($p[2] < $bb[4]) $bb[4] = $p[2];
		if ($p[2] > $bb[5]) $bb[5] = $p[2];
	}
	return $bb;
}

global proc float[] boltGetLeanVector(string $verts[])
//helps to work out which way the verts are leaning
{
	float $high[] = `pointPosition -w $verts[0]`; 
	float $low[]  = `pointPosition -w $verts[0]`; 
	for ($vert in $verts)
	{
		float $pos[] = `pointPosition -w $vert`;
		if ($pos[1] > $high[1]) $high = $pos;
		if ($pos[1] < $low[1])  $low = $pos;
	}
	
	return {($high[0]-$low[0]),($high[1]-$low[1]),($high[2]-$low[2])};
}
	



global proc string[] boltGetCentralVerts(string $obj)
//returns verts near centre of object (in x axis)
{
	float $tolerance = 0.02;
	string $centerVerts[] = {};
	string $verts[] = `ls -fl ($obj+".vtx[*]")`;
	for ($vert in $verts)
	{
		float $pos[] = `pointPosition -w $vert`;
		if (equivalentTol($pos[0], 0, $tolerance))
		{
			$centerVerts[size($centerVerts)] = $vert;
		}
	}
	return $centerVerts;
}


global proc boltCheckLightShaderSetup()
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;
	
	string $lightShaders[] = {"light_shader_standard.xml","light_shader_under_colour.xml","light_shader_standard_damage.xml"};
	string $shaders[] = `ls -type "ATGMaterial"`;
	
	//ensure everything is set to colourset1
	string $objs[] = boltShapesToTransforms(`ls -type "mesh"`);
	for ($obj in $objs)
	{
		string $colourSets[] = `polyColorSet -q -allColorSets $obj`;
		if (sFindItem($colourSets, "colorSet1") != -1)
		{
			polyColorSet -currentColorSet -colorSet "colorSet1" $obj;
		}
	}
	
	int $headLightFound = 0;
	int $tailLightFound = 0;
	int $brakeLightFound = 0;
	int $combiLightFound = 0;
	int $reverseLightFound = 0;
	int $sideLightFound = 0;
		
	for ($shader in $shaders)
	{
		string $xmlpath = boltGetShaderPreset($shader);
		string $xml = basename( $xmlpath, "" );
		
		for ($lightShader in $lightShaders)
		{
			//light shader found
			if ($xml == $lightShader)
			{
				
				string $sgs[] = getSGFromMaterial($shader);
				
				if (size($sgs)==0) continue;
				
				string $shadedPolys[] = `sets -q $sgs[0]`;
				$shadedPolys = boltNorms.ToFaces($shadedPolys);
				
				for ($poly in $shadedPolys)
				{
					if ((`gmatch $poly "*_DAM.f*"` == 0) && (`gmatch $poly "*_DAMShape.f*"` == 0))
					{
						
						//get light type - returns [index, glowtype, mirror, plusone, constType] 
						int $lightType[] = boltGetLightTypeSCV($poly);
						
						//check for gradient
						if ($lightType[0] == -1)
						{
							$msg = ("\nLight Setup Error - " + $poly + " has a gradient of light types across its vertex colours - Should be a constant value per polygon");
							print $msg; $gBoltWarnings += $msg;
						}
						else
						{
							//check mirroring
							int $mirroredUVs = (boltReturnUVWinding2(boltGetVertexOrder($poly)) == 1);
							if ($lightType[2] != $mirroredUVs) 
							{
								$msg = ("\nLight Setup Error - " + $poly + " has a mirror setting opposite to its UV mapping direction");
								print $msg; $gBoltWarnings += $msg;
							}
							
							//check light types are present
							if ($lightType[1] == 0) $headLightFound = 1;
							if ($lightType[1] == 1) $sideLightFound = 1;
							if ($lightType[1] == 2) $tailLightFound = 1;
							if ($lightType[1] == 3) $brakeLightFound = 1;
							if ($lightType[1] == 4) $combiLightFound = 1;
							if ($lightType[1] == 5) $reverseLightFound = 1;
							
							//add more checks for invalid types / colours??
						}	
					}
				}
			}
		}
	}
	
	if ($headLightFound == 0)
	{
		$msg = ("\nLight Setup Warning - no light shaders set to 'headlight' found in scene");
		print $msg; $gBoltWarningsLow += $msg;
	}
	if ($sideLightFound == 0)
	{
		$msg = ("\nLight Setup Warning - no light shaders set to 'sidelight' found in scene");
		print $msg; $gBoltWarningsLow += $msg;
	}
	if (($tailLightFound == 0) && ($combiLightFound == 0))
	{
		$msg = ("\nLight Setup Warning - no light shaders set to 'taillight' or 'combilight' found in scene");
		print $msg; $gBoltWarningsLow += $msg;
	}
	if (($brakeLightFound = 0) && ($combiLightFound == 0))   
	{
		$msg = ("\nLight Setup Warning - no light shaders set to 'brakelight' or 'combilight' found in scene");
		print $msg; $gBoltWarningsLow += $msg;
	}
	if ($reverseLightFound == 0)
	{
		$msg = ("\nLight Setup Warning - no light shaders set to 'reverselight' found in scene");
		print $msg; $gBoltWarningsLow += $msg;
	}
	
	print "\nLight shader vertex colour checks complete";
}

global proc int[] boltGetLightTypeSCV(string $poly)
//given a light shader poly, returns [index, glowtype, mirror, plusone, constType] 
//returns -1 index if inconsistent colours found
{
	string $vfs[] = boltNorms.ToVFs({$poly});  
	
	//check colours are consistent on poly
	float $col[] = `polyColorPerVertex -q -b $vfs[0]`;
	for ($vf in $vfs)
	{
		float $newCol[] = `polyColorPerVertex -q -b $vf`;
		if (`equivalentTol $newCol[0] $col[0] 0.00001` == 0)
		{
			return {-1,-1,-1,-1,-1}; //return error
		}
	}
	
	//reverse this:
	//$index = ($constType * 16) + ($mirror * 8) + $glowType + ($plusone*128);
	//float $colour = ($index / 255.0) + (0.1 / 255.0);
	float $fIndex = 255.0 * ($col[0]); //  - (0.1 / 255.0));
	int $index = $fIndex;
	int $glowType = $index % 8;
	int $mirror = ($index/8) % 2;
	int $plusOne = ($index/128) % 2;
	int $constType = ($index/16) % 8;
	
	return {$index, $glowType, $mirror, $plusOne, $constType};
	
}

global proc boltSCV.checkAlbedoValues()
{
	global string $gBoltWarnings;
	string $mats[] = `ls -type "ATGMaterial"`; 
	
	string $albedoTexs[] = {"*_texture_Diffuse*", "*_texture_Albedo*", "*_texture_OpaqueColourMap*","*_texture_PaintAlbedo*","*_texture_Stitch_Albedo*"};
	string $albedoCols[] = {"*float_DiffuseColour", "*float_AlbedoColour", "*float_Diffuse", "*float_Albedo", "*float_PaintColour", "*float_Stitch_Albedo", "*float_Piping_Albedo"};
	
	string $foundAlbedoTextures[] = {};
	string $foundAlbedoColours[] = {};
	
	for ($mat in $mats)
	{
		string $attrs[] = `listAttr $mat`;
		for ($attr in $attrs)
		{
			for ($albedoTex in $albedoTexs)
			{
				if (`gmatch $attr $albedoTex`)
				{
					print ("\nFound albedo texture attribute: " + $mat + "." + $attr);
					string $path = `getAttr ($mat + "." + $attr)`;
					if ($path == "")
					{
						$msg = ("\nShader warning - Empty texture slot found: " + $mat + "." + $attr);
						print $msg; //$gBoltWarnings += $msg; //avoid duplicate warnings
					}
					else
					{
						$foundAlbedoTextures[size($foundAlbedoTextures)] = $path;
					}
				}
			}
			
			for ($albedoCol in $albedoCols)
			{
				if (`gmatch $attr $albedoCol`)
				{
					print ("\nFound albedo colour attribute: " + $mat + "." + $attr);
					$foundAlbedoColours[size($foundAlbedoColours)] = ($mat + "." + $attr);
				}
			}
		}
	}
	
	$foundAlbedoTextures = stringArrayRemoveDuplicates($foundAlbedoTextures);
	$foundAlbedoColours = stringArrayRemoveDuplicates($foundAlbedoColours);
	
	for ($path in $foundAlbedoTextures)
	{
		$cmd = "superTextureTools.checkTextureAlbedo(\"" + $path + "\")"; 
		if (python($cmd))
		{
			$msg = ("\nAlbedo Texture Error - Texture has albedo brighter than 0.8: " + $path );
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	for ($att in $foundAlbedoColours)
	{
		float $col[] = `getAttr $att`;
		int $errorFlag = 0;
		for ($c in $col)
		{
			if ( pow($c,0.5) > 0.8)
			{
				$errorFlag = 1;
			}
		}
		if ($errorFlag)
		{
			$msg = ("\nAlbedo Colour Error - Colour has albedo brighter than 0.8: " + $att );
			print $msg; $gBoltWarnings += $msg;
		}
	}
	
	
	
}