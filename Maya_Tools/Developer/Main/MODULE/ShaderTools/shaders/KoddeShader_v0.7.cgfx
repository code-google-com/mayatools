/******************************************************************************
 * The following code was generated by the mental mill(R)                     *
 * Fx_code_generator build 45261.50496 23 Jul 2009 nt-x86
 *                                                                            *
 * Portions Copyright (c) 1986-2009 mental images GmbH, Berlin, Germany.      *
 ******************************************************************************/

// shader type surface

//
// The state structure is used internally within the fragment shader to
// commonly used values.
//
struct State
{
	float4 tex_coord[4];
	float3 position;
	float3 origin;
	float3 normal;
	float3 geom_normal;
	float3 direction;
	float ray_length;
	float3x3 tangent_space[1];
};

//
// Values for the light_type parameter of light shaders
//
#define LIGHT_POINT    0
#define LIGHT_SPOT     1
#define LIGHT_INFINITE 2
#define LIGHT_PLANAR   3

//
// The light iterator structure holds the return values resulting from
// evaluating a light.
//
#ifndef __LIGHT_ITERATOR_STRUCT
#define __LIGHT_ITERATOR_STRUCT
struct Light_iterator {
    float3 msl_point;
    float4 msl_contribution;
    float4 msl_raw_contribution;
    float  msl_dot_nl;
    float3 msl_direction;
    float  msl_distance;
    float4 msl_shadow;
    int    msl_count;
};
#endif // __LIGHT_ITERATOR_STRUCT

struct Ray {
    float3 msl_origin;
    float3 msl_direction;
};

void __make_basis(const float3 n, const float3 u, const float3 v,
        out float3 t, out float3 b)
{
    b = normalize(cross(u,n));
    t = cross(n,b);
    if (dot(b,v) < 0.0)  b = -b;
}

float3 __perspective_divide(float4 pt)
{
    return pt.xyz/pt.w;
}

// 
// State dependant variable recalculation. 
// 
void __update_state_origin_or_position(inout State state) 
{ 
    state.direction = state.position - state.origin; 
    state.ray_length = length(state.direction); 
    state.direction = normalize(state.direction); 
} 

//
// The following are free parameters of the shader that should be set by the
// application at runtime.
//


bool Use_Half_Lambert
<
	string UIName = "Use Half Lambert";
> = false;

float3 Diffuse_Color : Diffuse
<
	string UIName = "Diffuse Color";
> = float3(1.0, 1.0, 1.0);


texture __msl_kostasShader01_1_ColorTexture <
	string UIName = "msl_kostasShader01_1_ColorTexture";
	string ResourceType = "2D";
>;

sampler2D Diffuse_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_ColorTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};


float Specular_Intensity
<
	string UIName = "Specular Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.200000;


texture __msl_kostasShader01_1_SpecularTexture <
	string UIName = "msl_kostasShader01_1_SpecularTexture";
	string ResourceType = "2D";
>;

sampler2D Specular_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_SpecularTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

bool Specularity_in_transparency
<
	string UIName = "Include spec on transparent surfaces";
> = false;


float Specular_Gloss_Factor
<
	string UIName = "Spec Gloss Factor";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.300000;

bool Use_Specular_Gloss_Texture
<
	string UIName = "Use specular gloss texture";
> = false;

texture __msl_kostasShader01_1_SpecularGlossTexture <
	string UIName = "msl_kostasShader01_1_SpecularGlossTexture";
	string ResourceType = "2D";
>;

sampler2D Specular_Gloss_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_SpecularGlossTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

texture __msl_kostasShader01_1_TangentNormalTexture <
	string UIName = "msl_kostasShader01_1_TangentNormalTexture";
	string ResourceType = "2D";
>;

sampler2D Tangent_Normal_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_TangentNormalTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

float Normal_Map_Intensity
<
	string UIName = "Normal Map Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

texture __msl_kostasShader01_1_ParallaxTexture <
	string UIName = "msl_kostasShader01_1_ParallaxTexture";
	string ResourceType = "2D";
>;

sampler2D Parallax_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_ParallaxTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

float Parallax_Intensity
<
	string UIName = "Parallax Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

texture __msl_Environment_map_cubic_1_env_tex <
	string UIName = "msl_Environment_map_cubic_1_env_tex";
	string ResourceType = "Cube";
>;

samplerCUBE Reflection_Env_Cube = sampler_state {
	Texture = <__msl_Environment_map_cubic_1_env_tex>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapR = ClampToEdge;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};

float Reflectivity_Intensity
<
	string UIName = "Reflectivity Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float Reflection_Gain
<
	string UIName = "Reflectivity Gain";
	float UIMin = 1.0;
	float UIMax = 5.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float Reflectivity_Fresnel
<
	string UIName = "Reflectivity Fresnel";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

texture __msl_kostasShader01_1_ReflectivityTexture <
	string UIName = "msl_kostasShader01_1_ReflectivityTexture";
	string ResourceType = "2D";
>;

sampler2D Reflectivity_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_ReflectivityTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

bool Transparency_Include_Reflections
<
	string UIName = "Include refl on transparent surfaces";
> = false;





texture __msl_kostasShader01_1_TintRampTexture <
	string UIName = "msl_kostasShader01_1_TintRampTexture";
	string ResourceType = "2D";
>;

sampler2D Tint_Ramp_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_TintRampTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

float Tint_Ramp_Intensity
<
	string UIName = "Tint Ramp Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float Tint_Ramp_Offset_U
<
	string UIName = "Tint Ramp Offset U";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float Tint_Ramp_Offset_V
<
	string UIName = "Tint Ramp Offset V";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

bool Tint_Ramp_Invert_U
<
	string UIName = "Tint Ramp Invert U";
> = true;

bool Tint_Ramp_Invert_V
<
	string UIName = "Tint Ramp Invert V";
> = false;

texture __msl_TintMask2DTexture_texture <
	string UIName = "msl_TintMask2DTexture_texture";
	string ResourceType = "2D";
>;

sampler2D Tint_Mask_Texture = sampler_state {
	Texture = <__msl_TintMask2DTexture_texture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};


bool Use_Diffuse_Warp_Ramp
<
	string UIName = "Use Diffuse Warp Ramp";
> = false;

texture __msl_kostasShader01_1_DiffuseWarpRamp <
	string UIName = "msl_kostasShader01_1_DiffuseWarpRamp";
	string ResourceType = "2D";
>;

sampler2D Diffuse_Warp_Ramp = sampler_state {
	Texture = <__msl_kostasShader01_1_DiffuseWarpRamp>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

bool Diffuse_Warp_Ramp_Invert
<
	string UIName = "Diffuse Warp Ramp Invert";
> = false;

bool Use_Emissive_Map
<
	string UIName = "Use Emissive Map";
> = false;

texture __msl_kostasShader01_1_EmissiveTexture <
	string UIName = "msl_kostasShader01_1_EmissiveTexture";
	string ResourceType = "2D";
>;

sampler2D Emissive_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_EmissiveTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};

float Emissive_Intensity
<
	string UIName = "Emissive Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float Ambient_Light_Intensity
<
	string UIName = "Ambient Light Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float3 msl_kostasShader01_1_Ambient_Color : Diffuse
<
	float3 UIMin = float3(0.0, 0.0, 0.0);
	float3 UIMax = float3(1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float3(1.0, 1.0, 1.0);


bool Use_Hemi_Coloring
<
	string UIName = "Use Hemispheric Ambient Light Colors";
> = false;

float3 Hemi_Sky_Color : Diffuse
<
	string UIName = "Hemi Sky Color";
> = float3(1.0, 1.0, 1.0);

float3 Hemi_Ground_Color : Diffuse
<
	string UIName = "Hemi Ground Color";
> = float3(1.0, 1.0, 1.0);

bool Use_Ambient_Environment_Map
<
	string UIWidget = "Use Ambient Light Cube Map";
> = false;

texture __msl_kostasShader01_1_EnvAmbientTexture <
	string UIName = "msl_kostasShader01_1_EnvAmbientTexture";
	string ResourceType = "Cube";
>;

samplerCUBE Ambient_Env_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_EnvAmbientTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
	WrapR = ClampToEdge;
	WrapS = ClampToEdge;
	WrapT = ClampToEdge;
};


texture __msl_kostasShader01_1_AOTexture <
	string UIName = "msl_kostasShader01_1_AOTexture";
	string ResourceType = "2D";
>;

sampler2D Ambient_Occ_Texture = sampler_state {
	Texture = <__msl_kostasShader01_1_AOTexture>;
	MinFilter = LinearMipMapLinear;
	MagFilter = Linear;
};


float Ambient_Occ_Intensity
<
	string UIName = "Ambient Occ Intensity";
	float UIMin = 0.0;
	float UIMax = 1.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float Rim_Light_Intensity
<
	string UIName = "Rim Light Intensity";
	float UIMin = 0.0;
	float UIMax = 5.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float Rim_Light_Edge_Factor
<
	string UIName = "Rim Light Edge Factor";
	float UIMin = 0.0;
	float UIMax = 20.0;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 10;


bool Display_ZDepth
<
	string UIName = "Display Z-Depth";
> = false;

float ZDepth_Near
<
	string UIName = "Z-Depth Near Plane";
> = 0.0;

float ZDepth_Far
<
	string UIName = "Z-Depth Far Plane";
> = 0.0;


bool Display_World_Normals
<
	string UIName = "Display World Normals";
> = false;

bool Display_Camera_Normals
<
	string UIName = "Display Camera Normals";
> = false;







//Directional Light 1 - Intensity & color


bool Directional1_Enabled
<
	string UIName = "Directional1_Enabled";
> = true;


float msl_Light_directional_1_intensity
<
	string UIName = "Directional1_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 3.000000;

float4 msl_Light_directional_1_color : Diffuse
<
	string UIName = "Directional1_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);

// Directional Light 1 - Direction

float3 Directional1_Direction : Direction 
<
	string Object = "InfiniteLight0";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float4x4 msl_light0_transform_internal_to_light;
float4x4 msl_light0_transform_light_to_internal;


//Directional Light 2 - Intensity & color


bool Directional2_Enabled
<
	string UIName = "Directional2_Enabled";
> = true;

float msl_Light_directional_2_intensity
<
	string UIName = "Directional2_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.000000;

float4 msl_Light_directional_2_color : Diffuse
<
	string UIName = "Directional2_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);


// Directional Light 2 - Direction

float3 Directional2_Direction : Direction 
<
	string Object = "InfiniteLight1";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float4x4 msl_light1_transform_internal_to_light;
float4x4 msl_light1_transform_light_to_internal;


//Directional Light 3 - Intensity & color


bool Directional3_Enabled
<
	string UIName = "Directional3_Enabled";
> = true;


float msl_Light_directional_3_intensity
<
	string UIName = "Directional3_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.000000;

float4 msl_Light_directional_3_color : Diffuse
<
	string UIName = "Directional3_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);


// Directional Light 3 - Direction

float3 Directional3_Direction : Direction 
<
	string Object = "InfiniteLight2";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float4x4 msl_light2_transform_internal_to_light;
float4x4 msl_light2_transform_light_to_internal;



//Point Light 1


bool Point1_Enabled
<
	string UIName = "Point1_Enabled";
> = true;


float msl_Light_point_1_intensity
<
	string UIName = "Point1_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_point_1_color : Diffuse
<
	string UIName = "Point1_Color";
	string UIWidget = "Color";
> = float4(1.0, 1.0, 1.0, 1.0);


float msl_Light_point_1_distance_falloff_exponent
<
	string UIName = "Point1_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;
float msl_Light_point_1_distance_scale
<
	string UIName = "Point1_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float3 Point1_Position : Position 
<
	string Object = "PointLight3";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light3_transform_internal_to_light;
float4x4 msl_light3_transform_light_to_internal;


//Point Light 2

bool Point2_Enabled
<
	string UIName = "Point2_Enabled";
> = true;

float msl_Light_point_2_intensity
<
	string UIName = "Point2_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_point_2_color : Diffuse
<
	string UIName = "Point2_Color";
	string UIWidget = "Color";
> = float4(1.0, 1.0, 1.0, 1.0);


float msl_Light_point_2_distance_falloff_exponent
<
	string UIName = "Point2_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;
float msl_Light_point_2_distance_scale
<
	string UIName = "Point2_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;


float3 Point2_Position : Position 
<
	string Object = "PointLight4";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light4_transform_internal_to_light;
float4x4 msl_light4_transform_light_to_internal;


//Point Light 3


bool Point3_Enabled
<
	string UIName = "Point3_Enabled";
> = true;

float msl_Light_point_3_intensity
<
	string UIName = "Point3_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_point_3_color : Diffuse
<
	string UIName = "Point3_Color";
	string UIWidget = "Color";
> = float4(1.0, 1.0, 1.0, 1.0);


float msl_Light_point_3_distance_falloff_exponent
<
	string UIName = "Point3_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;
float msl_Light_point_3_distance_scale
<
	string UIName = "Point3_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;


float3 Point3_Position : Position 
<
	string Object = "PointLight5";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light5_transform_internal_to_light;
float4x4 msl_light5_transform_light_to_internal;


//Point Light 4


bool Point4_Enabled
<
	string UIName = "Point4_Enabled";
> = true;


float msl_Light_point_4_intensity
<
	string UIName = "Point4_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_point_4_color : Diffuse
<
	string UIName = "Point4_Color";
	string UIWidget = "Color";
> = float4(1.0, 1.0, 1.0, 1.0);


float msl_Light_point_4_distance_falloff_exponent
<
	string UIName = "Point4_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;
float msl_Light_point_4_distance_scale
<
	string UIName = "Point4_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;


float3 Point4_Position : Position 
<
	string Object = "PointLight6";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float4x4 msl_light6_transform_internal_to_light;
float4x4 msl_light6_transform_light_to_internal;



//Spot Light 1


bool Spot1_Enabled
<
	string UIName = "Spot1_Enabled";
> = true;


float msl_Light_spot_1_intensity
<
	string UIName = "Spot1_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_spot_1_color : Diffuse
<
	string UIName = "Spot1_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);

float msl_Light_spot_1_distance_falloff_exponent
<
	string UIName = "Spot1_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_spot_1_distance_scale
<
	string UIName = "Spot1_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float msl_Light_spot_1_light_spread_inner
<
	string UIName = "Spot1_Spread_Inner";
	float UIMin = 0.0;
	float UIMax = 90.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 30.000000;

float msl_Light_spot_1_light_spread_falloff
<
	string UIName = "Spot1_Spread_Falloff";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;


float Spot1_Spread
<
> = 0.785398;
float Spot1_Spread_Cos
<
> = 0.707107;
float3 Spot1_Position : Position 
<
	string Object = "SpotLight7";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float3 Spot1_Direction : Direction 
<
	string Object = "SpotLight7";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);

float4x4 msl_light7_transform_internal_to_light;
float4x4 msl_light7_transform_light_to_internal;


//Spot Light 2

bool Spot2_Enabled
<
	string UIName = "Spot2_Enabled";
> = true;


float msl_Light_spot_2_intensity
<
	string UIName = "Spot2_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_spot_2_color : Diffuse
<
	string UIName = "Spot2_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);

float msl_Light_spot_2_distance_falloff_exponent
<
	string UIName = "Spot2_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_spot_2_distance_scale
<
	string UIName = "Spot2_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float msl_Light_spot_2_light_spread_inner
<
	string UIName = "Spot2_Spread_Inner";
	float UIMin = 0.0;
	float UIMax = 90.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 30.000000;

float msl_Light_spot_2_light_spread_falloff
<
	string UIName = "Spot2_Spread_Falloff";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float Spot2_Spread
<
> = 0.785398;
float Spot2_Spread_Cos
<
> = 0.707107;
float3 Spot2_Position : Position 
<
	string Object = "SpotLight8";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float3 Spot2_Direction : Direction 
<
	string Object = "SpotLight8";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);

float4x4 msl_light8_transform_internal_to_light;
float4x4 msl_light8_transform_light_to_internal;



//Spot Light 3

bool Spot3_Enabled
<
	string UIName = "Spot3_Enabled";
> = true;



float msl_Light_spot_3_intensity
<
	string UIName = "Spot3_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_spot_3_color : Diffuse
<
	string UIName = "Spot3_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);

float msl_Light_spot_3_distance_falloff_exponent
<
	string UIName = "Spot3_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_spot_3_distance_scale
<
	string UIName = "Spot3_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float msl_Light_spot_3_light_spread_inner
<
	string UIName = "Spot3_Spread_Inner";
	float UIMin = 0.0;
	float UIMax = 90.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 30.000000;

float msl_Light_spot_3_light_spread_falloff
<
	string UIName = "Spot3_Spread_Falloff";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;


float3 Spot3_Position : Position 
<
	string Object = "SpotLight9";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float3 Spot3_Direction : Direction 
<
	string Object = "SpotLight9";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float Spot3_Spread
<
> = 0.785398;
float Spot3_Spread_Cos
<
> = 0.707107;
float4x4 msl_light9_transform_internal_to_light;
float4x4 msl_light9_transform_light_to_internal;


//Spot Light 4

bool Spot4_Enabled
<
	string UIName = "Spot4_Enabled";
> = true;



float msl_Light_spot_4_intensity
<
	string UIName = "Spot4_Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float4 msl_Light_spot_4_color : Diffuse
<
	string UIName = "Spot4_Color";
	float4 UIMin = float4(0.0, 0.0, 0.0, 0.0);
	float4 UIMax = float4(1.0, 1.0, 1.0, 1.0);
	float UIStep = 0.01;
	string UIWidget = "slider";
> = float4(1.0, 1.0, 1.0, 1.0);

float msl_Light_spot_4_distance_falloff_exponent
<
	string UIName = "Spot4_Falloff_Exp";
	float UIMin = 0.0;
	float UIMax = 4.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 0.0;

float msl_Light_spot_4_distance_scale
<
	string UIName = "Spot4_Distance_Scale";
	float UIMin = 0.001000;
	float UIMax = 2.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float msl_Light_spot_4_light_spread_inner
<
	string UIName = "Spot4_Spread_Inner";
	float UIMin = 0.0;
	float UIMax = 90.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 30.000000;

float msl_Light_spot_4_light_spread_falloff
<
	string UIName = "Spot4_Spread_Falloff";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;

float3 Spot4_Position : Position 
<
	string Object = "SpotLight10";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);
float3 Spot4_Direction : Direction 
<
	string Object = "SpotLight10";
	string Space = "View";
> = float3(0.0, 0.0, -1.000000);
float Spot4_Spread
<
> = 0.785398;
float Spot4_Spread_Cos
<
> = 0.707107;
float4x4 msl_light10_transform_internal_to_light;
float4x4 msl_light10_transform_light_to_internal;


//Trash Attributes I'd rather not have showing

//Directional Lights Position Slots

float3 Ignore_Me_Dir1Pos : Position 
<
	string Object = "InfiniteLight0";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);

float3 Ignore_Me_Dir2Pos : Position 
<
	string Object = "InfiniteLight1";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);

float3 Ignore_Me_Dir3Pos : Position 
<
	string Object = "InfiniteLight2";
	string Space = "View";
> = float3(0.0, 0.0, 0.0);







float msl_Environment_map_cubic_1_intensity
<
	string UIName = "Intensity";
	float UIMin = 0.0;
	float UIMax = 10.000000;
	float UIStep = 0.01;
	string UIWidget = "slider";
> = 1.0;


//
// The following are parameters representing non-varying state variables 
// referenced by the shader. These should be set by the application at runtime.
// Note that vector parameters should be provided in camera space.
//
float4x4 __object_to_ndc : WorldViewProjection
<
	string UIWidget = "none";
>;
float __refracted_ior = 1.01;
float __incident_ior = 1.0;
bool __orthographic : Orthographic= false;
float4x4 __world_to_camera : View
<
	string UIWidget = "none";
>;
float4x4 __object_to_world : World
<
	string UIWidget = "none";
>;
float4x4 __object_to_camera : WorldView
<
	string UIWidget = "none";
>;
float4x4 __camera_to_world : ViewInverse
<
	string UIWidget = "none";
>;
float4x4 __camera_to_object : WorldViewInverse
<
	string UIWidget = "none";
>;
float4 __scene_ambient : Ambient
<
	string UIName = "Scene Ambient";
	string UIWidget = "color";
> = float4(0.00,0.00,0.00,0.00);
//                                                   
// The following are parameters representing non-varying non-state variables      
// referenced by the shader. These should be set by the application at runtime.             
//                                                   
float4x4 __internal_to_light;
float4x4 __light_to_internal;


#ifndef mi_falloff__float__float3__float3__float
#define mi_falloff__float__float3__float3__float 1
float mi_falloff(
	inout State state,
	float3 msl_direction,
	float3 msl_normal,
	float msl_amount)
{
	float msl_f;
	msl_f = (saturate((dot((-msl_direction), msl_normal))));
	msl_f = (1.0 - (pow(msl_f, (1.0 / msl_amount))));
	return msl_f;
}
#endif

#ifndef mi_phong_specular__float__float3__float3__float3__float
#define mi_phong_specular__float__float3__float3__float3__float 1
float mi_phong_specular(
	inout State state,
	float3 msl_lightDir,
	float3 msl_eyeDir,
	float3 msl_n,
	float msl_specular_shininess)
{
	float3 msl_refl = ((2.f * (-(dot(msl_eyeDir, msl_n)))) * msl_n) + msl_eyeDir;
	float msl_h = dot(msl_refl, msl_lightDir);
	return ((pow((max(msl_h, 0.f)), msl_specular_shininess)) * (msl_specular_shininess + 2.f)) / (2.0 * 3.14159265358979323846f);
}
#endif

#ifndef rgb_to_hsv__Color__Color
#define rgb_to_hsv__Color__Color 1
float4 rgb_to_hsv(
	inout State state,
	float4 msl_rgb)
{
	float4 msl_result;
	float msl_channelMin, msl_channelMax, msl_delta;
	msl_channelMin = (min(msl_rgb.r, (min(msl_rgb.g, msl_rgb.b))));
	msl_channelMax = (max(msl_rgb.r, (max(msl_rgb.g, msl_rgb.b))));
	msl_result.b = msl_channelMax;
	msl_delta = (msl_channelMax - msl_channelMin);
	if (msl_channelMax != (float(0)))
	{
		msl_result.g = (msl_delta / msl_channelMax);
	}
	else
	{
		msl_result.g = (float(0));
		msl_result.r = (float((-1)));
		return msl_result;
	}
	if (msl_rgb.r == msl_channelMax)
	{
		msl_result.r = ((msl_rgb.g - msl_rgb.b) / msl_delta);
	}
	else
	{
		if (msl_rgb.g == msl_channelMax)
		{
			msl_result.r = ((float(2)) + ((msl_rgb.b - msl_rgb.r) / msl_delta));
		}
		else
		{
			msl_result.r = ((float(4)) + ((msl_rgb.r - msl_rgb.g) / msl_delta));
		}
	}
	msl_result.r *= (float(60));
	if (msl_result.r < (float(0)))
	{
		msl_result.r += (float(360));
	}
	return msl_result;
}
#endif

#ifndef hsv_to_rgb__Color__Color
#define hsv_to_rgb__Color__Color 1
float4 hsv_to_rgb(
	inout State state,
	float4 msl_hsv)
{
	float4 msl_result;
	int msl_i;
	float msl_f, msl_p, msl_q, msl_t;
	if (msl_hsv.g == (float(0)))
	{
		msl_result = (float4(msl_hsv.b));
		return msl_result;
	}
	msl_hsv.r /= (float(60));
	msl_i = (int((floor(msl_hsv.r))));
	msl_f = (msl_hsv.r - (float(msl_i)));
	msl_p = (msl_hsv.b * ((float(1)) - msl_hsv.g));
	msl_q = (msl_hsv.b * ((float(1)) - (msl_hsv.g * msl_f)));
	msl_t = (msl_hsv.b * ((float(1)) - (msl_hsv.g * ((float(1)) - msl_f))));
	{
		bool msl_exit = false;
		if((msl_i == 0))
		{
			msl_result.r = msl_hsv.b;
			msl_result.g = msl_t;
			msl_result.b = msl_p;
		}
		else
		if((msl_i == 1))
		{
			msl_result.r = msl_q;
			msl_result.g = msl_hsv.b;
			msl_result.b = msl_p;
		}
		else
		if((msl_i == 2))
		{
			msl_result.r = msl_p;
			msl_result.g = msl_hsv.b;
			msl_result.b = msl_t;
		}
		else
		if((msl_i == 3))
		{
			msl_result.r = msl_p;
			msl_result.g = msl_q;
			msl_result.b = msl_hsv.b;
		}
		else
		if((msl_i == 4))
		{
			msl_result.r = msl_t;
			msl_result.g = msl_p;
			msl_result.b = msl_hsv.b;
		}
		else
		{
			msl_result.r = msl_hsv.b;
			msl_result.g = msl_p;
			msl_result.b = msl_q;
		}

	}
	return msl_result;
}
#endif



//
// The App2vert structure defines the vertex attributes used by the vertex
// shader. The application should supply a vertex stream containing these 
// elements.
//
struct App2vert
{
	float3 position : POSITION;
	float3 normal : NORMAL;
	float4 texcoord0 : TEXCOORD0;
	float4 texcoord1 : TEXCOORD1;
	float4 texcoord2 : TEXCOORD2;
	float4 texcoord3 : TEXCOORD3;
	float3 tex_du : TANGENT;
	float3 tex_dv : BINORMAL;
};

//
// The Vert2frag structure defines values used by the fragment shader and
// supplied by the vertex shader.
//
struct Vert2frag
{
	float4 hpos : POSITION;
	float4 tex_coord[4] : TEXCOORD0;
	float3 tex_du : TEXCOORD4;
	float3 tex_dv : TEXCOORD5;
	float3 position : TEXCOORD6;
	float3 normal : TEXCOORD7;
};

//
// This function is the main method of the vertex shader.
//
Vert2frag vertex_main(
	App2vert vs_in)
{
	Vert2frag vs_out;
	float4 position = float4(vs_in.position, 1);
	vs_out.hpos = mul(__object_to_ndc, position);
	vs_out.position = mul(__object_to_camera, position).xyz;
	vs_out.normal = mul(vs_in.normal, (float3x3)__camera_to_object);
	vs_out.tex_coord[0] = vs_in.texcoord0;
	vs_out.tex_coord[1] = vs_in.texcoord1;
	vs_out.tex_coord[2] = vs_in.texcoord2;
	vs_out.tex_coord[3] = vs_in.texcoord3;
	vs_out.tex_du = mul((float3x3)__object_to_camera, vs_in.tex_du);
	vs_out.tex_dv = mul((float3x3)__object_to_camera, vs_in.tex_dv);
	return vs_out;
}

//
// Declaration of final output type. For MRT, this is a struct.
//
typedef float4 FS_OUT;

//
// The following functions are generated from the MetaSL implementation of
// the shaders that are part of the compiled shader graph.
//

void kostasShader01_NormalAndParallax_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_NormalAndParallax_Math_float_multiply_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left * msl_right);
	}
}

void kostasShader01_NormalAndParallax_Texture_coordinate_2d_parallax_main(
	inout State state,
	int msl_texture_space,
	float2 msl_texture_uv,
	float4 msl_height,
	float msl_amount,
	out float2 msl_result)
{
	{
		float msl_h = msl_height.x;
		msl_h = ((msl_h * msl_amount) - (msl_amount * 0.5));
		float3 msl_vtan = mul((state.tangent_space)[0], (state.direction));
		float2 msl_uv = msl_texture_uv;
		msl_result.x = (msl_texture_uv.x - (msl_vtan.x * msl_h));
		msl_result.y = (msl_texture_uv.y + (msl_vtan.y * msl_h));
	}
}

void kostasShader01_NormalAndParallax_Normals_make_normal_main(
	inout State state,
	float4 msl_color,
	float msl_amount,
	out float3 msl_result)
{
	{
		float3 msl_n = (msl_color.xyz - 0.5) * 2.0;
		msl_n.xy *= msl_amount;
		msl_result = (normalize((mul(msl_n, (state.tangent_space)[0]))));
	}
}

void kostasShader01_NormalAndParallax_main(
	inout State state,
	sampler2D msl_ParallaxTexture,
	float msl_ParallaxAmount,
	sampler2D msl_NormalTexture,
	float msl_NormalAmount,
	out float3 msl_NormalResult,
	out float2 msl_TextureOffset)
{
	{
		float4 msl_Texture_lookup_2d_6_result;
		kostasShader01_NormalAndParallax_Texture_lookup_2d_main(state, msl_ParallaxTexture, 0, (float2((state.tex_coord)[0].x, (state.tex_coord)[0].y)), msl_Texture_lookup_2d_6_result);
		float msl_Math_float_multiply_3_result;
		kostasShader01_NormalAndParallax_Math_float_multiply_main(state, msl_ParallaxAmount, 0.100000, msl_Math_float_multiply_3_result);
		float2 msl_Texture_coordinate_2d_parallax_1_result;
		kostasShader01_NormalAndParallax_Texture_coordinate_2d_parallax_main(state, 0, (float2((state.tex_coord)[0].x, (state.tex_coord)[0].y)), msl_Texture_lookup_2d_6_result, msl_Math_float_multiply_3_result, msl_Texture_coordinate_2d_parallax_1_result);
		float4 msl_Texture_lookup_2d_7_result;
		kostasShader01_NormalAndParallax_Texture_lookup_2d_main(state, msl_NormalTexture, 0, msl_Texture_coordinate_2d_parallax_1_result, msl_Texture_lookup_2d_7_result);
		float3 msl_Normals_make_normal_1_result;
		kostasShader01_NormalAndParallax_Normals_make_normal_main(state, msl_Texture_lookup_2d_7_result, msl_NormalAmount, msl_Normals_make_normal_1_result);
		msl_NormalResult = msl_Normals_make_normal_1_result;
		msl_TextureOffset = msl_Texture_coordinate_2d_parallax_1_result;
	}
}

void kostasShader01_Conversion_float3_to_color_main(
	inout State state,
	float3 msl_vector,
	out float4 msl_result)
{
	{
		msl_result.x = msl_vector.x;
		msl_result.y = msl_vector.y;
		msl_result.z = msl_vector.z;
		msl_result.w = 1.0;
	}
}

void Light_directional_main(
	inout State state,
	bool msl_enabled,
	float4 msl_color,
	float msl_intensity,
	out float4 msl_result,
	out float4 msl_light_shadow,
	inout float4x4 msl__state_transform_internal_to_light,
	inout float4x4 msl__state_transform_light_to_internal)
{
	{
		msl_result = (float4((((float4(msl_color)) * msl_intensity) * (float(msl_enabled)))));
		msl_light_shadow = (float4(1,1,1,1));
	}
}

void Light_directional_1_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_direction), (state.normal));
	float4 msl_Light_directional_1_result;
	float4 msl_Light_directional_1_light_shadow;
	Light_directional_main(state, Directional1_Enabled, msl_Light_directional_1_color, msl_Light_directional_1_intensity, msl_Light_directional_1_result, msl_Light_directional_1_light_shadow, msl__state_transform_internal_to_light, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_direction);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_directional_1_result;
	msl___light.msl_contribution = msl_Light_directional_1_result;
	msl___light.msl_shadow = msl_Light_directional_1_light_shadow;
	msl___light.msl_count = 1;
}

void Light_directional_2_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_direction), (state.normal));
	float4 msl_Light_directional_2_result;
	float4 msl_Light_directional_2_light_shadow;
	Light_directional_main(state, Directional2_Enabled, msl_Light_directional_2_color, msl_Light_directional_2_intensity, msl_Light_directional_2_result, msl_Light_directional_2_light_shadow, msl__state_transform_internal_to_light, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_direction);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_directional_2_result;
	msl___light.msl_contribution = msl_Light_directional_2_result;
	msl___light.msl_shadow = msl_Light_directional_2_light_shadow;
	msl___light.msl_count = 1;
}

void Light_directional_3_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_direction), (state.normal));
	float4 msl_Light_directional_3_result;
	float4 msl_Light_directional_3_light_shadow;
	Light_directional_main(state, Directional3_Enabled, msl_Light_directional_3_color, msl_Light_directional_3_intensity, msl_Light_directional_3_result, msl_Light_directional_3_light_shadow, msl__state_transform_internal_to_light, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_direction);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_directional_3_result;
	msl___light.msl_contribution = msl_Light_directional_3_result;
	msl___light.msl_shadow = msl_Light_directional_3_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_main(
	inout State state,
	bool msl_enabled,
	float4 msl_color,
	float msl_intensity,
	float msl_distance_falloff_exponent,
	float msl_distance_scale,
	out float4 msl_result,
	out float4 msl_light_shadow,
	inout float4x4 msl__state_transform_internal_to_light,
	inout float msl__state_light_distance,
	inout float4x4 msl__state_transform_light_to_internal)
{
	{
		float msl_attenuation = 1.0;
		if (msl_distance_falloff_exponent > (float(0)))
		{
			msl_attenuation = (pow((msl__state_light_distance * msl_distance_scale), (-msl_distance_falloff_exponent)));
		}
		msl_result = (float4(((((float4(msl_color)) * msl_intensity) * msl_attenuation) * (float(msl_enabled)))));
		msl_light_shadow = (float4(1,1,1,1));
	}
}

void Light_point_1_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_1_result;
	float4 msl_Light_point_1_light_shadow;
	Light_point_main(state, Point1_Enabled, msl_Light_point_1_color, msl_Light_point_1_intensity, msl_Light_point_1_distance_falloff_exponent, msl_Light_point_1_distance_scale, msl_Light_point_1_result, msl_Light_point_1_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_1_result;
	msl___light.msl_contribution = msl_Light_point_1_result;
	msl___light.msl_shadow = msl_Light_point_1_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_2_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_2_result;
	float4 msl_Light_point_2_light_shadow;
	Light_point_main(state, Point2_Enabled, msl_Light_point_2_color, msl_Light_point_2_intensity, msl_Light_point_2_distance_falloff_exponent, msl_Light_point_2_distance_scale, msl_Light_point_2_result, msl_Light_point_2_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_2_result;
	msl___light.msl_contribution = msl_Light_point_2_result;
	msl___light.msl_shadow = msl_Light_point_2_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_3_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_3_result;
	float4 msl_Light_point_3_light_shadow;
	Light_point_main(state, Point3_Enabled, msl_Light_point_3_color, msl_Light_point_3_intensity, msl_Light_point_3_distance_falloff_exponent, msl_Light_point_3_distance_scale, msl_Light_point_3_result, msl_Light_point_3_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_3_result;
	msl___light.msl_contribution = msl_Light_point_3_result;
	msl___light.msl_shadow = msl_Light_point_3_light_shadow;
	msl___light.msl_count = 1;
}

void Light_point_4_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_point_4_result;
	float4 msl_Light_point_4_light_shadow;
	Light_point_main(state, Point4_Enabled, msl_Light_point_4_color, msl_Light_point_4_intensity, msl_Light_point_4_distance_falloff_exponent, msl_Light_point_4_distance_scale, msl_Light_point_4_result, msl_Light_point_4_light_shadow, msl__state_transform_internal_to_light, msl__state_light_distance, msl__state_transform_light_to_internal);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_point_4_result;
	msl___light.msl_contribution = msl_Light_point_4_result;
	msl___light.msl_shadow = msl_Light_point_4_light_shadow;
	msl___light.msl_count = 1;
}

void Light_spot_main(
	inout State state,
	bool msl_enabled,
	float4 msl_color,
	float msl_intensity,
	float msl_distance_falloff_exponent,
	float msl_distance_scale,
	float msl_light_spread_inner,
	float msl_light_spread_falloff,
	out float4 msl_result,
	out float4 msl_light_shadow,
	inout float3 msl__state_light_direction,
	inout float4x4 msl__state_transform_internal_to_light,
	inout float msl__state_light_spread_cos,
	inout float msl__state_light_distance,
	inout float4x4 msl__state_transform_light_to_internal,
	inout float msl__state_light_spread,
	inout float3 msl__state_light_to_surface)
{
	{
		float msl_attenuation = 1.0;
		if (msl_distance_falloff_exponent > (float(0)))
		{
			msl_attenuation = (pow((msl__state_light_distance * msl_distance_scale), (-msl_distance_falloff_exponent)));
		}
		float msl_locationSpread = min(1.0, (dot(msl__state_light_to_surface, msl__state_light_direction)));
		if (msl_locationSpread < msl__state_light_spread_cos)
		{
			msl_result = 0.0;
		}
		else
		{
			float msl_sf;
			float msl_locationSpreadRadians = acos(msl_locationSpread);
			float msl_light_spread_innerRadians = radians(msl_light_spread_inner);
			if (msl_locationSpreadRadians < msl_light_spread_innerRadians)
			{
				msl_sf = 1.0;
			}
			else
			{
				msl_sf = (pow(((float(1)) - ((saturate((msl_locationSpreadRadians - msl_light_spread_innerRadians))) / (msl__state_light_spread - msl_light_spread_innerRadians))), msl_light_spread_falloff));
			}
			msl_result = (float4((((((float4(msl_color)) * msl_intensity) * msl_attenuation) * msl_sf) * (float(msl_enabled)))));
		}
		msl_light_shadow = (float4(1,1,1,1));
	}
}

void Light_spot_1_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float msl__state_light_spread,
	in float msl__state_light_spread_cos,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_spot_1_result;
	float4 msl_Light_spot_1_light_shadow;
	Light_spot_main(state, Spot1_Enabled, msl_Light_spot_1_color, msl_Light_spot_1_intensity, msl_Light_spot_1_distance_falloff_exponent, msl_Light_spot_1_distance_scale, msl_Light_spot_1_light_spread_inner, msl_Light_spot_1_light_spread_falloff, msl_Light_spot_1_result, msl_Light_spot_1_light_shadow, msl__state_light_direction, msl__state_transform_internal_to_light, msl__state_light_spread_cos, msl__state_light_distance, msl__state_transform_light_to_internal, msl__state_light_spread, msl__state_light_to_surface);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_spot_1_result;
	msl___light.msl_contribution = msl_Light_spot_1_result;
	msl___light.msl_shadow = msl_Light_spot_1_light_shadow;
	msl___light.msl_count = 1;
}

void Light_spot_2_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float msl__state_light_spread,
	in float msl__state_light_spread_cos,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_spot_2_result;
	float4 msl_Light_spot_2_light_shadow;
	Light_spot_main(state, Spot2_Enabled, msl_Light_spot_2_color, msl_Light_spot_2_intensity, msl_Light_spot_2_distance_falloff_exponent, msl_Light_spot_2_distance_scale, msl_Light_spot_2_light_spread_inner, msl_Light_spot_2_light_spread_falloff, msl_Light_spot_2_result, msl_Light_spot_2_light_shadow, msl__state_light_direction, msl__state_transform_internal_to_light, msl__state_light_spread_cos, msl__state_light_distance, msl__state_transform_light_to_internal, msl__state_light_spread, msl__state_light_to_surface);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_spot_2_result;
	msl___light.msl_contribution = msl_Light_spot_2_result;
	msl___light.msl_shadow = msl_Light_spot_2_light_shadow;
	msl___light.msl_count = 1;
}

void Light_spot_3_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float msl__state_light_spread,
	in float msl__state_light_spread_cos,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_spot_3_result;
	float4 msl_Light_spot_3_light_shadow;
	Light_spot_main(state, Spot3_Enabled, msl_Light_spot_3_color, msl_Light_spot_3_intensity, msl_Light_spot_3_distance_falloff_exponent, msl_Light_spot_3_distance_scale, msl_Light_spot_3_light_spread_inner, msl_Light_spot_3_light_spread_falloff, msl_Light_spot_3_result, msl_Light_spot_3_light_shadow, msl__state_light_direction, msl__state_transform_internal_to_light, msl__state_light_spread_cos, msl__state_light_distance, msl__state_transform_light_to_internal, msl__state_light_spread, msl__state_light_to_surface);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_spot_3_result;
	msl___light.msl_contribution = msl_Light_spot_3_result;
	msl___light.msl_shadow = msl_Light_spot_3_light_shadow;
	msl___light.msl_count = 1;
}

void Light_spot_4_lightmain(
	inout State state,
	in float3 msl__state_light_position,
	in float3 msl__state_light_direction,
	in float msl__state_light_spread,
	in float msl__state_light_spread_cos,
	in float4x4 msl__state_transform_internal_to_light,
	in float4x4 msl__state_transform_light_to_internal,
	out Light_iterator msl___light)
{
	float3 msl__state_light_to_surface = (state.position) - msl__state_light_position;
	float msl__state_light_distance = length(msl__state_light_to_surface);
	msl__state_light_to_surface /= msl__state_light_distance;
	float msl__state_light_dot_nl = dot((-msl__state_light_to_surface), (state.normal));
	float4 msl_Light_spot_4_result;
	float4 msl_Light_spot_4_light_shadow;
	Light_spot_main(state, Spot4_Enabled, msl_Light_spot_4_color, msl_Light_spot_4_intensity, msl_Light_spot_4_distance_falloff_exponent, msl_Light_spot_4_distance_scale, msl_Light_spot_4_light_spread_inner, msl_Light_spot_4_light_spread_falloff, msl_Light_spot_4_result, msl_Light_spot_4_light_shadow, msl__state_light_direction, msl__state_transform_internal_to_light, msl__state_light_spread_cos, msl__state_light_distance, msl__state_transform_light_to_internal, msl__state_light_spread, msl__state_light_to_surface);
	msl___light.msl_point = msl__state_light_position;
	msl___light.msl_direction = (-msl__state_light_to_surface);
	msl___light.msl_distance = msl__state_light_distance;
	msl___light.msl_dot_nl = msl__state_light_dot_nl;
	msl___light.msl_raw_contribution = msl_Light_spot_4_result;
	msl___light.msl_contribution = msl_Light_spot_4_result;
	msl___light.msl_shadow = msl_Light_spot_4_light_shadow;
	msl___light.msl_count = 1;
}

void kostasShader01_Ext_lambert_half_main(
	inout State state,
	float4 msl_diffuse,
	out float4 msl_result)
{
	{
		Light_iterator msl_light;
		{
			Light_directional_1_lightmain(state, Ignore_Me_Dir1Pos, Directional1_Direction, msl_light0_transform_internal_to_light, msl_light0_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_directional_2_lightmain(state, Ignore_Me_Dir2Pos, Directional2_Direction, msl_light1_transform_internal_to_light, msl_light1_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_directional_3_lightmain(state, Ignore_Me_Dir3Pos, Directional3_Direction, msl_light2_transform_internal_to_light, msl_light2_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_point_1_lightmain(state, Point1_Position, msl_light3_transform_internal_to_light, msl_light3_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_point_2_lightmain(state, Point2_Position, msl_light4_transform_internal_to_light, msl_light4_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_point_3_lightmain(state, Point3_Position, msl_light5_transform_internal_to_light, msl_light5_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_point_4_lightmain(state, Point4_Position, msl_light6_transform_internal_to_light, msl_light6_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_spot_1_lightmain(state, Spot1_Position, Spot1_Direction, Spot1_Spread, Spot1_Spread_Cos, msl_light7_transform_internal_to_light, msl_light7_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_spot_2_lightmain(state, Spot2_Position, Spot2_Direction, Spot2_Spread, Spot2_Spread_Cos, msl_light8_transform_internal_to_light, msl_light8_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_spot_3_lightmain(state, Spot3_Position, Spot3_Direction, Spot3_Spread, Spot3_Spread_Cos, msl_light9_transform_internal_to_light, msl_light9_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
			Light_spot_4_lightmain(state, Spot4_Position, Spot4_Direction, Spot4_Spread, Spot4_Spread_Cos, msl_light10_transform_internal_to_light, msl_light10_transform_light_to_internal, msl_light);
			{
				msl_result += (float4((((float4(msl_diffuse)) * (max((((msl_light.msl_dot_nl * 0.5) + 0.5) * ((msl_light.msl_dot_nl * 0.5) + 0.5)), 0.0))) * (float4(msl_light.msl_contribution)))));
			}
		}
		msl_result /= 3.14159265358979323846f;
		msl_result += (float4(((float4((__scene_ambient))) * (float4(msl_diffuse)))));
		msl_result.a = msl_diffuse.a;
	}
}

void kostasShader01_SpecularGlossControl_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_SpecularGlossControl_Conversion_color_to_float_main(
	inout State state,
	float4 msl_color,
	out float msl_scalar)
{
	{
		msl_scalar = (((msl_color.r + msl_color.g) + msl_color.b) / 3.0);
	}
}

void kostasShader01_SpecularGlossControl_Math_float_add_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left + msl_right);
	}
}

void kostasShader01_SpecularGlossControl_Math_float_conditional_main(
	inout State state,
	bool msl_condition,
	float msl_true_value,
	float msl_false_value,
	out float msl_result)
{
	{
		msl_result = (msl_condition ? msl_true_value : msl_false_value);
	}
}

void kostasShader01_SpecularGlossControl_Math_float_multiply_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left * msl_right);
	}
}

void kostasShader01_SpecularGlossControl_main(
	inout State state,
	float msl_SpecularGlossFactor,
	sampler2D msl_SpecularGlossTexture,
	float2 msl_texture_uv,
	float msl_defaultIfTextureNotLoaded,
	bool msl_UseSpecularGlossTexture,
	out float msl_SpecularGloss)
{
	{
		float4 msl_SpecularGlossTexture_result;
		kostasShader01_SpecularGlossControl_Texture_lookup_2d_main(state, msl_SpecularGlossTexture, 0, msl_texture_uv, msl_SpecularGlossTexture_result);
		float msl_Conversion_color_to_float_3_scalar;
		kostasShader01_SpecularGlossControl_Conversion_color_to_float_main(state, msl_SpecularGlossTexture_result, msl_Conversion_color_to_float_3_scalar);
		float msl_Math_float_add_6_result;
		kostasShader01_SpecularGlossControl_Math_float_add_main(state, msl_Conversion_color_to_float_3_scalar, 0.030000, msl_Math_float_add_6_result);
		float msl_Math_float_conditional_3_result;
		kostasShader01_SpecularGlossControl_Math_float_conditional_main(state, msl_UseSpecularGlossTexture, msl_Math_float_add_6_result, msl_defaultIfTextureNotLoaded, msl_Math_float_conditional_3_result);
		float msl_Math_float_multiply_4_result;
		kostasShader01_SpecularGlossControl_Math_float_multiply_main(state, msl_Math_float_conditional_3_result, msl_SpecularGlossFactor, msl_Math_float_multiply_4_result);
		float msl_Math_float_multiply_2_result;
		kostasShader01_SpecularGlossControl_Math_float_multiply_main(state, msl_Math_float_multiply_4_result, 100.000000, msl_Math_float_multiply_2_result);
		float msl_Math_float_add_3_result;
		kostasShader01_SpecularGlossControl_Math_float_add_main(state, msl_Math_float_multiply_2_result, 2.000000, msl_Math_float_add_3_result);
		msl_SpecularGloss = msl_Math_float_add_3_result;
	}
}

void kostasShader01_Component_phong_main(
	inout State state,
	float4 msl_col,
	float msl_specular_shininess,
	out float4 msl_diffuse,
	out float4 msl_specular)
{
	{
		msl_diffuse = (float4((float(0)), (float(0)), (float(0)), (float(0))));
		msl_specular = (float4((float(0)), (float(0)), (float(0)), (float(0))));
		float3 msl_vdir = state.direction;
		Light_iterator msl_light;
		{
			Light_directional_1_lightmain(state, Ignore_Me_Dir1Pos, Directional1_Direction, msl_light0_transform_internal_to_light, msl_light0_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_directional_2_lightmain(state, Ignore_Me_Dir2Pos, Directional2_Direction, msl_light1_transform_internal_to_light, msl_light1_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_directional_3_lightmain(state, Ignore_Me_Dir3Pos, Directional3_Direction, msl_light2_transform_internal_to_light, msl_light2_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_point_1_lightmain(state, Point1_Position, msl_light3_transform_internal_to_light, msl_light3_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_point_2_lightmain(state, Point2_Position, msl_light4_transform_internal_to_light, msl_light4_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_point_3_lightmain(state, Point3_Position, msl_light5_transform_internal_to_light, msl_light5_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_point_4_lightmain(state, Point4_Position, msl_light6_transform_internal_to_light, msl_light6_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_spot_1_lightmain(state, Spot1_Position, Spot1_Direction, Spot1_Spread, Spot1_Spread_Cos, msl_light7_transform_internal_to_light, msl_light7_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_spot_2_lightmain(state, Spot2_Position, Spot2_Direction, Spot2_Spread, Spot2_Spread_Cos, msl_light8_transform_internal_to_light, msl_light8_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_spot_3_lightmain(state, Spot3_Position, Spot3_Direction, Spot3_Spread, Spot3_Spread_Cos, msl_light9_transform_internal_to_light, msl_light9_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
			Light_spot_4_lightmain(state, Spot4_Position, Spot4_Direction, Spot4_Spread, Spot4_Spread_Cos, msl_light10_transform_internal_to_light, msl_light10_transform_light_to_internal, msl_light);
			{
				float msl_cos = saturate(msl_light.msl_dot_nl);
				if (msl_cos > 0.0)
				{
					msl_diffuse += (float4((((msl_cos / 3.14159265358979323846f) * (float4(msl_light.msl_contribution))) * (float4(msl_col)))));
					float msl_s = mi_phong_specular(state, msl_light.msl_direction, msl_vdir, (state.normal), msl_specular_shininess);
					msl_specular += (float4(((msl_s * msl_cos) * (float4(msl_light.msl_contribution)))));
				}
			}
		}
		
		;
		msl_diffuse += (float4(((1.0 / 3.14159265358979323846f) * (float4((__scene_ambient))))));
		msl_diffuse.a = 1.0;
		msl_specular.a = 1.0;
	}
}

void kostasShader01_Math_color_conditional_main(
	inout State state,
	bool msl_condition,
	float4 msl_true_value,
	float4 msl_false_value,
	out float4 msl_result)
{
	{
		msl_result = (msl_condition ? msl_true_value : msl_false_value);
	}
}

void kostasShader01_Ambient_Occlusion_Component_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_Ambient_Occlusion_Component_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_Ambient_Occlusion_Component_Math_color_lerp_main(
	inout State state,
	float4 msl_start,
	float4 msl_end,
	float4 msl_location,
	out float4 msl_result)
{
	{
		msl_result = (float4((lerp((float4(msl_start)), (float4(msl_end)), (float4(msl_location))))));
	}
}

void kostasShader01_Ambient_Occlusion_Component_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void kostasShader01_Ambient_Occlusion_Component_State_normal_main(
	inout State state,
	out float3 msl_result)
{
	{
		msl_result = (state.normal);
	}
}

void kostasShader01_Ambient_Occlusion_Component_Transform_internal_to_world_normal_main(
	inout State state,
	float3 msl_norm,
	out float3 msl_result)
{
	{
		msl_result = (mul(msl_norm, (float3x3)__world_to_camera));
	}
}

void kostasShader01_Ambient_Occlusion_Component_Conversion_float3_to_floats_main(
	inout State state,
	float3 msl_vector,
	out float msl_x,
	out float msl_y,
	out float msl_z)
{
	{
		msl_x = msl_vector.x;
		msl_y = msl_vector.y;
		msl_z = msl_vector.z;
	}
}

void kostasShader01_Ambient_Occlusion_Component_Conversion_floats_to_float3_main(
	inout State state,
	float msl_x,
	float msl_y,
	float msl_z,
	out float3 msl_result)
{
	{
		msl_result = (float3(msl_x, msl_y, msl_z));
	}
}

void kostasShader01_Ambient_Occlusion_Component_Texture_lookup_cube_main(
	inout State state,
	samplerCUBE msl_texture,
	int msl_texture_space,
	float3 msl_texture_uvw,
	out float4 msl_result)
{
	{
		msl_result = (texCUBE(msl_texture, msl_texture_uvw.xzy));
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float3_to_color_main(
	inout State state,
	float3 msl_vector,
	out float4 msl_result)
{
	{
		msl_result.x = msl_vector.x;
		msl_result.y = msl_vector.y;
		msl_result.z = msl_vector.z;
		msl_result.w = 1.0;
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_State_normal_main(
	inout State state,
	out float3 msl_result)
{
	{
		msl_result = (state.normal);
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Transform_internal_to_world_normal_main(
	inout State state,
	float3 msl_norm,
	out float3 msl_result)
{
	{
		msl_result = (mul(msl_norm, (float3x3)__world_to_camera));
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float3_to_floats_main(
	inout State state,
	float3 msl_vector,
	out float msl_x,
	out float msl_y,
	out float msl_z)
{
	{
		msl_x = msl_vector.x;
		msl_y = msl_vector.y;
		msl_z = msl_vector.z;
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Math_float_add_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left + msl_right);
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Math_float_multiply_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left * msl_right);
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Ext_scalar_compress_level_main(
	inout State state,
	float msl_input,
	float msl_compress_factor,
	float msl_compress_center,
	bool msl_clamp_result,
	out float msl_result)
{
	{
		float msl_range = ((float(1)) - msl_compress_factor) / 2.0;
		float msl_tmp_min = msl_compress_center - msl_range;
		msl_range = ((msl_range == 0.0) ? 0.001 : msl_range);
		msl_result = ((msl_input - msl_tmp_min) / ((float(2)) * msl_range));
		if (msl_clamp_result == true)
		{
			msl_result = (saturate(msl_result));
		}
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Math_color_lerp_main(
	inout State state,
	float4 msl_start,
	float4 msl_end,
	float4 msl_location,
	out float4 msl_result)
{
	{
		msl_result = (float4((lerp((float4(msl_start)), (float4(msl_end)), (float4(msl_location))))));
	}
}

void kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_main(
	inout State state,
	float3 msl_HemiNormalInput,
	float3 msl_HemiSkyColor,
	float3 msl_HemiGroundColor,
	out float4 msl_result)
{
	{
		float4 msl_Conversion_float3_to_color_1_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float3_to_color_main(state, msl_HemiGroundColor, msl_Conversion_float3_to_color_1_result);
		float4 msl_Conversion_float3_to_color_4_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float3_to_color_main(state, msl_HemiSkyColor, msl_Conversion_float3_to_color_4_result);
		float3 msl_State_normal_1_result;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_HemiNormalInput;
			kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_State_normal_main(state, msl_State_normal_1_result);
			(state.normal) = msl__normal_temp;
		}
		float3 msl_Transform_internal_to_world_normal_1_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Transform_internal_to_world_normal_main(state, msl_State_normal_1_result, msl_Transform_internal_to_world_normal_1_result);
		float msl_Conversion_float3_to_floats_1_x;
		float msl_Conversion_float3_to_floats_1_y;
		float msl_Conversion_float3_to_floats_1_z;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float3_to_floats_main(state, msl_Transform_internal_to_world_normal_1_result, msl_Conversion_float3_to_floats_1_x, msl_Conversion_float3_to_floats_1_y, msl_Conversion_float3_to_floats_1_z);
		float msl_Math_float_add_1_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Math_float_add_main(state, msl_Conversion_float3_to_floats_1_y, 1.0, msl_Math_float_add_1_result);
		float msl_Math_float_multiply_1_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Math_float_multiply_main(state, msl_Math_float_add_1_result, 0.500000, msl_Math_float_multiply_1_result);
		float msl_Ext_scalar_compress_level_1_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Ext_scalar_compress_level_main(state, msl_Math_float_multiply_1_result, 0.700000, 0.500000, true, msl_Ext_scalar_compress_level_1_result);
		float4 msl_Conversion_float_to_color_1_color;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Conversion_float_to_color_main(state, msl_Ext_scalar_compress_level_1_result, msl_Conversion_float_to_color_1_color);
		float4 msl_Math_color_lerp_1_result;
		kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_Math_color_lerp_main(state, msl_Conversion_float3_to_color_1_result, msl_Conversion_float3_to_color_4_result, msl_Conversion_float_to_color_1_color, msl_Math_color_lerp_1_result);
		msl_result = msl_Math_color_lerp_1_result;
	}
}

void kostasShader01_Ambient_Occlusion_Component_Conversion_float3_to_color_main(
	inout State state,
	float3 msl_vector,
	out float4 msl_result)
{
	{
		msl_result.x = msl_vector.x;
		msl_result.y = msl_vector.y;
		msl_result.z = msl_vector.z;
		msl_result.w = 1.0;
	}
}

void kostasShader01_Ambient_Occlusion_Component_Math_color_conditional_main(
	inout State state,
	bool msl_condition,
	float4 msl_true_value,
	float4 msl_false_value,
	out float4 msl_result)
{
	{
		msl_result = (msl_condition ? msl_true_value : msl_false_value);
	}
}

void kostasShader01_Ambient_Occlusion_Component_main(
	inout State state,
	float msl_AmbientLightAmount,
	sampler2D msl_AOTexture,
	samplerCUBE msl_EnvAmbientTexture,
	bool msl_UseAmbientEnvironmentTexture,
	float3 msl_NormalMapInput,
	float msl_AO_Amount,
	float2 msl_texture_uv,
	bool msl_UseHemiColoring,
	float3 msl_HemiGroundColor,
	float3 msl_HemiSkyColor,
	float3 msl_Ambient_Color,
	out float4 msl_result)
{
	{
		float4 msl_Texture_lookup_2d_2_result;
		kostasShader01_Ambient_Occlusion_Component_Texture_lookup_2d_main(state, msl_AOTexture, 0, msl_texture_uv, msl_Texture_lookup_2d_2_result);
		float4 msl_Conversion_float_to_color_2_color;
		kostasShader01_Ambient_Occlusion_Component_Conversion_float_to_color_main(state, msl_AO_Amount, msl_Conversion_float_to_color_2_color);
		float4 msl_Math_color_lerp_3_result;
		kostasShader01_Ambient_Occlusion_Component_Math_color_lerp_main(state, (float4(1.0, 1.0, 1.0, 1.0)), msl_Texture_lookup_2d_2_result, msl_Conversion_float_to_color_2_color, msl_Math_color_lerp_3_result);
		float4 msl_Conversion_float_to_color_1_color;
		kostasShader01_Ambient_Occlusion_Component_Conversion_float_to_color_main(state, msl_AmbientLightAmount, msl_Conversion_float_to_color_1_color);
		float4 msl_Math_color_multiply_1_result;
		kostasShader01_Ambient_Occlusion_Component_Math_color_multiply_main(state, msl_Math_color_lerp_3_result, msl_Conversion_float_to_color_1_color, msl_Math_color_multiply_1_result);
		float3 msl_State_normal_1_result;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_NormalMapInput;
			kostasShader01_Ambient_Occlusion_Component_State_normal_main(state, msl_State_normal_1_result);
			(state.normal) = msl__normal_temp;
		}
		float3 msl_Transform_internal_to_world_normal_1_result;
		kostasShader01_Ambient_Occlusion_Component_Transform_internal_to_world_normal_main(state, msl_State_normal_1_result, msl_Transform_internal_to_world_normal_1_result);
		float msl_Conversion_float3_to_floats_1_x;
		float msl_Conversion_float3_to_floats_1_y;
		float msl_Conversion_float3_to_floats_1_z;
		kostasShader01_Ambient_Occlusion_Component_Conversion_float3_to_floats_main(state, msl_Transform_internal_to_world_normal_1_result, msl_Conversion_float3_to_floats_1_x, msl_Conversion_float3_to_floats_1_y, msl_Conversion_float3_to_floats_1_z);
		float3 msl_Conversion_floats_to_float3_1_result;
		kostasShader01_Ambient_Occlusion_Component_Conversion_floats_to_float3_main(state, msl_Conversion_float3_to_floats_1_x, msl_Conversion_float3_to_floats_1_z, msl_Conversion_float3_to_floats_1_y, msl_Conversion_floats_to_float3_1_result);
		float4 msl_Texture_lookup_cube_1_result;
		kostasShader01_Ambient_Occlusion_Component_Texture_lookup_cube_main(state, msl_EnvAmbientTexture, 0, msl_Conversion_floats_to_float3_1_result, msl_Texture_lookup_cube_1_result);
		float4 msl_HemisphericColoring_1_result;
		{
			float3 msl__normal_temp = state.normal;
			kostasShader01_Ambient_Occlusion_Component_HemisphericColoring_main(state, msl_NormalMapInput, msl_HemiGroundColor, msl_HemiSkyColor, msl_HemisphericColoring_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_Conversion_float3_to_color_5_result;
		kostasShader01_Ambient_Occlusion_Component_Conversion_float3_to_color_main(state, msl_Ambient_Color, msl_Conversion_float3_to_color_5_result);
		float4 msl_Math_color_conditional_3_result;
		kostasShader01_Ambient_Occlusion_Component_Math_color_conditional_main(state, msl_UseHemiColoring, msl_HemisphericColoring_1_result, msl_Conversion_float3_to_color_5_result, msl_Math_color_conditional_3_result);
		float4 msl_Math_color_conditional_2_result;
		kostasShader01_Ambient_Occlusion_Component_Math_color_conditional_main(state, msl_UseAmbientEnvironmentTexture, msl_Texture_lookup_cube_1_result, msl_Math_color_conditional_3_result, msl_Math_color_conditional_2_result);
		float4 msl_Math_color_multiply_2_result;
		kostasShader01_Ambient_Occlusion_Component_Math_color_multiply_main(state, msl_Math_color_multiply_1_result, msl_Math_color_conditional_2_result, msl_Math_color_multiply_2_result);
		msl_result = msl_Math_color_multiply_2_result;
	}
}

void kostasShader01_WarpedDiffuse_Layer_color_main(
	inout State state,
	float4 msl_foreground,
	float4 msl_background,
	out float4 msl_result)
{
	{
		float4 msl_hsvf, msl_hsvb;
		msl_hsvf = (rgb_to_hsv(state, msl_foreground));
		msl_hsvb = (rgb_to_hsv(state, msl_background));
		msl_hsvf.rg = msl_hsvb.rg;
		msl_result = (hsv_to_rgb(state, msl_hsvf));
	}
}

void kostasShader01_WarpedDiffuse_Conversion_color_to_floats_main(
	inout State state,
	float4 msl_color,
	out float msl_r,
	out float msl_g,
	out float msl_b,
	out float msl_a)
{
	{
		msl_r = msl_color.r;
		msl_g = msl_color.g;
		msl_b = msl_color.b;
		msl_a = msl_color.a;
	}
}

void kostasShader01_WarpedDiffuse_Math_float_max_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (max(msl_left, msl_right));
	}
}

void kostasShader01_WarpedDiffuse_Conversion_floats_to_float2_main(
	inout State state,
	float msl_x,
	float msl_y,
	out float2 msl_result)
{
	{
		msl_result = (float2(msl_x, msl_y));
	}
}

void kostasShader01_WarpedDiffuse_Math_float2_min_main(
	inout State state,
	float2 msl_left,
	float2 msl_right,
	out float2 msl_result)
{
	{
		msl_result = (min(msl_left, msl_right));
	}
}

void kostasShader01_WarpedDiffuse_Math_float2_max_main(
	inout State state,
	float2 msl_left,
	float2 msl_right,
	out float2 msl_result)
{
	{
		msl_result = (max(msl_left, msl_right));
	}
}

void kostasShader01_WarpedDiffuse_Conversion_float2_to_floats_main(
	inout State state,
	float2 msl_vector,
	out float msl_x,
	out float msl_y)
{
	{
		msl_x = msl_vector.x;
		msl_y = msl_vector.y;
	}
}

void kostasShader01_WarpedDiffuse_Math_float_invert_main(
	inout State state,
	float msl_scalar,
	out float msl_result)
{
	{
		msl_result = ((float(1)) - msl_scalar);
	}
}

void kostasShader01_WarpedDiffuse_Conversion_bool_to_int_main(
	inout State state,
	bool msl_boolean,
	out int msl_integer)
{
	{
		if (msl_boolean)
		{
			msl_integer = 1;
		}
		else
		{
			msl_integer = 0;
		}
	}
}

void kostasShader01_WarpedDiffuse_Conversion_int_to_float_main(
	inout State state,
	int msl_integer,
	out float msl_scalar)
{
	{
		msl_scalar = (float(msl_integer));
	}
}

void kostasShader01_WarpedDiffuse_Math_float_lerp_main(
	inout State state,
	float msl_start,
	float msl_end,
	float msl_location,
	out float msl_result)
{
	{
		msl_result = (lerp(msl_start, msl_end, msl_location));
	}
}

void kostasShader01_WarpedDiffuse_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_WarpedDiffuse_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void kostasShader01_WarpedDiffuse_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_WarpedDiffuse_Math_color_lerp_main(
	inout State state,
	float4 msl_start,
	float4 msl_end,
	float4 msl_location,
	out float4 msl_result)
{
	{
		msl_result = (float4((lerp((float4(msl_start)), (float4(msl_end)), (float4(msl_location))))));
	}
}

void kostasShader01_WarpedDiffuse_Math_color_add_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) + (float4(msl_right)))));
	}
}

void kostasShader01_WarpedDiffuse_main(
	inout State state,
	float4 msl_DiffuseInput,
	sampler2D msl_DiffuseWarpRamp,
	bool msl_UseDiffuseWarpRamp,
	bool msl_DiffuseWarpRampInvert,
	float4 msl_AmbientLightInput,
	out float4 msl_result)
{
	{
		float4 msl_Layer_color_1_result;
		kostasShader01_WarpedDiffuse_Layer_color_main(state, (float4(1.0, 1.0, 1.0, 0.0)), msl_DiffuseInput, msl_Layer_color_1_result);
		float msl_Conversion_color_to_floats_1_r;
		float msl_Conversion_color_to_floats_1_g;
		float msl_Conversion_color_to_floats_1_b;
		float msl_Conversion_color_to_floats_1_a;
		kostasShader01_WarpedDiffuse_Conversion_color_to_floats_main(state, msl_DiffuseInput, msl_Conversion_color_to_floats_1_r, msl_Conversion_color_to_floats_1_g, msl_Conversion_color_to_floats_1_b, msl_Conversion_color_to_floats_1_a);
		float msl_Math_float_max_1_result;
		kostasShader01_WarpedDiffuse_Math_float_max_main(state, msl_Conversion_color_to_floats_1_r, msl_Conversion_color_to_floats_1_g, msl_Math_float_max_1_result);
		float msl_Math_float_max_2_result;
		kostasShader01_WarpedDiffuse_Math_float_max_main(state, msl_Math_float_max_1_result, msl_Conversion_color_to_floats_1_b, msl_Math_float_max_2_result);
		float2 msl_Conversion_floats_to_float2_2_result;
		kostasShader01_WarpedDiffuse_Conversion_floats_to_float2_main(state, msl_Math_float_max_2_result, msl_Math_float_max_2_result, msl_Conversion_floats_to_float2_2_result);
		float2 msl_Math_float2_min_1_result;
		kostasShader01_WarpedDiffuse_Math_float2_min_main(state, msl_Conversion_floats_to_float2_2_result, (float2(0.950000, 0.950000)), msl_Math_float2_min_1_result);
		float2 msl_Math_float2_max_1_result;
		kostasShader01_WarpedDiffuse_Math_float2_max_main(state, msl_Math_float2_min_1_result, (float2(0.050000, 0.050000)), msl_Math_float2_max_1_result);
		float msl_Conversion_float2_to_floats_1_x;
		float msl_Conversion_float2_to_floats_1_y;
		kostasShader01_WarpedDiffuse_Conversion_float2_to_floats_main(state, msl_Math_float2_max_1_result, msl_Conversion_float2_to_floats_1_x, msl_Conversion_float2_to_floats_1_y);
		float msl_Math_float_invert_3_result;
		kostasShader01_WarpedDiffuse_Math_float_invert_main(state, msl_Conversion_float2_to_floats_1_y, msl_Math_float_invert_3_result);
		int msl_Conversion_bool_to_int_8_integer;
		kostasShader01_WarpedDiffuse_Conversion_bool_to_int_main(state, msl_DiffuseWarpRampInvert, msl_Conversion_bool_to_int_8_integer);
		float msl_Conversion_int_to_float_8_scalar;
		kostasShader01_WarpedDiffuse_Conversion_int_to_float_main(state, msl_Conversion_bool_to_int_8_integer, msl_Conversion_int_to_float_8_scalar);
		float msl_Math_float_lerp_4_result;
		kostasShader01_WarpedDiffuse_Math_float_lerp_main(state, msl_Conversion_float2_to_floats_1_y, msl_Math_float_invert_3_result, msl_Conversion_int_to_float_8_scalar, msl_Math_float_lerp_4_result);
		float2 msl_Conversion_floats_to_float2_3_result;
		kostasShader01_WarpedDiffuse_Conversion_floats_to_float2_main(state, msl_Conversion_float2_to_floats_1_x, msl_Math_float_lerp_4_result, msl_Conversion_floats_to_float2_3_result);
		float4 msl_Texture_lookup_2d_4_result;
		kostasShader01_WarpedDiffuse_Texture_lookup_2d_main(state, msl_DiffuseWarpRamp, 0, msl_Conversion_floats_to_float2_3_result, msl_Texture_lookup_2d_4_result);
		float4 msl_Math_color_multiply_9_result;
		kostasShader01_WarpedDiffuse_Math_color_multiply_main(state, msl_Layer_color_1_result, msl_Texture_lookup_2d_4_result, msl_Math_color_multiply_9_result);
		int msl_Conversion_bool_to_int_7_integer;
		kostasShader01_WarpedDiffuse_Conversion_bool_to_int_main(state, msl_UseDiffuseWarpRamp, msl_Conversion_bool_to_int_7_integer);
		float msl_Conversion_int_to_float_7_scalar;
		kostasShader01_WarpedDiffuse_Conversion_int_to_float_main(state, msl_Conversion_bool_to_int_7_integer, msl_Conversion_int_to_float_7_scalar);
		float4 msl_Conversion_float_to_color_7_color;
		kostasShader01_WarpedDiffuse_Conversion_float_to_color_main(state, msl_Conversion_int_to_float_7_scalar, msl_Conversion_float_to_color_7_color);
		float4 msl_Math_color_lerp_5_result;
		kostasShader01_WarpedDiffuse_Math_color_lerp_main(state, msl_DiffuseInput, msl_Math_color_multiply_9_result, msl_Conversion_float_to_color_7_color, msl_Math_color_lerp_5_result);
		float4 msl_Math_color_add_5_result;
		kostasShader01_WarpedDiffuse_Math_color_add_main(state, msl_AmbientLightInput, msl_Math_color_lerp_5_result, msl_Math_color_add_5_result);
		msl_result = msl_Math_color_add_5_result;
	}
}
void kostasShader01_Rim_Light_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_Rim_Light_Ext_edge_factor_main(
	inout State state,
	float msl_edge_factor,
	float msl_edge_weight,
	float msl_base_weight,
	out float msl_result_scal,
	out float4 msl_result_col)
{
	{
		float msl_edge_level = pow((1.0 + ((((dot(state.direction, state.normal))) < (float(0))) ? ((dot(state.direction, state.normal))) : (float(0)))), msl_edge_factor);
		msl_result_col = (msl_result_scal = ((msl_edge_weight * msl_edge_level) + (msl_base_weight * (1.0 - msl_edge_level))));
	}
}

void kostasShader01_Rim_Light_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void kostasShader01_Rim_Light_main(
	inout State state,
	float msl_edge_factor,
	float4 msl_Diffuse_Input,
	float msl_scalar,
	float3 msl_NormalInput,
	out float4 msl_result)
{
	{
		float4 msl_Conversion_float_to_color_11_color;
		kostasShader01_Rim_Light_Conversion_float_to_color_main(state, msl_scalar, msl_Conversion_float_to_color_11_color);
		float msl_Ext_edge_factor_1_result_scal;
		float4 msl_Ext_edge_factor_1_result_col;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_NormalInput;
			kostasShader01_Rim_Light_Ext_edge_factor_main(state, msl_edge_factor, 1.0, 0.0, msl_Ext_edge_factor_1_result_scal, msl_Ext_edge_factor_1_result_col);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_Math_color_multiply_10_result;
		kostasShader01_Rim_Light_Math_color_multiply_main(state, msl_Ext_edge_factor_1_result_col, msl_Diffuse_Input, msl_Math_color_multiply_10_result);
		float4 msl_Math_color_multiply_11_result;
		kostasShader01_Rim_Light_Math_color_multiply_main(state, msl_Conversion_float_to_color_11_color, msl_Math_color_multiply_10_result, msl_Math_color_multiply_11_result);
		msl_result = msl_Math_color_multiply_11_result;
	}
}

void kostasShader01_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_LightingFacingColorTint_Math_float_add_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left + msl_right);
	}
}

void kostasShader01_LightingFacingColorTint_Component_falloff_main(
	inout State state,
	float msl_amount,
	out float4 msl_result)
{
	{
		float msl_falloff = mi_falloff(state, (state.direction), (state.normal), msl_amount);
		msl_result = (float4(msl_falloff, msl_falloff, msl_falloff, 1.0));
	}
}

void kostasShader01_LightingFacingColorTint_Conversion_color_to_float_main(
	inout State state,
	float4 msl_color,
	out float msl_scalar)
{
	{
		msl_scalar = (((msl_color.r + msl_color.g) + msl_color.b) / 3.0);
	}
}

void kostasShader01_LightingFacingColorTint_Math_float_min_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (min(msl_left, msl_right));
	}
}

void kostasShader01_LightingFacingColorTint_Math_float_max_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (max(msl_left, msl_right));
	}
}

void kostasShader01_LightingFacingColorTint_Math_float_invert_main(
	inout State state,
	float msl_scalar,
	out float msl_result)
{
	{
		msl_result = ((float(1)) - msl_scalar);
	}
}

void kostasShader01_LightingFacingColorTint_Conversion_bool_to_int_main(
	inout State state,
	bool msl_boolean,
	out int msl_integer)
{
	{
		if (msl_boolean)
		{
			msl_integer = 1;
		}
		else
		{
			msl_integer = 0;
		}
	}
}

void kostasShader01_LightingFacingColorTint_Conversion_int_to_float_main(
	inout State state,
	int msl_integer,
	out float msl_scalar)
{
	{
		msl_scalar = (float(msl_integer));
	}
}

void kostasShader01_LightingFacingColorTint_Math_float_lerp_main(
	inout State state,
	float msl_start,
	float msl_end,
	float msl_location,
	out float msl_result)
{
	{
		msl_result = (lerp(msl_start, msl_end, msl_location));
	}
}

void kostasShader01_LightingFacingColorTint_Math_float_multiply_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left * msl_right);
	}
}

void kostasShader01_LightingFacingColorTint_Conversion_floats_to_float2_main(
	inout State state,
	float msl_x,
	float msl_y,
	out float2 msl_result)
{
	{
		msl_result = (float2(msl_x, msl_y));
	}
}

void kostasShader01_LightingFacingColorTint_Texture_coordinate_2d_offset_main(
	inout State state,
	int msl_texture_space,
	float2 msl_texture_uv,
	float msl_offset_u,
	float msl_offset_v,
	out float2 msl_result)
{
	{
		msl_result.x = (msl_texture_uv.x + msl_offset_u);
		msl_result.y = (msl_texture_uv.y + msl_offset_v);
	}
}

void kostasShader01_LightingFacingColorTint_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_LightingFacingColorTint_main(
	inout State state,
	sampler2D msl_TintRampTexture,
	float msl_OffsetU,
	float msl_OffsetV,
	float4 msl_DiffuseInput,
	bool msl_TintRampInvertV,
	bool msl_TintRampInvertU,
	out float4 msl_result)
{
	{
		float msl_Math_float_add_1_result;
		kostasShader01_LightingFacingColorTint_Math_float_add_main(state, msl_OffsetU, 1.0, msl_Math_float_add_1_result);
		float4 msl_Component_falloff_1_result;
		kostasShader01_LightingFacingColorTint_Component_falloff_main(state, msl_Math_float_add_1_result, msl_Component_falloff_1_result);
		float msl_Conversion_color_to_float_2_scalar;
		kostasShader01_LightingFacingColorTint_Conversion_color_to_float_main(state, msl_Component_falloff_1_result, msl_Conversion_color_to_float_2_scalar);
		float msl_Error_Margin_Min_1_result;
		kostasShader01_LightingFacingColorTint_Math_float_min_main(state, msl_Conversion_color_to_float_2_scalar, 0.980000, msl_Error_Margin_Min_1_result);
		float msl_Error_Margin_Max_1_result;
		kostasShader01_LightingFacingColorTint_Math_float_max_main(state, msl_Error_Margin_Min_1_result, 0.080000, msl_Error_Margin_Max_1_result);
		float msl_Math_float_invert_1_result;
		kostasShader01_LightingFacingColorTint_Math_float_invert_main(state, msl_Error_Margin_Max_1_result, msl_Math_float_invert_1_result);
		int msl_Conversion_bool_to_int_6_integer;
		kostasShader01_LightingFacingColorTint_Conversion_bool_to_int_main(state, msl_TintRampInvertU, msl_Conversion_bool_to_int_6_integer);
		float msl_Conversion_int_to_float_1_scalar;
		kostasShader01_LightingFacingColorTint_Conversion_int_to_float_main(state, msl_Conversion_bool_to_int_6_integer, msl_Conversion_int_to_float_1_scalar);
		float msl_Math_float_lerp_1_result;
		kostasShader01_LightingFacingColorTint_Math_float_lerp_main(state, msl_Error_Margin_Max_1_result, msl_Math_float_invert_1_result, msl_Conversion_int_to_float_1_scalar, msl_Math_float_lerp_1_result);
		float msl_Math_float_add_2_result;
		kostasShader01_LightingFacingColorTint_Math_float_add_main(state, msl_OffsetV, 1.0, msl_Math_float_add_2_result);
		float msl_Conversion_color_to_float_1_scalar;
		kostasShader01_LightingFacingColorTint_Conversion_color_to_float_main(state, msl_DiffuseInput, msl_Conversion_color_to_float_1_scalar);
		float msl_Math_float_multiply_1_result;
		kostasShader01_LightingFacingColorTint_Math_float_multiply_main(state, msl_Math_float_add_2_result, msl_Conversion_color_to_float_1_scalar, msl_Math_float_multiply_1_result);
		float msl_Error_Margin_Min_result;
		kostasShader01_LightingFacingColorTint_Math_float_min_main(state, msl_Math_float_multiply_1_result, 0.980000, msl_Error_Margin_Min_result);
		float msl_Error_Margin_Max_result;
		kostasShader01_LightingFacingColorTint_Math_float_max_main(state, msl_Error_Margin_Min_result, 0.080000, msl_Error_Margin_Max_result);
		float msl_Math_float_invert_2_result;
		kostasShader01_LightingFacingColorTint_Math_float_invert_main(state, msl_Error_Margin_Max_result, msl_Math_float_invert_2_result);
		int msl_Conversion_bool_to_int_5_integer;
		kostasShader01_LightingFacingColorTint_Conversion_bool_to_int_main(state, msl_TintRampInvertV, msl_Conversion_bool_to_int_5_integer);
		float msl_Conversion_int_to_float_2_scalar;
		kostasShader01_LightingFacingColorTint_Conversion_int_to_float_main(state, msl_Conversion_bool_to_int_5_integer, msl_Conversion_int_to_float_2_scalar);
		float msl_Math_float_lerp_2_result;
		kostasShader01_LightingFacingColorTint_Math_float_lerp_main(state, msl_Error_Margin_Max_result, msl_Math_float_invert_2_result, msl_Conversion_int_to_float_2_scalar, msl_Math_float_lerp_2_result);
		float2 msl_Conversion_floats_to_float2_1_result;
		kostasShader01_LightingFacingColorTint_Conversion_floats_to_float2_main(state, msl_Math_float_lerp_1_result, msl_Math_float_lerp_2_result, msl_Conversion_floats_to_float2_1_result);
		float2 msl_Texture_coordinate_2d_offset_1_result;
		kostasShader01_LightingFacingColorTint_Texture_coordinate_2d_offset_main(state, 0, msl_Conversion_floats_to_float2_1_result, 0.0, 0.0, msl_Texture_coordinate_2d_offset_1_result);
		float4 msl_Texture_lookup_2d_1_result;
		kostasShader01_LightingFacingColorTint_Texture_lookup_2d_main(state, msl_TintRampTexture, 0, msl_Texture_coordinate_2d_offset_1_result, msl_Texture_lookup_2d_1_result);
		msl_result = msl_Texture_lookup_2d_1_result;
	}
}

void kostasShader01_Math_color_lerp_main(
	inout State state,
	float4 msl_start,
	float4 msl_end,
	float4 msl_location,
	out float4 msl_result)
{
	{
		msl_result = (float4((lerp((float4(msl_start)), (float4(msl_end)), (float4(msl_location))))));
	}
}

void kostasShader01_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void kostasShader01_Math_color_add_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) + (float4(msl_right)))));
	}
}

void kostasShader01_Reflections_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void Environment_map_cubic_main(
	inout State state,
	samplerCUBE msl_env_tex,
	float msl_intensity,
	out float4 msl_result,
	inout float3 msl__state_direction)
{
	{
		float3 msl_v = mul((float3x3)__camera_to_world, msl__state_direction);
		msl_result = (texCUBE(msl_env_tex, msl_v.xyz));
		msl_result *= msl_intensity;
	}
}

void Environment_map_cubic_1_environmentmain(
	inout State state,
	in float3 msl__state_direction,
	out float4 msl___result)
{
	float4 msl_Environment_map_cubic_1_result;
	Environment_map_cubic_main(state, Reflection_Env_Cube, msl_Environment_map_cubic_1_intensity, msl_Environment_map_cubic_1_result, msl__state_direction);
	msl___result = msl_Environment_map_cubic_1_result;
}

float4 __trace_environment(
	inout State state,
	Ray msl_ray)
{
	float4 msl_result;
	Environment_map_cubic_1_environmentmain(state, msl_ray.msl_direction, msl_result);
	return msl_result;
}

void kostasShader01_Reflections_Component_reflection_main(
	inout State state,
	out float4 msl_result)
{
	{
		float3 msl_reflected = reflect((state.direction), (state.normal));
		if ((dot(msl_reflected, (state.geom_normal))) < 0.0)
		{
			msl_reflected = (reflect((state.direction), (state.geom_normal)));
		}
		msl_result = (float4(0.0));
		Ray msl_ray = Ray((state.position), msl_reflected);
		Ray msl_ray_dx = Ray((float3((float(0)))), (float3((float(0)))));
		Ray msl_ray_dy = Ray((float3((float(0)))), (float3((float(0)))));
		int msl_trace_opt = 13;
		msl_trace_opt = 13;
		if (!(((((msl_trace_opt == 3) || (msl_trace_opt == 13)) || (msl_trace_opt == 12)) || (msl_trace_opt == 11)) ? (((msl_result = (__trace_environment(state, msl_ray))), true)) : false))
		{
			msl_trace_opt = 3;
			((((msl_trace_opt == 3) || (msl_trace_opt == 13)) || (msl_trace_opt == 12)) || (msl_trace_opt == 11)) ? (((msl_result = (__trace_environment(state, msl_ray))), true)) : false;
		}
	}
}

void kostasShader01_Reflections_Math_color_pow_main(
	inout State state,
	float4 msl_base,
	float4 msl_exponent,
	out float4 msl_result)
{
	{
		msl_result = (float4((pow((float4(msl_base)), (float4(msl_exponent))))));
	}
}

void kostasShader01_Reflections_Component_falloff_main(
	inout State state,
	float msl_amount,
	out float4 msl_result)
{
	{
		float msl_falloff = mi_falloff(state, (state.direction), (state.normal), msl_amount);
		msl_result = (float4(msl_falloff, msl_falloff, msl_falloff, 1.0));
	}
}

void kostasShader01_Reflections_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void kostasShader01_Reflections_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_Reflections_main(
	inout State state,
	sampler2D msl_ReflectivityTexture,
	float msl_ReflectivityFresnel,
	float msl_ReflectivityAmount,
	float3 msl_NormalInput,
	float msl_ReflectionGain,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		float4 msl_Conversion_float_to_color_3_color;
		kostasShader01_Reflections_Conversion_float_to_color_main(state, msl_ReflectivityAmount, msl_Conversion_float_to_color_3_color);
		float4 msl_Component_reflection_1_result;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_NormalInput;
			kostasShader01_Reflections_Component_reflection_main(state, msl_Component_reflection_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_Conversion_float_to_color_10_color;
		kostasShader01_Reflections_Conversion_float_to_color_main(state, msl_ReflectionGain, msl_Conversion_float_to_color_10_color);
		float4 msl_Math_color_pow_1_result;
		kostasShader01_Reflections_Math_color_pow_main(state, msl_Component_reflection_1_result, msl_Conversion_float_to_color_10_color, msl_Math_color_pow_1_result);
		float4 msl_Component_falloff_2_result;
		kostasShader01_Reflections_Component_falloff_main(state, msl_ReflectivityFresnel, msl_Component_falloff_2_result);
		float4 msl_Math_color_multiply_4_result;
		kostasShader01_Reflections_Math_color_multiply_main(state, msl_Math_color_pow_1_result, msl_Component_falloff_2_result, msl_Math_color_multiply_4_result);
		float4 msl_Texture_lookup_2d_3_result;
		kostasShader01_Reflections_Texture_lookup_2d_main(state, msl_ReflectivityTexture, 0, msl_texture_uv, msl_Texture_lookup_2d_3_result);
		float4 msl_Math_color_multiply_5_result;
		kostasShader01_Reflections_Math_color_multiply_main(state, msl_Math_color_multiply_4_result, msl_Texture_lookup_2d_3_result, msl_Math_color_multiply_5_result);
		float4 msl_Math_color_multiply_6_result;
		kostasShader01_Reflections_Math_color_multiply_main(state, msl_Conversion_float_to_color_3_color, msl_Math_color_multiply_5_result, msl_Math_color_multiply_6_result);
		msl_result = msl_Math_color_multiply_6_result;
	}
}

void kostasShader01_Emissive_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_Emissive_Texture_lookup_2d_main(
	inout State state,
	sampler2D msl_texture,
	int msl_texture_space,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
	}
}

void kostasShader01_Emissive_Conversion_bool_to_int_main(
	inout State state,
	bool msl_boolean,
	out int msl_integer)
{
	{
		if (msl_boolean)
		{
			msl_integer = 1;
		}
		else
		{
			msl_integer = 0;
		}
	}
}

void kostasShader01_Emissive_Conversion_int_to_float_main(
	inout State state,
	int msl_integer,
	out float msl_scalar)
{
	{
		msl_scalar = (float(msl_integer));
	}
}

void kostasShader01_Emissive_Math_color_lerp_main(
	inout State state,
	float4 msl_start,
	float4 msl_end,
	float4 msl_location,
	out float4 msl_result)
{
	{
		msl_result = (float4((lerp((float4(msl_start)), (float4(msl_end)), (float4(msl_location))))));
	}
}

void kostasShader01_Emissive_Math_color_multiply_main(
	inout State state,
	float4 msl_left,
	float4 msl_right,
	out float4 msl_result)
{
	{
		msl_result = (float4(((float4(msl_left)) * (float4(msl_right)))));
	}
}

void kostasShader01_Emissive_main(
	inout State state,
	sampler2D msl_EmissiveTexture,
	bool msl_UseEmissiveMap,
	float msl_EmissiveAmount,
	float2 msl_texture_uv,
	out float4 msl_result)
{
	{
		float4 msl_Conversion_float_to_color_9_color;
		kostasShader01_Emissive_Conversion_float_to_color_main(state, msl_EmissiveAmount, msl_Conversion_float_to_color_9_color);
		float4 msl_Texture_lookup_2d_5_result;
		kostasShader01_Emissive_Texture_lookup_2d_main(state, msl_EmissiveTexture, 0, msl_texture_uv, msl_Texture_lookup_2d_5_result);
		int msl_Conversion_bool_to_int_9_integer;
		kostasShader01_Emissive_Conversion_bool_to_int_main(state, msl_UseEmissiveMap, msl_Conversion_bool_to_int_9_integer);
		float msl_Conversion_int_to_float_9_scalar;
		kostasShader01_Emissive_Conversion_int_to_float_main(state, msl_Conversion_bool_to_int_9_integer, msl_Conversion_int_to_float_9_scalar);
		float4 msl_Conversion_float_to_color_8_color;
		kostasShader01_Emissive_Conversion_float_to_color_main(state, msl_Conversion_int_to_float_9_scalar, msl_Conversion_float_to_color_8_color);
		float4 msl_Math_color_lerp_7_result;
		kostasShader01_Emissive_Math_color_lerp_main(state, (float4(0.0, 0.0, 0.0, 1.0)), msl_Texture_lookup_2d_5_result, msl_Conversion_float_to_color_8_color, msl_Math_color_lerp_7_result);
		float4 msl_Math_color_multiply_7_result;
		kostasShader01_Emissive_Math_color_multiply_main(state, msl_Conversion_float_to_color_9_color, msl_Math_color_lerp_7_result, msl_Math_color_multiply_7_result);
		msl_result = msl_Math_color_multiply_7_result;
	}
}

void kostasShader01_DisplayNormals_Transform_internal_to_camera_normal_main(
	inout State state,
	float3 msl_norm,
	out float3 msl_result)
{
	{
		msl_result = (msl_norm);
	}
}

void kostasShader01_DisplayNormals_Math_float3_add_main(
	inout State state,
	float3 msl_left,
	float3 msl_right,
	out float3 msl_result)
{
	{
		msl_result = (msl_left + msl_right);
	}
}

void kostasShader01_DisplayNormals_Math_float3_multiply_main(
	inout State state,
	float3 msl_left,
	float3 msl_right,
	out float3 msl_result)
{
	{
		msl_result = (msl_left * msl_right);
	}
}

void kostasShader01_DisplayNormals_Conversion_float3_to_color_main(
	inout State state,
	float3 msl_vector,
	out float4 msl_result)
{
	{
		msl_result.x = msl_vector.x;
		msl_result.y = msl_vector.y;
		msl_result.z = msl_vector.z;
		msl_result.w = 1.0;
	}
}

void kostasShader01_DisplayNormals_Transform_internal_to_world_normal_main(
	inout State state,
	float3 msl_norm,
	out float3 msl_result)
{
	{
		msl_result = (mul(msl_norm, (float3x3)__world_to_camera));
	}
}

void kostasShader01_DisplayNormals_Math_color_conditional_main(
	inout State state,
	bool msl_condition,
	float4 msl_true_value,
	float4 msl_false_value,
	out float4 msl_result)
{
	{
		msl_result = (msl_condition ? msl_true_value : msl_false_value);
	}
}

void kostasShader01_DisplayNormals_main(
	inout State state,
	bool msl_DisplayWorldNormals,
	bool msl_DisplayCameraNormals,
	float3 msl_NormalInput,
	float4 msl_Input,
	out float4 msl_result)
{
	{
		float3 msl_Transform_internal_to_camera_normal_1_result;
		kostasShader01_DisplayNormals_Transform_internal_to_camera_normal_main(state, msl_NormalInput, msl_Transform_internal_to_camera_normal_1_result);
		float3 msl_Math_float3_add_2_result;
		kostasShader01_DisplayNormals_Math_float3_add_main(state, msl_Transform_internal_to_camera_normal_1_result, (float3(1.0, 1.0, 1.0)), msl_Math_float3_add_2_result);
		float3 msl_Math_float3_multiply_2_result;
		kostasShader01_DisplayNormals_Math_float3_multiply_main(state, msl_Math_float3_add_2_result, (float3(0.500000, 0.500000, 0.500000)), msl_Math_float3_multiply_2_result);
		float4 msl_Conversion_float3_to_color_3_result;
		kostasShader01_DisplayNormals_Conversion_float3_to_color_main(state, msl_Math_float3_multiply_2_result, msl_Conversion_float3_to_color_3_result);
		float3 msl_Transform_internal_to_world_normal_2_result;
		kostasShader01_DisplayNormals_Transform_internal_to_world_normal_main(state, msl_NormalInput, msl_Transform_internal_to_world_normal_2_result);
		float3 msl_Math_float3_add_1_result;
		kostasShader01_DisplayNormals_Math_float3_add_main(state, msl_Transform_internal_to_world_normal_2_result, (float3(1.0, 1.0, 1.0)), msl_Math_float3_add_1_result);
		float3 msl_Math_float3_multiply_1_result;
		kostasShader01_DisplayNormals_Math_float3_multiply_main(state, msl_Math_float3_add_1_result, (float3(0.500000, 0.500000, 0.500000)), msl_Math_float3_multiply_1_result);
		float4 msl_Conversion_float3_to_color_2_result;
		kostasShader01_DisplayNormals_Conversion_float3_to_color_main(state, msl_Math_float3_multiply_1_result, msl_Conversion_float3_to_color_2_result);
		float4 msl_Math_color_conditional_5_result;
		kostasShader01_DisplayNormals_Math_color_conditional_main(state, msl_DisplayWorldNormals, msl_Conversion_float3_to_color_2_result, msl_Input, msl_Math_color_conditional_5_result);
		float4 msl_Math_color_conditional_6_result;
		kostasShader01_DisplayNormals_Math_color_conditional_main(state, msl_DisplayCameraNormals, msl_Conversion_float3_to_color_3_result, msl_Math_color_conditional_5_result, msl_Math_color_conditional_6_result);
		msl_result = msl_Math_color_conditional_6_result;
	}
}

void kostasShader01_ZDepth_Math_float_subtract_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left - msl_right);
	}
}

void kostasShader01_ZDepth_Math_float_divide_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left / msl_right);
	}
}

void kostasShader01_ZDepth_State_ray_length_main(
	inout State state,
	out float msl_result)
{
	{
		msl_result = (state.ray_length);
	}
}

void kostasShader01_ZDepth_Math_float_multiply_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left * msl_right);
	}
}

void kostasShader01_ZDepth_Math_float_invert_main(
	inout State state,
	float msl_scalar,
	out float msl_result)
{
	{
		msl_result = ((float(1)) - msl_scalar);
	}
}

void kostasShader01_ZDepth_Conversion_float_to_color_main(
	inout State state,
	float msl_scalar,
	out float4 msl_color)
{
	{
		msl_color = (float4(msl_scalar, msl_scalar, msl_scalar, 1.0));
	}
}

void kostasShader01_ZDepth_Math_color_conditional_main(
	inout State state,
	bool msl_condition,
	float4 msl_true_value,
	float4 msl_false_value,
	out float4 msl_result)
{
	{
		msl_result = (msl_condition ? msl_true_value : msl_false_value);
	}
}

void kostasShader01_ZDepth_main(
	inout State state,
	float msl_Near,
	float msl_Far,
	float4 msl_input,
	bool msl_DisplayZDepth,
	out float4 msl_resultColor)
{
	{
		float msl_Math_float_subtract_2_result;
		kostasShader01_ZDepth_Math_float_subtract_main(state, msl_Far, msl_Near, msl_Math_float_subtract_2_result);
		float msl_Math_float_divide_1_result;
		kostasShader01_ZDepth_Math_float_divide_main(state, 1.0, msl_Math_float_subtract_2_result, msl_Math_float_divide_1_result);
		float msl_State_ray_length_1_result;
		kostasShader01_ZDepth_State_ray_length_main(state, msl_State_ray_length_1_result);
		float msl_Math_float_subtract_1_result;
		kostasShader01_ZDepth_Math_float_subtract_main(state, msl_State_ray_length_1_result, msl_Near, msl_Math_float_subtract_1_result);
		float msl_Math_float_multiply_1_result;
		kostasShader01_ZDepth_Math_float_multiply_main(state, msl_Math_float_divide_1_result, msl_Math_float_subtract_1_result, msl_Math_float_multiply_1_result);
		float msl_Math_float_invert_2_result;
		kostasShader01_ZDepth_Math_float_invert_main(state, msl_Math_float_multiply_1_result, msl_Math_float_invert_2_result);
		float4 msl_Conversion_float_to_color_2_color;
		kostasShader01_ZDepth_Conversion_float_to_color_main(state, msl_Math_float_invert_2_result, msl_Conversion_float_to_color_2_color);
		float4 msl_Math_color_conditional_4_result;
		kostasShader01_ZDepth_Math_color_conditional_main(state, msl_DisplayZDepth, msl_Conversion_float_to_color_2_color, msl_input, msl_Math_color_conditional_4_result);
		msl_resultColor = msl_Math_color_conditional_4_result;
	}
}

void kostasShader01_Transparency_Conversion_color_to_float_main(
	inout State state,
	float4 msl_color,
	out float msl_scalar)
{
	{
		msl_scalar = (((msl_color.r + msl_color.g) + msl_color.b) / 3.0);
	}
}

void kostasShader01_Transparency_Math_float_conditional_main(
	inout State state,
	bool msl_condition,
	float msl_true_value,
	float msl_false_value,
	out float msl_result)
{
	{
		msl_result = (msl_condition ? msl_true_value : msl_false_value);
	}
}

void kostasShader01_Transparency_Ext_texture_lookup_2d_alpha_main(
	inout State state,
	sampler2D msl_texture,
	float2 msl_texture_uv,
	out float4 msl_result,
	out float msl_alpha)
{
	{
		msl_result = (tex2D(msl_texture, msl_texture_uv));
		msl_alpha = msl_result.a;
	}
}

void kostasShader01_Transparency_Math_float_add_main(
	inout State state,
	float msl_left,
	float msl_right,
	out float msl_result)
{
	{
		msl_result = (msl_left + msl_right);
	}
}

void kostasShader01_Transparency_Math_float_clamp_main(
	inout State state,
	float msl_input,
	float msl_min,
	float msl_max,
	out float msl_result)
{
	{
		msl_result = (clamp(msl_input, msl_min, msl_max));
	}
}

void kostasShader01_Transparency_main(
	inout State state,
	sampler2D msl_DiffuseTextureAlpha,
	float4 msl_Reflections,
	bool msl_IncludeReflections,
	bool msl_IncludeSpecularity,
	float4 msl_Specularity,
	out float msl_result)
{
	{
		float msl_Conversion_color_to_float_5_scalar;
		kostasShader01_Transparency_Conversion_color_to_float_main(state, msl_Specularity, msl_Conversion_color_to_float_5_scalar);
		float msl_Math_float_conditional_2_result;
		kostasShader01_Transparency_Math_float_conditional_main(state, msl_IncludeReflections, msl_Conversion_color_to_float_5_scalar, 0.0, msl_Math_float_conditional_2_result);
		float msl_Conversion_color_to_float_4_scalar;
		kostasShader01_Transparency_Conversion_color_to_float_main(state, msl_Reflections, msl_Conversion_color_to_float_4_scalar);
		float msl_Math_float_conditional_1_result;
		kostasShader01_Transparency_Math_float_conditional_main(state, msl_IncludeSpecularity, msl_Conversion_color_to_float_4_scalar, 0.0, msl_Math_float_conditional_1_result);
		float4 msl_Ext_texture_lookup_2d_alpha_1_result;
		float msl_Ext_texture_lookup_2d_alpha_1_alpha;
		kostasShader01_Transparency_Ext_texture_lookup_2d_alpha_main(state, msl_DiffuseTextureAlpha, (state.tex_coord)[0].xy, msl_Ext_texture_lookup_2d_alpha_1_result, msl_Ext_texture_lookup_2d_alpha_1_alpha);
		float msl_Math_float_add_4_result;
		kostasShader01_Transparency_Math_float_add_main(state, msl_Math_float_conditional_1_result, msl_Ext_texture_lookup_2d_alpha_1_alpha, msl_Math_float_add_4_result);
		float msl_Math_float_add_5_result;
		kostasShader01_Transparency_Math_float_add_main(state, msl_Math_float_conditional_2_result, msl_Math_float_add_4_result, msl_Math_float_add_5_result);
		float msl_Math_float_clamp_1_result;
		kostasShader01_Transparency_Math_float_clamp_main(state, msl_Math_float_add_5_result, 0.0, 1.0, msl_Math_float_clamp_1_result);
		msl_result = msl_Math_float_clamp_1_result;
	}
}

void kostasShader01_Comp_set_alpha_main(
	inout State state,
	float4 msl_foreground,
	float msl_alpha,
	out float4 msl_result)
{
	{
		msl_result = msl_foreground;
		msl_result.a = msl_alpha;
	}
}

void kostasShader01_main(
	inout State state,
	sampler2D msl_ColorTexture,
	sampler2D msl_SpecularTexture,
	float msl_SpecularIntensity,
	float msl_SpecularGlossFactor,
	sampler2D msl_SpecularGlossTexture,
	sampler2D msl_TangentNormalTexture,
	float msl_NormalMapAmount,
	float msl_ReflectivityAmount,
	sampler2D msl_ReflectivityTexture,
	float msl_ReflectivityFresnel,
	float msl_AmbientLightAmount,
	sampler2D msl_AOTexture,
	sampler2D msl_TintRampTexture,
	float msl_TintRampOffsetU,
	float msl_TintRampOffsetV,
	float msl_TintRampAmount,
	samplerCUBE msl_EnvAmbientTexture,
	bool msl_UseHalfLambert,
	bool msl_UseAmbientEnvironmentTexture,
	bool msl_TintRampInvertV,
	bool msl_TintRampInvertU,
	sampler2D msl_DiffuseWarpRamp,
	bool msl_UseDiffuseWarpRamp,
	bool msl_DiffuseWarpRampInvert,
	sampler2D msl_EmissiveTexture,
	bool msl_UseEmissiveMap,
	float msl_AO_Amount,
	float msl_EmissiveAmount,
	float msl_ReflectionGain,
	float msl_Rim_Light_Edge_Factor,
	float msl_Rim_Light_Intensity,
	bool msl_IncludeReflectionsInTransparency,
	bool msl_IncludeSpecularityInTransparency,
	sampler2D msl_ParallaxTexture,
	float msl_ParallaxAmount,
	bool msl_UseHemiColoring,
	bool msl_WorldNormal,
	bool msl_CameraNormal,
	bool msl_UseSpecularGlossTexture,
	bool msl_DisplayZDepth,
	float msl_ZDepthNear,
	float msl_ZDepthFar,
	float3 msl_arne,
	float3 msl_HemiGroundColor,
	float3 msl_HemiSkyColor,
	float3 msl_Ambient_Color,
	out float4 msl_result)
{
	{
		float3 msl_NormalAndParallax_1_NormalResult;
		float2 msl_NormalAndParallax_1_TextureOffset;
		kostasShader01_NormalAndParallax_main(state, msl_ParallaxTexture, msl_ParallaxAmount, msl_TangentNormalTexture, msl_NormalMapAmount, msl_NormalAndParallax_1_NormalResult, msl_NormalAndParallax_1_TextureOffset);
		float4 msl_Conversion_float3_to_color_1_result;
		kostasShader01_Conversion_float3_to_color_main(state, msl_arne, msl_Conversion_float3_to_color_1_result);
		float4 msl_Ext_lambert_half_1_result;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_NormalAndParallax_1_NormalResult;
			kostasShader01_Ext_lambert_half_main(state, msl_Conversion_float3_to_color_1_result, msl_Ext_lambert_half_1_result);
			(state.normal) = msl__normal_temp;
		}
		float msl_SpecularGlossControl_1_SpecularGloss;
		kostasShader01_SpecularGlossControl_main(state, msl_SpecularGlossFactor, msl_SpecularGlossTexture, msl_NormalAndParallax_1_TextureOffset, 1.0, msl_UseSpecularGlossTexture, msl_SpecularGlossControl_1_SpecularGloss);
		float4 msl_Component_phong_2_diffuse;
		float4 msl_Component_phong_2_specular;
		{
			float3 msl__normal_temp = state.normal;
			(state.normal) = msl_NormalAndParallax_1_NormalResult;
			kostasShader01_Component_phong_main(state, msl_Conversion_float3_to_color_1_result, msl_SpecularGlossControl_1_SpecularGloss, msl_Component_phong_2_diffuse, msl_Component_phong_2_specular);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_Math_color_conditional_1_result;
		kostasShader01_Math_color_conditional_main(state, msl_UseHalfLambert, msl_Ext_lambert_half_1_result, msl_Component_phong_2_diffuse, msl_Math_color_conditional_1_result);
		float4 msl_Ambient_Occlusion_Component_1_result;
		{
			float3 msl__normal_temp = state.normal;
			kostasShader01_Ambient_Occlusion_Component_main(state, msl_AmbientLightAmount, msl_AOTexture, msl_EnvAmbientTexture, msl_UseAmbientEnvironmentTexture, msl_NormalAndParallax_1_NormalResult, msl_AO_Amount, msl_NormalAndParallax_1_TextureOffset, msl_UseHemiColoring, msl_HemiSkyColor, msl_HemiGroundColor, msl_Ambient_Color, msl_Ambient_Occlusion_Component_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_WarpedDiffuse_1_result;
		kostasShader01_WarpedDiffuse_main(state, msl_Math_color_conditional_1_result, msl_DiffuseWarpRamp, msl_UseDiffuseWarpRamp, msl_DiffuseWarpRampInvert, msl_Ambient_Occlusion_Component_1_result, msl_WarpedDiffuse_1_result);
		float4 msl_Rim_Light_1_result;
		{
			float3 msl__normal_temp = state.normal;
			kostasShader01_Rim_Light_main(state, msl_Rim_Light_Edge_Factor, msl_WarpedDiffuse_1_result, msl_Rim_Light_Intensity, msl_NormalAndParallax_1_NormalResult, msl_Rim_Light_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_Color2DTexture_result;
		kostasShader01_Texture_lookup_2d_main(state, msl_ColorTexture, 0, msl_NormalAndParallax_1_TextureOffset, msl_Color2DTexture_result);
		float4 msl_LightingFacingColorTint_1_result;
		kostasShader01_LightingFacingColorTint_main(state, msl_TintRampTexture, msl_TintRampOffsetU, msl_TintRampOffsetV, msl_WarpedDiffuse_1_result, msl_TintRampInvertV, msl_TintRampInvertU, msl_LightingFacingColorTint_1_result);
		float4 msl_TintMask2DTexture_result;
		kostasShader01_Texture_lookup_2d_main(state, Tint_Mask_Texture, 0, msl_NormalAndParallax_1_TextureOffset, msl_TintMask2DTexture_result);
		float4 msl_Math_color_lerp_1_result;
		kostasShader01_Math_color_lerp_main(state, msl_WarpedDiffuse_1_result, msl_LightingFacingColorTint_1_result, msl_TintMask2DTexture_result, msl_Math_color_lerp_1_result);
		float4 msl_Conversion_float_to_color_4_color;
		kostasShader01_Conversion_float_to_color_main(state, msl_TintRampAmount, msl_Conversion_float_to_color_4_color);
		float4 msl_Math_color_lerp_2_result;
		kostasShader01_Math_color_lerp_main(state, msl_WarpedDiffuse_1_result, msl_Math_color_lerp_1_result, msl_Conversion_float_to_color_4_color, msl_Math_color_lerp_2_result);
		float4 msl_Math_color_multiply_8_result;
		kostasShader01_Math_color_multiply_main(state, msl_Color2DTexture_result, msl_Math_color_lerp_2_result, msl_Math_color_multiply_8_result);
		float4 msl_Specular2DTexture_result;
		kostasShader01_Texture_lookup_2d_main(state, msl_SpecularTexture, 0, msl_NormalAndParallax_1_TextureOffset, msl_Specular2DTexture_result);
		float4 msl_Math_color_multiply_2_result;
		kostasShader01_Math_color_multiply_main(state, msl_Component_phong_2_specular, msl_Specular2DTexture_result, msl_Math_color_multiply_2_result);
		float4 msl_specularIntensity_color;
		kostasShader01_Conversion_float_to_color_main(state, msl_SpecularIntensity, msl_specularIntensity_color);
		float4 msl_Math_color_multiply_3_result;
		kostasShader01_Math_color_multiply_main(state, msl_Math_color_multiply_2_result, msl_specularIntensity_color, msl_Math_color_multiply_3_result);
		float4 msl_Math_color_add_1_result;
		kostasShader01_Math_color_add_main(state, msl_Math_color_multiply_8_result, msl_Math_color_multiply_3_result, msl_Math_color_add_1_result);
		float4 msl_Reflections_1_result;
		{
			float3 msl__normal_temp = state.normal;
			kostasShader01_Reflections_main(state, msl_ReflectivityTexture, msl_ReflectivityFresnel, msl_ReflectivityAmount, msl_NormalAndParallax_1_NormalResult, msl_ReflectionGain, msl_NormalAndParallax_1_TextureOffset, msl_Reflections_1_result);
			(state.normal) = msl__normal_temp;
		}
		float4 msl_Math_color_add_2_result;
		kostasShader01_Math_color_add_main(state, msl_Math_color_add_1_result, msl_Reflections_1_result, msl_Math_color_add_2_result);
		float4 msl_Emissive_1_result;
		kostasShader01_Emissive_main(state, msl_EmissiveTexture, msl_UseEmissiveMap, msl_EmissiveAmount, msl_NormalAndParallax_1_TextureOffset, msl_Emissive_1_result);
		float4 msl_Math_color_add_4_result;
		kostasShader01_Math_color_add_main(state, msl_Math_color_add_2_result, msl_Emissive_1_result, msl_Math_color_add_4_result);
		float4 msl_Math_color_add_3_result;
		kostasShader01_Math_color_add_main(state, msl_Rim_Light_1_result, msl_Math_color_add_4_result, msl_Math_color_add_3_result);
		float4 msl_DisplayNormals_1_result;
		kostasShader01_DisplayNormals_main(state, msl_WorldNormal, msl_CameraNormal, msl_NormalAndParallax_1_NormalResult, msl_Math_color_add_3_result, msl_DisplayNormals_1_result);
		float4 msl_ZDepth_1_resultColor;
		kostasShader01_ZDepth_main(state, msl_ZDepthNear, msl_ZDepthFar, msl_DisplayNormals_1_result, msl_DisplayZDepth, msl_ZDepth_1_resultColor);
		float msl_Transparency_1_result;
		kostasShader01_Transparency_main(state, msl_ColorTexture, msl_Reflections_1_result, msl_IncludeSpecularityInTransparency, msl_IncludeReflectionsInTransparency, msl_Math_color_multiply_3_result, msl_Transparency_1_result);
		float4 msl_Comp_set_alpha_1_result;
		kostasShader01_Comp_set_alpha_main(state, msl_ZDepth_1_resultColor, msl_Transparency_1_result, msl_Comp_set_alpha_1_result);
		msl_result = msl_Comp_set_alpha_1_result;
	}
}

//
// The following method is the root function of the shader graph
//
float4 kostasShader01_1_eval(State state, out FS_OUT eval_out)
{
	// primary_out: 
	float4 msl_result;
	{
		float3 msl__normal_temp = state.normal;
		kostasShader01_main(state, Diffuse_Texture, Specular_Texture, Specular_Intensity, Specular_Gloss_Factor, Specular_Gloss_Texture, Tangent_Normal_Texture, Normal_Map_Intensity, Reflectivity_Intensity, Reflectivity_Texture, Reflectivity_Fresnel, Ambient_Light_Intensity, Ambient_Occ_Texture, Tint_Ramp_Texture, Tint_Ramp_Offset_U, Tint_Ramp_Offset_V, Tint_Ramp_Intensity, Ambient_Env_Texture, Use_Half_Lambert, Use_Ambient_Environment_Map, Tint_Ramp_Invert_V, Tint_Ramp_Invert_U, Diffuse_Warp_Ramp, Use_Diffuse_Warp_Ramp, Diffuse_Warp_Ramp_Invert, Emissive_Texture, Use_Emissive_Map, Ambient_Occ_Intensity, Emissive_Intensity, Reflection_Gain, Rim_Light_Edge_Factor, Rim_Light_Intensity, Transparency_Include_Reflections, Specularity_in_transparency, Parallax_Texture, Parallax_Intensity, Use_Hemi_Coloring, Display_World_Normals, Display_Camera_Normals, Use_Specular_Gloss_Texture, Display_ZDepth, ZDepth_Near, ZDepth_Far, Diffuse_Color, Hemi_Ground_Color, Hemi_Sky_Color, msl_kostasShader01_1_Ambient_Color, msl_result);
		(state.normal) = msl__normal_temp;
	}
	eval_out = float4(msl_result);
	return float4(msl_result);
}

//
// This function is the main method of the fragment shader. It initializes the
// values in the state structure that are used by nodes in the shader graph
// and produces the final result of the shader.
//
FS_OUT fragment_main(
	Vert2frag fs_in) : COLOR
{
	State state;
	state.position = fs_in.position;
	state.normal = normalize(fs_in.normal);

	// the next three lines are the frontside/backside test!
	if(dot(state.direction, state.normal) > 0.0)
	{
		state.normal = -state.normal;
	}
	// end frontside/backside test

	state.geom_normal = state.normal;
	state.tex_coord = fs_in.tex_coord;
	state.origin = 0;
	state.ray_length = length(state.position);
	state.direction = state.position/state.ray_length;
	float3 t_tex_tangent, t_tex_binormal;
	__make_basis(state.normal, fs_in.tex_du, fs_in.tex_dv, t_tex_tangent, t_tex_binormal);
	state.tangent_space[0] = float3x3(
	    t_tex_tangent,
	    t_tex_binormal,
	    state.normal);

	FS_OUT eval_out;  // multiple shader outputs
	float4 primary_out;  // primary shader output
	primary_out = kostasShader01_1_eval(state, eval_out);
	FS_OUT fs_out;
	fs_out = primary_out;
	return fs_out;
}

//
// The following define the default technique and pass of the effect.
//
technique No_Transparency
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		VertexShader = compile vp40 vertex_main();
		PixelShader  = compile fp40 fragment_main();
	}
}

technique Transparency_using_diffuse_alpha
{
	pass P0
	{
		DepthTestEnable = true;
		DepthMask       = true;
		CullFaceEnable  = false;
		BlendEnable = true;
		blendfunc = int2(srcalpha, oneminussrcalpha);
		VertexShader = compile vp40 vertex_main();
		PixelShader  = compile fp40 fragment_main();
	}
}

string description = "www.kostas.se/shader/";

