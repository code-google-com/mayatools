
// By sorting the node names based on the string length we know that a leaf node will always be in the list before it's parent.
proc cryFBXSortNodeNamesLeafFirst( string $inNodes[] )
{
	int $numNodes = size($inNodes);
	string $temp;
	for( $i = 0;$i<$numNodes-1;$i++ )
	{
		int $swap = 0;
		for( $j = 0;$j<$numNodes-1-$i;$j++ )
		{
			int $jLength = size($inNodes[$j]);
			int $j1Length = size($inNodes[$j+1]);

			if( $j1Length > $jLength )
			{
				$temp = $inNodes[$j];
				$inNodes[$j] = $inNodes[$j+1];
				$inNodes[$j+1] = $temp;
				$swap = 1;
			}
		}
		if( $swap == 0 )
			break;
	}
}

proc string cryFBXCleanupDollars( string $node, string $newNodeName )
{
	string $dollarString = "FBXASC036"; // FBX importer replaces `$` with this string.
	while ( $newNodeName != ( $newNodeName = `substitute $dollarString $newNodeName "_"` ) );
	return $newNodeName;
}

proc string cryFBXCleanupHashes( string $node, string $newNodeName )
{
	string $hashString = "FBXASC035"; // FBX importer replaces `#` with this string.
	while ( $newNodeName != ( $newNodeName = `substitute $hashString $newNodeName "_"` ) );
	return $newNodeName;
}

proc string cryFBXCleanupSpaces( string $node, string $newNodeName )
{
	string $spaceString = "FBXASC032"; // FBX importer replaces ` ` with this string.
	while ( $newNodeName != ( $newNodeName = `substitute $spaceString $newNodeName "__"` ) );
	return $newNodeName;
}

proc string cryFBXCleanupParentheses( string $node, string $newNodeName )
{
	string $openBraceString = "FBXASC040"; // FBX importer replaces `(` with this string.
	string $closeBraceString = "FBXASC041"; // FBX importer replaces `)` with this string.
	while ( $newNodeName != ( $newNodeName = `substitute $openBraceString $newNodeName "_"` ) );
	while ( $newNodeName != ( $newNodeName = `substitute $closeBraceString $newNodeName "_"` ) );
	return $newNodeName;
}

proc string cryFBXCleanupGroup( string $node, string $newNodeName )
{
	string $pathTokens[];
	$pathTokens = `stringToStringArray $node "|"`;
	int $pathLength = `size($pathTokens)`;

	if( $pathLength > 1 && `endsWith $newNodeName "_group"` == 0 && `startsWith $newNodeName "_joint"` == 0 )
	{
		$newNodeName = ($newNodeName + "_group");
	}
	return $newNodeName;
}

proc string cryFBXCleanupExportNode( string $node, string $newNodeName )
{
	string $pathTokens[];
	$pathTokens = `stringToStringArray $node "|"`;
	int $pathLength = `size($pathTokens)`;

	if( $pathLength == 1 )
	{
		$newNodeName = ("cryexportnode_" + $newNodeName);
	}
	return $newNodeName;
}

proc cryFBXCleanupAttributes( string $node )
{
	string $attrs[];
	$attrs = `listAttr -userDefined $node`;

	for( $attr in $attrs )
	{
		// Some of the attributes from MAX seem to have a `3DSMAX` suffix...
		if( `endsWith $attr "3DSMAX"` == 1 )
		{
			int $attrNameLength = `size($attr)`;
			string $newAttrName = `substring $attr 1 ($attrNameLength-6)`;
			catchQuiet( `renameAttr ($node+"."+$attr) $newAttrName` );
		}
	}
}

proc int cryFBXCleanupIsSelected( string $nodeName )
{
	string $selected[];
	$selected = `ls -sl $nodeName`;
	
	if( size($selected) > 0 )
	{
		return true;
	}

	// Check to see if the nodes parent is selected.
	string $parent = `firstParentOf $nodeName`;
	if( size($parent) > 0 )
	{
		return `cryFBXCleanupIsSelected $parent`;
	}

	return false;
}

proc cryFBXCleanupProcess( int $renameSelectedRootsOnly )
{
	string $allNodes[];
	$allNodes = `ls -l -type "transform" -type "mesh"`;

	cryFBXSortNodeNamesLeafFirst $allNodes;

	string $node;
	for( $node in $allNodes )
	{
		string $nodeType = `nodeType $node`;

		string $pathTokens[];
		$pathTokens = `stringToStringArray $node "|"`;
		string $nodeName = $pathTokens[size($pathTokens)-1];

		cryFBXCleanupAttributes $node;

		int $renameExportNode = 1;
		if( $renameSelectedRootsOnly && !`cryFBXCleanupIsSelected $nodeName` )
			$renameExportNode = 0;

		string $newNodeName = $nodeName;
		$newNodeName = `cryFBXCleanupDollars $node $newNodeName`;
		$newNodeName = `cryFBXCleanupHashes $node $newNodeName`;
		$newNodeName = `cryFBXCleanupSpaces $node $newNodeName`;
		$newNodeName = `cryFBXCleanupParentheses $node $newNodeName`;

		if( $renameExportNode && `strcmp $nodeType "mesh"` != 0 )
		{
			$newNodeName = `cryFBXCleanupExportNode $node $newNodeName`;
			$newNodeName = `cryFBXCleanupGroup $node $newNodeName`;
		}
			
		if( $newNodeName != $nodeName )
		{
			catchQuiet( $newNodeName = `rename -ignoreShape $node $newNodeName` );
		}
	}
}

global proc cryFBXCleanupUDP( )
{
	string $udpAttributeName = "UDP";

	string $allNodes[];
	$allNodes = `ls -l`;
	for( $node in $allNodes )
	{
		if (`attributeExists $udpAttributeName $node`)
		{
			string $nodeUDP = `getAttr ($node+"."+$udpAttributeName)`;
			while( 1 )
			{
				string $newUDP = `substitute "&cr;&lf;" $nodeUDP "\n"`;
				if( `strcmp $newUDP $nodeUDP` == 0 )
					break;
				$nodeUDP = $newUDP;
			}
			setAttr -type "string" ($node+"."+$udpAttributeName) $nodeUDP;
		}
	}
}

proc cryFBXCleanup()
{
	string $selected[];
	$selected = `ls -sl`;

	int $renameSelectedRootsOnly = 1;
	string $message = "";
	if( size($selected) == 0 )
	{
		$message = "This will cleanup the node names created when importing an FBX scene from Max.\nAll root nodes will be renamed to `cryexportnode`.\nIf this is not what you want to do, click Cancel, select the export nodes and rerun this script.";	
		$renameSelectedRootsOnly = 0;
	}
	else
	{
		$message = "This will cleanup the node names created when importing an FBX scene from Max.\nOnly the selected root nodes will be renamed to `cryexportnode`.";	
		$renameSelectedRootsOnly = 1;
	}

	string $result = `confirmDialog -title "Cry FBX" -message $message -button "Ok" -button "Cancel" -defaultButton "Ok" -cancelButton "Cancel" -dismissString "Cancel"`;

	if( $result == "Ok" )
	{
		cryFBXCleanupProcess( $renameSelectedRootsOnly );

		cryFBXCleanupUDP;

		string $nodes[];
		$nodes = `ls "cryexportnode_*"`;

		// Add any attributes to the newly renamed nodes.
		cryExportAddAttributes;
	}
}

proc cryFBXSourceDependencies()
{
	eval("source cryExport.mel");
}

global proc cryFBX()
{
	cryFBXSourceDependencies;
	cryFBXCleanup;
}