global proc string boltGetRootPath()
//Returns the root path for the current project
//This proc can be changed per project if necessary to make paths compatible
//
//Currently relies on MS3 people only having a "BRANCH_ROOT" env var, and no
//"BRANCHPATH". If "BRANCHPATH" is found an MSF style root will be returned 
//with the added data directory.
{
	//string $path = `getenv BRANCHPATH`;
	//if ($path != "")
	//{
	//	$path += "/Data";
	//	return $path;
	//}
	//MSF paths removed
	
	$path = `getenv BRANCH_ROOT`;
	if ($path != "")
	{
		return "m:";
	}
	//MS3 Paths - m: drive based paths needed for export to work correctly
	
	error "boltGetRootPath() could not establish project path!";
}


global proc string boltGetRPKPath()
//needed as rpks are in a totally different path on each project
{
	//string $path = `getenv BRANCHPATH`;
	//if ($path != "")
	//{
	//	$path += "/Output/packed_vehicles/";
	//	return $path;
	//}
	//MSF paths removed
	
	$path = `getenv BRANCH_ROOT`;
	if ($path != "")
	{
		return "m:/resources/ps3/overrides/packed_vehicles/";
	}
	//MS3 Paths
	
	error "boltGetRPKPath() could not establish a path!";
}




	
	
		

	frameLayout -width 205 -collapsable 1 -label "Cameras" -marginWidth 0 -labelAlign "center" -borderStyle "etchedOut" camerasFrameLayout;
		formLayout camerasFormLayout;
		//Create frame and form
			button -height 20 -width 90 -recomputeSize 0 -label "Lock" 				-backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Locks position and settings of currently selected cameras" 		-command "boltLockCams 1;"  	boltButtonLockCams;
			button -height 20 -width 90 -recomputeSize 0 -label "Unlock" 			-backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Unlocks position and settings of currently selected cameras" 		-command "boltLockCams 0;"  	boltButtonUnlockCams;
			button -height 20 -width 188 -recomputeSize 0 -label "Toggle Auto Tumble Pivot"	-backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Toggles camera auto tumble pivot on/off" 		-command "ctp 3"  	boltButtonCPT;
			//Create camera buttons
			separator -h 4 -style "none" seperator02;
		setParent ..;
	setParent ..;


	
			
			button -height 20 -width 188 -recomputeSize 0 -label "Super Car Validator" -ann "Tests for and fixes vehicle errors" 	-command "boltSuperCarValidator" -backgroundColor $colToolBox[0] $colToolBox[1] $colToolBox[2]	boltButtonSCV;
			button -height 20 -width 90 -recomputeSize 0 -label "Export" 	-backgroundColor $colBolt[0] $colBolt[1] $colBolt[2]		-ann "Exports intermediate files - opens for edit in perforce if necessary" 	-command "source evoexport.mel; evoExportUI(); tabLayout -e -selectTab \"evoExportVehicleFrame\" evoExportUITabCtrl;" 	boltButtonExportVehicleIntermediatesA;
			button -height 20 -width 90 -recomputeSize 0 -label "Archive Scene" 	-backgroundColor $colToolBox[0] $colToolBox[1] $colToolBox[2]	-ann "Allows you to archive the current scene file and all necessary textures, ideal for outsourcing" 	-command "boltArchiveGUI" 	boltButtonArchive;




global proc boltAutoTumblePivotMenu()
{
	int $value = `menuItem -q -checkBox boltMenuAutoTumbleOption`;
	
	if ($value == 0) ctp 2; else ctp 1;
	
	optionVar -intValue "boltPolyToolsCameraTumble" $value;
}



boltUpdateShaderOptionMenu;
		$boltEditTabJob4 = `scriptJob -parent "boltPolyToolsWindow" -event "SceneOpened" 		boltUpdateShaderOptionMenu`;
		$boltEditTabJob5 = `scriptJob -parent "boltPolyToolsWindow" -event "SelectionChanged" 	boltUpdateShaderOptionMenu`;
		//updates the shader menu	
		
		$boltEditTabJob6 = `scriptJob -parent "boltPolyToolsWindow" -event "SelectionChanged" 	boltUpdateUndoPrefsButton`;
		
		
	//			button -height 20 -width 100 -recomputeSize 0 -label "Undo Prefs" -command "PreferencesWindow; switchPrefTabs 22;" -ann "Shows prefs for undo command. Button goes red if undo disabled" boltButtonUndoPrefs;

global proc boltUpdateUndoPrefsButton()
//colours the undo prefs button red if undo is off
{
	global float $gColR[];
	global float $gColGP[];
	
	if (`undoInfo -q -state` == 0) 
	{
		button -e -backgroundColor $gColR[0] $gColR[1] $gColR[2] boltButtonUndoPrefs;
	}
	else
	{
		button -e -backgroundColor $gColGP[0] $gColGP[1] $gColGP[2] boltButtonUndoPrefs;
	}
	
	formLayout -edit -visible 0 boltPTTabForm; 
	formLayout -edit -visible 1 boltPTTabForm; 
	//updates display
	
}


                   

global proc boltLockCams(int $flag)
//lock or unlocks selected cameras.
//$flag 1 locks, 0 unlocks
{

	string $selected[] = `ls -sl`;
	string $obj;
	
	for ($obj in $selected)
	{
		boltLockCam $obj $flag;
	}
}


global proc boltLockCam(string $obj, int $flag)
//lock or unlocks specified camera.
//$flag 1 locks, 0 unlocks
{		
	string $rels[] = `listRelatives -c -s -type "camera" $obj`;
	if ($rels[0] != "")
	//make sure this is a camera
	{   
		setAttr -lock $flag ($obj + ".tx");
		setAttr -lock $flag ($obj + ".ty");
		setAttr -lock $flag ($obj + ".tz");
		setAttr -lock $flag ($obj + ".rx");
		setAttr -lock $flag ($obj + ".ry");
		setAttr -lock $flag ($obj + ".rz");
		setAttr -lock $flag ($obj + ".sx");
		setAttr -lock $flag ($obj + ".sy");
		setAttr -lock $flag ($obj + ".sz");
		
		setAttr -lock $flag ($rels[0] + ".orthographic");
		setAttr -lock $flag ($rels[0] + ".hfa");
		setAttr -lock $flag ($rels[0] + ".vfa");
		setAttr -lock $flag ($rels[0] + ".fl");
		setAttr -lock $flag ($rels[0] + ".lsr");
		setAttr -lock $flag ($rels[0] + ".fs");
		setAttr -lock $flag ($rels[0] + ".fd");
		setAttr -lock $flag ($rels[0] + ".sa");
		setAttr -lock $flag ($rels[0] + ".coi");
	}   
	//lock/unlock attributes.
	
}



global proc boltUpperCaseObjects()
//converts all objects in scene to uppercase - except the viewport cams
{
	string $objectList[] = `ls -transforms`;
	// get a list of objects
	string $object;

	string $dontChange[] = {"front", "persp", "side", "top"};
	$objectList = stringArrayRemove($dontChange, $objectList);
	//remove the viewport cams from the name change list

	for ($object in $objectList)
	{
		string $newName = `toupper $object`;
		rename $object $newName;
	}
	//convert objects to uppercase
	
	boltUpdateObjectNameField;
	boltUpdateObjectNameOptionMenu;
	//update the interface with the new names
	
}



global proc boltUpdateShaderOptionMenu()
//updates the shaders displayed in the shaders optionmenu
{
	string $sMaterial;
	if (`optionMenu -q -numberOfItems boltOptionMenuShaders` == 0)
	{
		$sMaterial = "";
	}
	else
	{
		$sMaterial = `optionMenu -q -value boltOptionMenuShaders`;
	}
	//remember selected material
	
	string $optionContents[] = `optionMenu -q -ils boltOptionMenuShaders`;
	//get list of items in the option menu
	
	for ($item in $optionContents)
	{
		deleteUI $item;
	}
	//clear the option menu items
	
	string $shaderList[] = sort(`ls -materials`);
				
	string $shader;
	for ($shader in $shaderList)
	{
		if ($shader != "particleCloud1")
		//dont bother with this shader
		{
			string $label = `substring $shader 1 30`;
			menuItem -parent "boltOptionMenuShaders" -label $label ("boltShaderList" + $shader);
		}
		//add menu items
	}
	//adds all the shader names to the option menu
	
	//if (`menuItem -exists ("boltShaderList" + $sMaterial)`)
	{
		catchQuiet(`optionMenu -e -value $sMaterial boltOptionMenuShaders`);
		//print ("\n" + $sMaterial + " SHADER RESTORED");
	}
	//restore previously selected material
}



global proc boltUpdateDisplayFloatBox (string $floatChanged, string $propertyChanged)
//updates a property after a float box is changed
//inputs are the floatbox that changed, and the property to change on selected objects.
{
	string $selectedShapes[];
	
	string $selected[]= `ls -sl -et transform -long`; 
	//get selected objects 
	
	if (size($selected) == 0)
	{
		$selected = `ls -hl -long`; 
	}
	//if no selected objects found, check for highlighted objects (objs being component edited)
	
	if (size($selected) != 0) //don't attempt if nothing is selected
	{
		$selectedShapes = `listRelatives -type "mesh" -fullPath $selected`; 
		//get the shape nodes for all selected objects
		
		string $i;
		for ($i in $selectedShapes)
		{
			setAttr ($i + "." + $propertyChanged) `floatField -q -value $floatChanged`;
		}
		//change the property for all shapes
	}

}


global proc boltUpdateDisplayCheckBoxes (string $changed)
//updates display attributes when the specified check box changes 
{
	int $state;
	string $attr;
	string $selectedShapes[];
	
	string $selected[]= `ls -sl -et transform -long`; 
	//get selected objects 
	
	if (size($selected) == 0)
	{
		$selected = `ls -hl -long`; 
	}
	//if no selected objects found, check for highlighted objects (objs being component edited)
		
	$selectedShapes = `listRelatives -type "mesh" -fullPath $selected`; 
	//get the shape nodes for all selected objects
	
	if ($changed == "Vertices")
	{
		$state = `checkBox -q -value boltCheckBoxVertices`; //get the flag state
		$attr = "displayVertices"; //set the right attribute to change
	}
	else if ($changed == "VertexCulling")
	{
		$state = `checkBox -q -value boltCheckBoxVertexCulling`; 
		$attr = "vertexBackfaceCulling"; 
	}
	else if ($changed == "Borders")
	{
		$state = `checkBox -q -value boltCheckBoxBorders`; 
		$attr = "displayBorders"; 
	}
	else if ($changed == "FaceCenters")
	{
		$state = `checkBox -q -value boltCheckBoxFaceCenters`; 
		$attr = "displayCenter"; 
	}	
	else if ($changed == "Triangles")	
	{
		$state = `checkBox -q -value boltCheckBoxTriangles`; 
		$attr = "displayTriangles"; 
	}
	else if ($changed == "UVs")	
	{
		$state = `checkBox -q -value boltCheckBoxUVs`; 
		$attr = "displayUVs"; 
	}
	else if ($changed == "NonPlanar")	
	{
		$state = `checkBox -q -value boltCheckBoxNonPlanar`;
		$attr = "displayNonPlanar"; 
	}
	else if ($changed == "Normals")	
	{
		$state = `checkBox -q -value boltCheckBoxNormals`; 
		$attr = "displayNormal"; 
	}
	
	string $i;
	for ($i in $selectedShapes)
	{
		setAttr ($i+"."+$attr) $state;
	}
	//update the attribute state for each selected object
	
}



global proc boltUpdateDisplayAttributeButtons()
//updates the status of the Display Attribute Buttons if the selection changes
{
	int $state;                                                 
	string $selectedShape[];                                      
                                                               
	string $selected[]= `ls -sl -et transform -long`;                            
	//get selected objects                                      
    
    if (size($selected) == 0)                                                                       
	{                                                                                               
		$selected = `ls -hl -long`;                                                                 
	}                                                                                               
	//if no selected objects found, check for highlighted objects (objs being component edited)     
     
    if (size($selected) != 0)    
    {                                                                                       
		$selectedShape = `listRelatives -type "mesh" -fullPath $selected[0]`; 
		//get the shape nodes for 1st selected object                 
			
		$state = `getAttr ($selectedShape[0]+".displayVertices")`;  		//get the current state
 		checkBox -e -value $state boltCheckBoxVertices;						//update the tick box
 		$state = `getAttr ($selectedShape[0]+".vertexBackfaceCulling")`;
 		checkBox -e -value $state boltCheckBoxVertexCulling;
 		$state = `getAttr ($selectedShape[0]+".displayCenter")`; 
 		checkBox -e -value $state boltCheckBoxFaceCenters;	
 		$state = `getAttr ($selectedShape[0]+".displayBorders")`; 
 		checkBox -e -value $state boltCheckBoxBorders;						
 		$state = `getAttr ($selectedShape[0]+".displayTriangles")`; 
 		checkBox -e -value $state boltCheckBoxTriangles;				
 		$state = `getAttr ($selectedShape[0]+".displayUVs")`; 
 		checkBox -e -value $state boltCheckBoxUVs;				
 		$state = `getAttr ($selectedShape[0]+".displayNonPlanar")`; 
 		checkBox -e -value $state boltCheckBoxNonPlanar;				
    	$state = `getAttr ($selectedShape[0]+".displayNormal")`; 
 		checkBox -e -value $state boltCheckBoxNormals;		
 		
 		$state = `getAttr ($selectedShape[0]+".normalType")`;
 		if ($state == 0) $state = 1; 
 		catchQuiet(`optionMenu -e -select ($state) boltOptionMenuNormalType`);  //updates the normal type option menu
 				
 		$state = `getAttr ($selectedShape[0]+".displayEdges")`;
 		optionMenu -e -select ($state+1) boltOptionMenuEdgeDisplay;  //updates the edge display option menu
 		
 		$state = `getAttr ($selectedShape[0]+".backfaceCulling")`;
 		optionMenu -e -select ($state+1) boltOptionMenuBackfaceCulling;  //updates the backface culling option menu
		
		
		floatField -e -value `getAttr ($selectedShape[0]+".normalSize")` boltFieldNormalSize;
 		//update the normal size float box
 	}
}


global proc boltSelectionList(int $mode, string $title, string $buttonText, string $itemList[], string $command)
//Allows the user to select from a list of items, then performs a command on those items
//$mode 		- 0 = select 1 item, 1 = select multiple items
//$title 		- window title
//$buttonText	- text for the "ok" perform command button
//$itemList[]   - array of items to select from
//$command      - command to perform on each selected "$item". 
//eg: boltSelectionList 1 "Select Items To Print" "Print Items" ("fred", "jim", "dave") "print $item"
{
	global string $item;	
	global string $boltSLCommand;
	$boltSLCommand = $command;
	//have to make this gobal or else the "ok" button can't see it for some reason...
		
	if (`window -exists boltSelectionListWindow`) {deleteUI boltSelectionListWindow;} 
	//delete the window if it already exists
	
	window -height 307 -width 208 -title $title -toolbox 1 boltSelectionListWindow;
	//create window
		columnLayout;
			textScrollList -numberOfRows 20 -width 194 -allowMultiSelection $mode boltSelectionTextScrollList;
			button -height 20 -width 194 -recomputeSize 0 -label $buttonText 	
				-command 	("string $selectedItems[] = `textScrollList -q -selectItem boltSelectionTextScrollList`;" +
							"if (size($selectedItems) > 0)" +
							"{for ($item in $selectedItems)	{eval $boltSLCommand;}}" +
							"deleteUI boltSelectionListWindow;")
				-ann "Proceed with selection" 	boltButtonSelectionListOK;
			//defines the "OK" button
	
	
	showWindow boltSelectionListWindow;
	//display the window
	
	
	for ($item in $itemList)
	{
		textScrollList -e -append $item boltSelectionTextScrollList;
	}
	//adds all the items to the text list
}


global proc boltDeleteLayers()
//removes all layers from scene
{
	string $object;
	string $objectList[] = `ls -transforms -long`;
	
	for ($object in $objectList)
	{
		editDisplayLayerMembers defaultLayer $object;
	}
	//move everything to defaultLayer (always exists)
	
	layerEditorSelectUnused; layerEditorDeleteLayer "";
	//delete layers
}





global proc boltDeleteAllParentConstraints()
//Deletes all parent constraints in the scene
{
	
	string $node;
	string $allParentConstraints[] = `ls -long -exactType "parentConstraint"`;
	//get a list of all parent constraint nodes.
	
	for ($node in $allParentConstraints) delete $node;
	//delete them all
	
	//listRelatives -c -type "parentConstraint" "MIRROR_L";
}


global proc boltDeleteParentConstraints()
//Deletes parent constraints for selected objects
{
	string $object;                                
	string $objectList[] = `ls -sl -transforms -long`; 
	//get selected objects
	
	for ($object in $objectList)
	{
		string $nodes[] = `listRelatives -fullPath -c -type "parentConstraint" $object`;
		string $node;
		for ($node in $nodes) delete $node;
		//find and delete parent constraints for each selected object
	}
	
}

	
global proc boltRenameShapes()
//renames shapes to [transform name]Shape
{
	
	string $shape;
	string $selected[]= `ls -type "mesh"`;                            
	//get shapes                                      
                   
    for ($shape in $selected)
    {              
                                                              
		string $trans[] = `listRelatives -type "transform" -parent $shape`; 
		//get the shape nodes for 1st selected object    

		catchQuiet(`rename $shape ($trans[0] + "Shape")`);
		
	}
	print "Shapes renamed";
}



global proc boltDeleteHavokNodes(string $obj)
//delete havok nodes from an objectr
{

	string $havokNodeTypes[] = {"hkNodeRigidBody", "hkNodeShape", "hkNodeHingeConstraint", "hkNodeRagDollConstraint", "hkdBody", "hkdFlexibleJointController", "hkdRandomSplitFracture", "hkdShape" };  
	string $havokNodes[];
		
	for ($nodeType in $havokNodeTypes)
	{
		$havokNodes = `listRelatives -fullPath -type $nodeType $obj`;
		for ($node in $havokNodes)
		{
			boltDeleteLocked $node;
			print ("\nDeleted " + $node);
		}
	}
	
}


global proc boltRemoveHavok()
//deletes havok nodes for all selected objects.
{
	string $selected[] = `ls -o -sl`;
	for ($obj in $selected)
	{
		boltDeleteHavokNodes $obj;
		print ("\nREMOVED HAVOK NODES FROM " + $obj + "\n");
	}
}


global proc boltAddLodsToHierarchy()
{
	string $lods[] = `ls -type "transform" "*_LOD*"`;
	
	for ($lod in $lods)
	{
		string $parent =  `substitute "_LOD." $lod ""`;
		
		string $currentParent[] = `listRelatives -p $lod`;
		if ($currentParent[0] != $parent)
		{		
			catchQuiet(`parent $lod $parent`);
		}
		
	}
	// parent all lods
	
	print "\nLODS ATTACHED TO HIERARCHY\n";
}


global proc boltMudVerts (float $mud)
{
	if ($mud == 2)
	{
		string $sel[] = `ls -sl`;
		polySelectConstraint -pp 1;
		polyColorPerVertex -r 1 -g 0.5 -b 1;
		select $sel;
		polyColorPerVertex -r 1 -g 1 -b 1;
	}
	//premuds with a slight fade off
	else
	{
		polyColorPerVertex -r $mud;
	}
	//sets mud

}


global proc boltDeleteLocked(string $node)
//deletes specified locked nodes
{
		lockNode -lock off $node;
		delete $node;
}



global proc boltCarStats()
{
	int $polyCount0 = `boltGetPolyCount "_LOD0"`;
	int $nodeCount0 = `boltGetNodeCount "_LOD0"`;
	
	float $liveryTextures = `boltVehicleTextureMemory`;

	string $liverySizes[] = {};
	string $liveryNos[] = `boltGetSceneLiveryNos`;
				
	for ($liveryNo in $liveryNos)
	{
		string $no = `match "[0-9]+" $liveryNo`;
		boltSwitchLivery $no;
		refresh;
		int $liveryTextureMem = `boltVehicleTextureMemory`;
		$liverySizes[size($liverySizes)] = ($liveryNo + ": " + $liveryTextureMem + "k \n");
	}
	//get textures used for each livery
	
	print ("\nFILE: " + `file -q -sceneName` + "\n");
	print ("Triangles: " + $polyCount0 + "\n");
	print ("Nodes: " + $nodeCount0 + "\n");
	for ($entry in $liverySizes) print $entry;	
}



	
	
global proc int boltFileSize(string $fileToCheck)
//given a file path, returns the size in bytes of that file.	
{
	string $fileToCheck = toNativePath($fileToCheck);
	//make sure the path is dos compatible
	
	string $result = system("dir /-c " + $fileToCheck);
	//store results of a dir command on the file

	string $buffer[]; tokenize($result, $buffer);
	//tokenise the result

	int $i = sFindItem($buffer, "File(s)");
	//find this token
	
	int $fileSize = $buffer[($i+1)];	
	//file size is the next token
	
	return $fileSize;
}


global proc float boltDistanceFromPoint(string $vert, float $point[])
//returns the distance squared of a vert from a point.
{
	float $pos[] = `pointPosition -w $vert`;
	float $dis[] = {};
	//stores x y z dist from point
	
	for ($i = 0; $i < 3; $i++) 
	{
		$dis[$i] = $pos[$i]-$point[$i+3];
	}
	//work out distance from the box in XYZ axis
	
	float $distSquared = $dis[0]*$dis[0] + $dis[1]*$dis[1] + $dis[2]*$dis[2];
	return $distSquared;
}


global proc boltReloadTextures()
//reloads and refreshes all textures in the scene
{
	string $rootPath = `boltGetRootPath`;
	string $textures[] = `ls -type "file"`;
	string $paths[] = {};
	for ($texture in $textures)
	{
		$paths[size($paths)] = `getAttr ($texture + ".fileTextureName")`;
		setAttr ($texture + ".fileTextureName") -type "string" ( $rootPath + "/Art/Vehicles/GENERIC_TEXTURES/ribbed_pipe.dds" );
	
	}
	print "\ntextures stripped";
	
	refresh -force;
	
	for ($i=0; $i<size($textures); $i++)
	{
		setAttr  ($textures[$i] + ".fileTextureName") -type "string" $paths[$i];
	}
	print "\ntextures restored + refreshed";		
}




	
global proc boltArchiveFilesTo(string $dest)
//copies the current maya scene and all it's textures to $dest
{
	$dest = fromNativePath($dest);
	if (!(`endsWith "/" $dest`))
	{
		$dest = $dest + "/";
	}
	//make sure we have a trailing slash
		
	sysFile -makeDir $dest;                                                                                                                                                                                                                                                 
    //makes entire path
	
	string $fileNodes[] = `ls -type "file"`;
	string $files[] = {};
	
	for ($fileNode in $fileNodes)
	{
		int $countConns = 0;
		string $conns[] = `listConnections $fileNode`;
		for ($conn in $conns)
		{
			if ((`nodeType $conn` != "defaultTextureList") && (`nodeType $conn` != "place2dTexture"))
			{
				$countConns++;
			}
		}
		//filter out unused textures
		
		
		if ($countConns > 0)
		{
			string $file = `getAttr ($fileNode+".fileTextureName")`;
			$file = `fromNativePath $file`;
			$file = `tolower $file`;
			$files[size($files)] = $file;
		}
	}
	$files = `stringArrayRemoveDuplicates $files`;
	//gets a list of file texture paths
	
	
	$files[size($files)] = `file -q -sceneName`;
	//add the scene file to the list  
	
	print "/n"; print $files;
	
	string $copied[] = {};
		
	for ($file in $files)
	{
		string $destFileName = basename( $file, "" );
		if (`sFindItem $copied $destFileName` == -1)
		//stops script from trying to copy same texture twice, even if copying from diff sources 
		{
			system ("copy \"" + `toNativePath $file` + "\" \"" + `toNativePath ($dest+$destFileName)` + "\" /y");
			print ("\n" + $file + " copied to " + $dest + $destFileName);
		}
	}
	//copy all textures to destination
}

global proc boltZipFolder(string $folder)
//zips up the specified folder
//requires 7za.exe on system path - http://www.7-zip.org/
{
	$folder = `toNativePath $folder`;
	
	if (`endsWith $folder "\\"`)
	{
		$folder = `substring $folder 1 (size($folder)-1)`;
	}
	
	string $command = ("7za a -tzip \"" + $folder + ".zip\" \"" + $folder +"\"");
	print ("\n" + $command);
	system $command;
}


global proc boltArchiveGUI()
//archives and zips maya files and textures - similar to 3dsmax
//no support for references yet
{
	if (`window -exists boltArchiveWindow`) deleteUI boltArchiveWindow; 
	//delete the window if it already exists
	
	window -title "Archive Scene" -toolbox 1 boltArchiveWindow;
		scrollLayout;
			columnLayout;
				
				frameLayout -width 400 -collapsable 1 -label "Convert Shaders" -mw 10 -mh 10 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						button -height 20 -width 250 -label "Convert ATG to Maya Shaders (viewport)" -command "boltConvertAllATGShadersToMaya" -ann "Simple shaders, optimised for hires viewport display, not rendering.";
						button -height 20 -width 250 -label "Switch back to ATG Shaders" -command "boltSwitchBackToATGShaders; boltDeleteMayaShaders;" -ann "Switches back to ATG shaders if still in scene. Deletes maya shaders.";
					setParent ..;
				setParent ..;
				
				frameLayout -width 400 -collapsable 1 -label "Copy Vertex Alphas" -mw 10 -mh 10 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;

						button -height 20 -width 250 -label "Copy Alphas to new colour set"	  			-command "boltCreateColourSet \"occlusion_set\" \"-a\"" -ann "Copies the alpha channel into a new colour set - needed to view the occlusion in maya software shader";
						button -height 20 -width 250 -label "Copy Alphas back into main colour set"	 	-command "boltDeleteOcclusionSet" -ann "Copies the alpha channel back into the main colour set, and deletes the occlusion colour set used by outsourcers";
					setParent ..;
				setParent ..;
				
				frameLayout -width 400 -collapsable 1 -label "Swaps + Game Data" -mw 10 -mh 10 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						button -height 20 -width 250 -label "Import wheels (make non-referenced)" -command "boltConvertWheelsToNonReferenced" -ann "Imports any referenced wheels into the scene, ready to be pruned down by one of the delete swaps buttons below";
						button -height 20 -width 250 -label "Delete Swaps (Preserve Default)" -command "boltDeleteSwapShapes" -ann "Deletes all swap shapes and lods except for SWP00";
						button -height 20 -width 250 -label "Delete Swaps (Preserve Selected)" -command "boltDeleteUnselectedSwapShapes" -ann "Deletes all swap shapes except for those currently selected in the vehicle display manager. Renames remaining shapes to SWP00 shapes.";
						button -height 20 -width 250 -label "Delete All Game Data From Scene"	  -command "boltStripCar" -ann "Removes all game specific nodes, locators, rigging, lods, physics etc.";
					setParent ..;
				setParent ..;
				
				frameLayout -width 400 -collapsable 1 -label "Archive Scene" -mw 10 -mh 10 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						text -label "Archive Maya file and all required textures to:"; 
						textField -width 400 -text `boltGetDefaultArchivePath` -ann "Enter folder to copy textures to, new folders will be created if they don't exist" boltArchivePathField;
						button -height 20 -width 50   -label "Browse"    -ann "Browse for a file path"  -command "fileBrowserDialog -m 4 -fc \"boltSetBrowsedFolder\" -an \"Choose a directory for archive:\"";
						checkBox -value 1 -label "Zip folder" -ann "creates a zip of the folder, needs www.7-zip.org" boltArchiveZipCheckbox;  	
						button -height 20 -width 250   -label "ARCHIVE"    -ann "Creates the archive folder and optional zip"  -command "boltArchiveGUIRun";
					setParent ..;
				setParent ..;		
				
				frameLayout -width 400 -collapsable 1 -label "Outsource Tools" -mw 10 -mh 10 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						button -height 20 -width 250   -label "Outsource Toolbox"    -ann "Runs the toolbox that will be available to outsourcers"  -command "boltLodOutsourceToolbox";
						button -height 20 -width 250   -label "Add/Reset Outsource Tracker" -ann ""  -command "boltOutsourceTracker.Add";
						button -height 20 -width 250   -label "View tracking data in this file" -ann ""  -command "boltOutsourceTracker.View";
						button -height 20 -width 250   -label "Kill tracker in this file" -ann ""  -command "boltOutsourceTracker.Kill";
					setParent ..;
				setParent ..;		

			setParent ..;					
		setParent ..;
	setParent ..;   
                 		                             
	showWindow boltArchiveWindow;
	//display the window
}


global proc boltArchiveGUIRun()
//performs the achiving process using settings from the GUI
{

	
	
	string $path = `textField -q -text boltArchivePathField`;
	int $zip = `checkBox -q -value boltArchiveZipCheckbox`;
	boltArchiveFilesTo $path;
	
	string $uvTestPath = "M:/art/vehicles/GENERIC_TEXTURES/TEST/UV_testmap.jpg";
	string $destFileName = basename( $uvTestPath, "" );
	if (`filetest -f $uvTestPath`)
	{
		system ("copy \"" + `toNativePath $uvTestPath` + "\" \"" + `toNativePath ($path+$destFileName)` + "\" /y");
	}	
	//copy the UV test over
	
	
	if ($zip == 1) boltZipFolder $path;
}


global proc boltSetBrowsedFolder( string $filename, string $fileType )
{
    string $path = `fromNativePath $filename`;
    if (!(`endsWith "/" $path`)) $path = $path + "/";
	//make sure we have a trailing slash
    
    textField -e -text $path boltArchivePathField;
        
}




global proc string boltGetDefaultArchivePath()
//returns the default path for archiving vehicles to
{
	string $path = `file -q -sceneName`;
	string $file = `basenameEx $path`;
	string $dir = `match "^.*/" $path`;
	$dir = `tolower $dir`;
	
	if (`endsWith $dir "maya/"`)
	{
		$dir = `substring $dir 1 (size($dir)-5)`;
	}
	$dir = $dir + "source/" + $file + "_archived/";
	
	return $dir;
} 



global proc boltStripCar()
//cleans all game specific crap off vehicle, ready for rendering.
{
	boltConvertWheelsToNonReferenced;
	
	if (size(`ls "*_SWP*"`))
	{
		confirmDialog -title "Swap shapes found!" -message "Swap shapes must first be manually removed using one of the `Delete Swaps` options";
		error "Could not delete all game data - swap shapes need to be removed first";
	}
	
	boltDeleteAllHavok;
	if (size(`ls "*_LOD*"`)) delete "*_LOD*";
	if (size(`ls "CRUMPLEZONE_*"`)) delete "CRUMPLEZONE_*";
	if (size(`ls "SAFETYZONE_*"`)) delete "SAFETYZONE_*";
	boltRemoveHierarchy;
	if (size(`ls "*_COL"`)) delete "*_COL";
	boltRestoreHierarchy;
	boltUnrigB;
	boltUnrigF;
	string $lights[] = `ls -long -lights`;
	delete `listRelatives -parent $lights`;
	string $ambs[] = `ls -long -type "evoamboccvollocator"`;
	delete `listRelatives -parent $ambs`;
	if (size(`ls "FIRE_*"`)) delete "FIRE_*";
	if (size(`ls "STEAM_*"`)) delete "STEAM_*";
	if (size(`ls "*_DEAD"`)) delete "*_DEAD";
	if (size(`ls "NPC_CLING_*"`)) delete "NPC_CLING_*";
	if (size(`ls "*_mount_point"`)) delete "*_mount_point";
	if (size(`ls "RIDER_MOUNT"`)) delete "RIDER_MOUNT";
	if (size(`ls "REV_LOCATOR"`)) delete "REV_LOCATOR";
	if (size(`ls "*_hand"`)) delete "*_hand";
	if (size(`ls "*_wrist"`)) delete "*_wrist";
	if (size(`ls "BOOST_*"`)) delete "BOOST_*";
	//delete crap

	string $shapes[] = `ls -type "mesh"`;
	string $transforms[] = `boltShapesToTransformsNoPath $shapes`;
	for ($obj in $transforms)
	{
		string $parent[] = `listRelatives -parent $obj`;
		if (size($parent) == 0)
		{
			if ((objExists("BODY"))&&($obj != "BODY")) parent $obj "BODY";
		}
	}
	//parent all loose shapes to BODY
	
	if (objExists("BODY"))
	{
		string $vehicleType = `boltGetVehicleType`;
		string $filePath = `file -q -sn`;
		string $fileName = `match "[^/\\]*$" $filePath`;
		string $vehicleNo = `match "[0-9]+" $fileName`;
		rename "BODY" ($vehicleType + $vehicleNo);
	}
	//rename BODY node to name of car
}


	if ( catchQuiet(`loadPlugin measure.mll`) )
		{
			//confirmDialog -title "Bolt Poly Tools" -message "Can't find measure.mll - needed for physics calculations. To fix this please make sure that Bonus Tools for Maya is properly installed" -button "OK";
		}
	//make sure the measure plugin is loaded
	

	catchQuiet(`loadPlugin evoambientocc.mll`);



global proc boltDoTreeWeights(string $tree, string $trunk, float $maxDiameter)
{

	//setup cpom node
	boltPaintDam.GetVertDistFromMeshSetup($trunk);

	undoInfo -state off;
	//turn off otherwise maya runs out of memory.

	int $noVerts = GetNbMeshVerts($tree);
	$i = 0;

	for($k=0 ; $k < $noVerts; $k++)
	{
		$i++;
		if ($i == 200)
		{
			$i = 0;
			print ("\nProcessed: " + $k);
		}

		string $vert = ($tree+".vtx["+$k+"]");
		//go through each vertex
		float $dist = boltPaintDam.GetVertDistFromMesh($vert, $trunk);
		$dist = `clamp 0 1 ($dist/$maxDiameter)`;
		polyColorPerVertex -r $dist $vert;
		//assign colour
		//conversion to vfs needed to avoid alpha being screwed up.
	}
	refresh -force;
	undoInfo -state on;

	//delete cpom nodes
	boltPaintDam.GetVertDistFromMeshCleanup($trunk);

	print "\nTREE COLOURS DONE!";

}



global proc boltDoTreeWeights2(string $tree, float $maxDiameter, float $endHeight)
{
	undoInfo -state off;
	//turn off otherwise maya runs out of memory.

	int $noVerts = GetNbMeshVerts($tree);
	$i = 0;

	for($k=0 ; $k < $noVerts; $k++)
	{

		if ($i == 200)
		{
			$i = 0;
			print ("\nProcessed: " + $k);
		}
		$i++;

		string $vert = ($tree+".vtx["+$k+"]");
		//go through each vertex

		vector $inPos = `pointPosition -w $vert`;

		if ($inPos.y < $endHeight)
		{
			$inPos = <<($inPos.x),(0),($inPos.z)>>;
		}
		else
		{
			$inPos = <<($inPos.x),($inPos.y - $endHeight),($inPos.z)>>;
		}

		float $dist = mag($inPos);
		$dist = `clamp 0 1 ($dist/$maxDiameter)`;
		polyColorPerVertex -r $dist $vert;
		//assign colour
		//conversion to vfs needed to avoid alpha being screwed up.
	}
	refresh -force;
	undoInfo -state on;

	print "\nTREE COLOURS DONE!";

}

global proc boltDarkenCircle(float $startDist, float $startValue, float $endDist, float $endValue, vector $centre)
//for tree occlusion?
{
	string $objList[];

	string $selected[] = `ls -sl -long`;
	if (size($selected)>0)
	{
		$objList = $selected;
	}
	//if objs are selected, use those
	else
	{
		string $confirm = `confirmDialog -title "WARNING" -message "No objects selected!"`;
		return;
	}
	//warn user if nothing selected



	undoInfo -state off;
	//turn off otherwise maya runs out of memory.

	for ($obj in $objList)
	{
		int $noVerts = GetNbMeshVerts($obj);
		for($k=0 ; $k < $noVerts; $k++)
		{
			string $vert = ($obj+".vtx["+$k+"]");
			//go through each vertex

			float $colour;
			//set to grey

			vector $vertPos = `pointPosition -w $vert`;
			float $dist = `boltDistanceBetweenVectors $vertPos $centre`;
			//get the distance from the centre

			if ($dist > $endDist) $colour = $endValue;
			else if ($dist < $startDist) $colour = $startValue;
			else
			{
				float $distRange = $endDist - $startDist;
				float $distIn = $dist - $startDist;
				float $ratioIn = $distIn / $distRange;
				float $valueRange = $endValue - $startValue;
				$colour = $startValue + ($ratioIn * $valueRange);
			}
			//work out the colour


			string $vfs[] = `polyListComponentConversion -fv -tvf $vert`;
			polyColorPerVertex -a $colour $vfs;
			//print ("\nChanged " + $vert +" to " + $colour);
			//assign colour
			//conversion to vfs needed to avoid alpha being screwed up.

		}
		print ($obj + " occlusion colours set\n");
		refresh -force;
	}

	undoInfo -state on;
	//restore unfo



	print "OCCLUSION COLOURS DONE!\n";

}


//polyEditUV -relative false -uValue 1 -vValue 1 -uvSetName "damageWeightUVs";




global proc boltSetShaderScales(string $masterShader)
//measures uv to surface area ratio of master shader, then applies correct mud and damage scales to other shaders
{
	//disable this proc for now... but keep as it may come in handy again.
	warning "boltSetShaderScales is an MS2 proc and has been disabled"; return;

	string $originalLiveries[] = `boltGetCurrentLivery`;
	int $originalLivery = `endString $originalLiveries[0] 2`;
	//store the original livery

	string $materials[] = `ls -type "evocgfxShader"`;
	float $materialRatios[] = {};
	float  $masterRatio = 1;

	for ($m = 0; $m < size($materials); $m++)
	{

		if (`gmatch $materials[$m] "*_LV??"`)
		{
			int $livery = `endString $materials[$m] 2`;
			boltSwitchLivery $livery;
			//print ("\nSwitched to livery " + $livery);
			//ensure we are actually using each livery shader
		}

		string $sgs[] = `getSGFromMaterial $materials[$m]`;
		//work out its shading group

		string $sg;
		string $faceList1[] = {};

		for ($sg in $sgs)
		{
			string $newFaces[] = `sets -q $sg`;
			$faceList1 = `stringArrayCatenate $newFaces $faceList1`;
		}
		//get a list of all faces from all sgs.

		string $faceList[] = {};
		for ($face in $faceList1)
		{
			if (`match "\.f\\[" $face` == ".f[")
			{
				$faceList[size($faceList)] = $face;
			}
			//add if this is a face
			else
			{
				int $noPolys[] = `polyEvaluate -v $face`;
				string $tempFaceList[] = {};
				for ($f = 0; $f < $noPolys[0]; $f++)
				{
					$tempFaceList[size($tempFaceList)] = ($face + ".f[" + $f + "]");
				}
				$faceList = `stringArrayCatenate $tempFaceList $faceList`;
			}
			//work out all the individual faces for this shape
		}

		//print $faceList;

		int $count = 0;
		float $total = 0;

		$faceList = `filterExpand -sm 34 -ex 1 $faceList`;
		//flatten the list into individual faces


		for ($i = 0; $i < size($faceList); $i=$i+10)
		{

			//print ("\n face:" + $faceList[$i]);

			float $area3D = `boltGetPoly3DArea($faceList[$i])`;
			float $areaUV = `boltGetPolyUVArea($faceList[$i])`;

			if ($materials[$m]=="cage_LV01")
			{
				print ("\n 3d:" + $area3D);
				print ("\n UV:" + $areaUV);
			}

			if ($area3D>0 && $areaUV>0) //ignore anything with zero areas
			{
					$total = $total + ($areaUV/$area3D);
					//add up the uv/3d ratio for every 10th poly
					$count ++;
			}
		}

		float $avgRatio;
		if ($count > 0)
			$avgRatio = $total/$count;
		else
			$avgRatio = -1;

		$materialRatios[$m] = $avgRatio;

		print ("\n" + $materials[$m] + " ratio = " + $materialRatios[$m]);

		if ($materials[$m]==$masterShader) $masterRatio = $materialRatios[$m];

	}

	float $masterMudScale = `getAttr ($masterShader+".dirtUVScaleX")`;
	float $masterDamScale = `getAttr ($masterShader+".damageUVScaleX")`;


	if ($materialRatios[$m] == -1)
	{
		print ("\nNo faces or UVs found for " + $materials[$m]);
		//catch sqrt error
	}
	else
	{
		for ($m = 0; $m < size($materials); $m++)
		{
			if ($materials[$m] != $masterShader)
			{

				print ("\n" + $materials[$m] + " master ratio:" + $masterRatio + " / Material ratio:" + $materialRatios[$m]);

				float $mudScale = sqrt(($masterRatio/$materialRatios[$m]) * ($masterMudScale*$masterMudScale));
				float $damScale = sqrt(($masterRatio/$materialRatios[$m]) * ($masterDamScale*$masterDamScale));

				setAttr ($materials[$m]+".dirtUVScaleX") $mudScale;
				setAttr ($materials[$m]+".dirtUVScaleY") $mudScale;
				setAttr ($materials[$m]+".damageUVScaleX") $damScale;
				setAttr ($materials[$m]+".damageUVScaleY") $damScale;

				print ("\n" + $materials[$m] + " mud and damage UV scales set");
			}
		}
		//work out and set final ratios in shaders
	}

	boltSwitchLivery $originalLivery;
	//restore originally displayed livery

	print "\nMud and damage scale settings complete!";

}


global proc boltClearBlueChannel()
//sets everything to full texturedness
{
	string $objList[] = `ls -type "mesh"`;
	for ($obj in $objList)
		polyColorPerVertex -b 1 $obj;
}




global proc boltAddPlaceHolderMeshes(string $objs[])
//replaces the locator or mesh of the specified transform with a geometry placeholder cube
{
	boltRemoveHierarchy;
	string $dontDrawShader = boltGetShaderToApply("m:/assets/noodle/materials/library/vehicles/dont_draw_me.xml");
	
	for ($obj in $objs)
	{
		//print ("\nProcessing " + $obj + "...");
		
		string $meshes[] = `listRelatives -children -type "mesh" $obj`; 
		string $locs[] = `listRelatives -children -type "locator" $obj`;
		$locs = `ls -exactType "locator" $locs`; //filter out havok
		
		if ( size($meshes)>1 || size($locs)>1) 
		{
			error ("Error adding place holder meshes - " + $obj + " has more than 1 mesh shape node.");
		}
		if ( size($meshes)==0 && size($locs)==0) 
		{
			error ("Error adding place holder meshes - " + $obj + " has no shape or locator nodes.");
		}
					
		if (size($meshes)==1)
		//replace geometry with cube
		{
			//print "\nCreating Bounding Box...";
			
			//create bounding box
			float $bb[] = `polyEvaluate -b $obj`;
			float $pos[]  = `xform -q -t -ws $obj`; //{ ($bb[0]+$bb[1])/2 , ($bb[2]+$bb[3])/2 , ($bb[4]+$bb[5])/2 };
			float $size[] = { ($bb[1]-$bb[0]) , ($bb[3]-$bb[2]) , ($bb[5]-$bb[4]) };
			string $cube[] = `polyCube -w 1 -h 1 -d 1 -ch 0`;//`polyCube -w $size[0] -h $size[1] -d $size[2] -ch 0`;
			setAttr ($cube[0]+".t") $pos[0] $pos[1] $pos[2];
			
			//give it some vertex colours otherwise conditioning can fail
			polyColorPerVertex -r 0 -g 0 -b 0 -a 1 $cube[0];
			
			//print "\nMatching pivots...";
			
			//match pivots of old and new
			boltMatchPivotFast($cube[0], $obj);
			
			//print "\nCopying Havok...";
			
			//copy havok shapes over to bounding box
			string $havokNodes[] = `listRelatives -children -type "hkNodeRigidBody" -type "hkNodeShape" -type "hkNodeHingeConstraint" -type "hkNodeRagDollConstraint" -fullPath $obj`;
			for ($havokNode in $havokNodes)
			{
				parent -shape -relative $havokNode $cube[0];
			}
			
			//print "\nDeleting old geometry...";
			
			//delete old and rename new
			delete $obj;
			rename $cube[0] $obj;
			boltRenameShape $obj;
			
		}
		else if(size($locs)==1)
		//replace locator with cube
		{
			string $cube[] = `polyCube -w 1 -h 1 -d 1 -ch 0`;
			
			//give it some vertex colours otherwise conditioning can fail
			polyColorPerVertex -r 0 -g 0 -b 0 -a 1 $cube[0];
			
			float $m[]= `xform -q -matrix $obj`;
			xform -matrix $m[0] $m[1] $m[2] $m[3] $m[4] $m[5] $m[6] $m[7] $m[8] $m[9] $m[10] $m[11] $m[12] $m[13] $m[14] $m[15] $cube[0];
			delete $obj;
			rename $cube[0] $obj;
			boltRenameShape $obj;
			
		}
		
		//print "\nApplying shader...";
		
		select -cl;
		select $obj;
		boltMatLibSetShader($dontDrawShader);
		//apply the shader to the object
		
		//print "\nZeroing Pivot offset...";
		
		select -cl;
		select $obj;
		zeroPivotOffset;
		
		print ("\n" + $obj + " replaced by a placeholder cube.");
		
	}
	
	//print "\nRestoring Hierarchy...";
	
	boltRestoreHierarchy;
	
	//print "\nDone...";
}