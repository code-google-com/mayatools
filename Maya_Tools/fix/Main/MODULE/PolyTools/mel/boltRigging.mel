

// requires boltShatter boltDenter boltHierarchy boltCarData

source boltHierarchy; 
source boltCarData;
source boltDamage;
source boltVertexColours;

// Usage: sFindItem array value
// Returns the 0-based index of the first occurence of the value in the array
// If the specified value is not in the array, returns -1
proc int sFindItem (string $array[], string $value)
{
	int $i;
	if (`size($array)` > 0) {
		for ($i = 0; $i <= `size($array)`; $i++)
		{
			if ($array[$i] == $value) {
				return $i;
			}
		}
	}
	return -1;
}

global proc boltRigging.GUI()
{
	if (`window -exists boltRiggingWindow`) {deleteUI boltRiggingWindow;} 
	//delete the window if it already exists
	
	window -title "Rigging & Physics Toolbox" -menuBar true -toolbox 1 boltRiggingWindow;
		
		menu -label "Help" -tearOff true -allowOptionBoxes true;
			menuItem -label "WIKI Help Page" -command "showHelp -a \"http://43.193.223.115:8080/mediawiki/index.php/BPT_NormalToolBox\"";

			columnLayout;
				
				

				frameLayout -collapsable 1 -label "Damage Vertex Colours" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 5;
							button -height 20 -width 42 -recomputeSize 0 -label "Scratch"	-backgroundColor 1 0.29 0.29 -command "boltEditDebugPresets RVertexCol" -ann "Shows the scratch colours (colorSet1 red channel)";
							button -height 20 -width 46 -recomputeSize 0 -label "Direction"	-backgroundColor 0.29 0.29 1 -command "boltEditDebugPresets BVertexCol" -ann "Shows the scratch direction colours (colorSet1 blue channel)";
							button -height 20 -width 40 -recomputeSize 0 -label "Lookup"	-backgroundColor 1 0.47 0.95 -command "boltEditDebugPresets DamCols1" -ann "Shows the damageLookup_colorSet rgb";
							button -height 20 -width 40 -recomputeSize 0 -label "Vectors"	-backgroundColor 1 0.95 0.47 -command "boltEditDebugPresets DamCols2" -ann "Shows the damageVector_colorSet rgb";
							button -height 20 -width 25 -recomputeSize 0 -label "Off"	-command "boltRemoveDebugShaders(1)" -ann "Returns to normal shaded view";
						setParent ..;
						rowLayout -numberOfColumns 3;
							button -height 20 -width 75 -recomputeSize 0 -label "Paint Scratch" -ann "New method, works better with darker ground AO shadow. Paints scratch colours to selected objects, or all objects if none selected." -command "boltDam.paintDamageScratchGUI 1";
							button -height 20 -width 25 -recomputeSize 0 -label "Old" -ann "Uses old method. Paints scratch colours to selected objects, or all objects if none selected." -command "boltDam.paintDamageScratchGUI 0";
							button -height 20 -width 100 -recomputeSize 0 -label "Paint Lookup Cols" -ann "Paints damage lookup colours to selected objects, or all objects if none selected." -command "boltDam.paintDamageLookupGUI";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Paint No Scratches" -ann "Sets scratch colours to black for selected objects, or all objects if none selected." -command "boltDam.paintDamageScratchOffGUI";
							button -height 20 -width 100 -recomputeSize 0 -label "Zero Dam Vectors" -ann "Paints zeroed deformation vectors to selected objects, or all objects if none selected." -command "boltDam.paintDamageVectorOffGUI";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -recomputeSize 0 -label "Paint Default Scratch Direction" -ann "Sets scratch direction colours to black for selected objects, or all objects if none selected. Preserves light colours" -command "boltDam.paintDamageScratchDirectionDefaultGUI";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Store Light Cols" -ann "Saves the light colours to memory - handy to do before painting scratch direction in to the same blue channel" -command "boltDam.storeLightColours()";
							button -height 20 -width 100 -recomputeSize 0 -label "Restore Light Cols" -ann "Restores light vertex colours from memory. Handy if you have painted over them when setting scratch direction" -command "boltDam.restoreLightColours()";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 100 -recomputeSize 0 -label "Fix Broken Boost" -ann "Repairs the red colour channel of all boost geometry that has been broken by the scratch colour tool" -command "boltDam.fixBrokenBoost";
						setParent ..;
						
						
					setParent ..;
				setParent ..;	
				
				
				frameLayout -collapsable 1 -label "Damage Modelling" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;		
						rowLayout -numberOfColumns 1;
							button -height 20 -width 200  -recomputeSize 0 -label "1. Create Damage Shapes" -ann "Creates '_DAM' damage shapes for selected LOD0 objects" -command "boltDam.CreateDamageShapes()";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 200 -recomputeSize 0 -label "2. Paint Damage Vectors" -ann "Paints damage vectors from your '_DAM' objects, to selected LOD0 objects, or all LOD0 objects if none selected. Needs damage shapes to calculate from." -command "boltDam.paintDamageVectorGUI";
						setParent ..;
						//rowLayout -numberOfColumns 1;
						//	button -height 20 -width 200 -recomputeSize 0 -label "3. Transfer Damage To LODs" -ann "Transfers LOD0 damage vector colours to selected LODs, or all LODs if none selected." -command "boltDam.transferDamageVectorsGUI(1)";
						//setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 200 -recomputeSize 0 -label "3. Transfer Damage To LODs (Slow)" -ann "More accurate, but slower method. Transfers LOD0 damage vector colours to selected LODs, or all LODs if none selected." -command "boltDam.transferDamageVectorsGUI(2)";
						setParent ..;
						//rowLayout -numberOfColumns 1;
						//	button -height 20 -width 200 -recomputeSize 0 -label "Transfer Damage From Lod1" -ann "Transfers LOD1 damage vector colours to selected LODs." -command "boltDam.transferDamageVectorsFromLod1GUI(1)";
						//setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 200 -recomputeSize 0 -label "Transfer Damage From Lod1 (Slow)" -ann "More accurate, but slower method. Transfers LOD1 damage vector colours to selected LODs." -command "boltDam.transferDamageVectorsFromLod1GUI(2)";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100  -recomputeSize 0 -label "Copy Damage" -ann "Copies average damage vector from selected verts" -command "boltDamageVectorCopy";
							button -height 20 -width 100  -recomputeSize 0 -label "Paste Damage" -ann "Pastes copied damage vector to selected verts" -command "boltDamageVectorPaste";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100  -recomputeSize 0 -label "Heal Damage" -ann "Fixes rogue damage vectors that have been transfered to lods incorrectly" -command "boltHealDamageVector";
							button -height 20 -width 100  -recomputeSize 0 -label "Dent Tool" -ann "Applies MS3 style procedural damage effects in maya" -command "source boltDenter; boltDenter";
						setParent ..;
						rowLayout -numberOfColumns 1;
							button -height 20 -width 200 -recomputeSize 0 -label "Copy damage colours to _DAM object" -ann "Transfers LOD damage colours back to damage geometry for easier fine tuning and editing" -command "boltDam.copyDamageVectorToDamObjGUI()";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Fracture"  -ann "Splits 1st selected object into 2 pieces, using second selected object as a fracture plane" -command "boltFracture";
							button -height 20 -width 100  -recomputeSize 0 -label "Poly Cutter" -ann "Polygon cutting, stenciling, and shattering tool" -command "source boltShatter; boltShatter.GUI()";
						setParent ..;
						//button -height 20 -width 100  -recomputeSize 0 -label "Create Deads" -ann "Creates deadshape versions of currently slected objects, and places them correctly in the hierarchy" -command "boltCreateDeadShapes;";
						//button -height 20 -width 90  -recomputeSize 0 -label "Add Particle Cols" -backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Add approximate particle collison boxes to scene" -command "boltAddParticleCollison" boltButtonParticleCol;
						//button -height 20 -width 90  -recomputeSize 0 -label "Add ClingonLocs" -backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Add locators for NPC clingon grab points" -command "boltAddNPCClingLocators" boltButtonClingonLocs;
					setParent ..;
				setParent ..;

				frameLayout -collapsable 1 -label "Game Setup" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Add Occlusion Vol"  -ann "Adds an Evo Ambient occlusion volume to the scene" -command "boltAddOcclusionVolume()";
							button -height 20 -width 100 -recomputeSize 0 -label "Add Light Probes"  -ann "Adds interior light probe to the scene" -command "boltAddLightProbes()";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Add Photo Mirrors"  -ann "Adds photo mode mirror shaders and evo attribute nodes" -command "boltAddPhotoMirrors()";
							button -height 20 -width 100 -recomputeSize 0 -label "Windscreen Sorting"  -ann "Sets up the new sorting tech on the windscreen" -command "boltWindscreenSorting()";
						setParent ..;
						rowLayout -numberOfColumns 2;
							button -height 20 -width 100 -recomputeSize 0 -label "Tag Interior Only"  -ann "Tags selected nodes as interior only - eg windscreen reflections" -command "boltTagInterior()";
							button -height 20 -width 100 -recomputeSize 0 -label "Tag Exterior Only"  -ann "Tags selected nodes as exterior only - any thing that can't be seen form cockpit view" -command "boltTagExterior()";
						setParent ..;
						
						
						
						
					setParent ..;
				setParent ..;


				frameLayout -collapsable 1 -label "Havok" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
					columnLayout;

	    				//text -width 200 -align "left" -font "boldLabelFont" -label "Detachable Parts:";
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "BUMPER_F*"		-ann "BUMPER_F will be detachable"		rigCheckBox02;
	    					checkBox -enable 0 -value 0 -label "BUMPER_B*"		-ann "BUMPER_B will be detachable"		rigCheckBox03;
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "DOOR_*"		-ann "All doors will be detachable"			rigCheckBox04;   
	    					checkBox -enable 0 -value 0 -label "BONNET"		-ann "Bonnet will be detachable"			rigCheckBox05;   
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "BOOT"			-ann "Boot will be detachable"				rigCheckBox06;   
	    					checkBox -enable 0 -value 0 -label "LIGHT_F*"		-ann "Front lights will be detachable"		rigCheckBox07;   
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "LIGHT_B*"		-ann "Back lights will be detachable"		rigCheckBox08;   
	    					checkBox -enable 0 -value 0 -label "SPOT_*"		-ann "Spot Lights will be detachable"		rigCheckBox09;   
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;;
	    					checkBox -enable 0 -value 0 -label "MIRROR_*"		-ann "Mirrors will be detachable"			rigCheckBox10;   
	    					checkBox -enable 0 -value 0 -label "SPOILER"		-ann "Spoiler will be detachable"			rigCheckBox11;   
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "WING_F*"		-ann "Front wings will be detachable"		rigCheckBox13;   
	    					checkBox -enable 0 -value 0 -label "WING_B*"		-ann "Back wings will be detachable"		rigCheckBox14;   
	            		setParent ..;                      	
	    				
	    				//separator -style "in" -horizontal 1 -height 10 -width 200;	    			    			
	    				
	    				//text -width 200 -align "left" -font "boldLabelFont" -label "Hinged Parts";         	
	    				
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "DOOR*"		-ann "All doors will be hinged"				rigCheckBox20;   
	    					checkBox -enable 0 -value 0 -label "BONNET"		-ann "Bonnet will be hinged"				rigCheckBox21;   
	    				setParent ..;
	    				checkBox -visible 0 -enable 0 -value 0 -label "BOOT"			-ann "Boot will be hinged"					rigCheckBox22;   
	    				
	    				//separator -enable 0 -style "in" -horizontal 1 -height 10 -width 200;	    			    			
	    				
	    				//text -width 200 -align "left" -font "boldLabelFont" -label "Wobbly Parts (hinge constraints):";         	
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "BUMPER_F"			-ann "BUMPER_F will be wobbly"				rigCheckBox70;
	    					checkBox -enable 0 -value 0 -label "BUMPER_B"			-ann "BUMPER_B will be wobbly"				rigCheckBox71;
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "LIGHT_F*"			-ann "Front lights will be wobbly"			rigCheckBox72;   
	    					checkBox -enable 0 -value 0 -label "LIGHT_B*"			-ann "Back lights will be wobbly"			rigCheckBox73;   
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "MIRROR_*"			-ann "Mirrors will be wobbly"				rigCheckBox74; 
	    					checkBox -enable 0 -value 0 -label "SPOILER"			-ann "Spoiler will be wobbly"				rigCheckBox76;   
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "SPOT_*"			-ann "Spot Lights will be wobbly"			rigCheckBox77; 
	    					checkBox -enable 0 -value 0 -label "WING_F*"			-ann "Front wings will be wobbly"			rigCheckBox79;   
	    				setParent ..;
	    				checkBox -visible 0 -enable 0 -value 0 -label "WING_B*"			-ann "Back wings will be wobbly"			rigCheckBox80;   
	    				
	    				//separator -style "in" -horizontal 1 -height 10 -width 200;	    			    			
	    				
	    				//text -width 200 -align "left" -font "boldLabelFont" -label "Droopy parts (ragdoll constraints):"; 
	    				
	    				//checkBox -value 1 -label "BUMPER_F"		-ann "BUMPER_F will be Droopable"			rigCheckBox90;
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 0 -label "BUMPER_B"		-ann "BUMPER_B will be Droopable"			rigCheckBox91;
	    					checkBox -enable 0 -value 0 -label "DOOR*"		-ann "All doors will be Droopable"			rigCheckBox92;  
	    	    		setParent ..;
	    	    		
	    				//separator -style "in" -horizontal 1 -height 10 -width 200;
	    				
	    				//text -width 200 -align "left" -font "boldLabelFont" -label "Collision boxes";
	    				
	    				rowLayout -numberOfColumns 2 -visible 0;
	    					checkBox -enable 0 -value 1 -label "BODY_COL"		-ann "Main body collision will be added"	rigCheckBox40;   
	    					checkBox -enable 0 -value 0 -label "RAGDOLL_*"	-ann "Ragdoll collision will be added"		rigCheckBox41;   
	    				setParent ..;
	    				
	    				//separator -style "in" -horizontal 1 -height 10 -width 200;
	    				checkBox -value 1 -label "Delete Existing Havok Nodes"		-ann "Deletes all existing havok nodes"	rigCheckBox60;   
	    					    		
	    				separator -style "in" -horizontal 1 -height 10 -width 200;
						
						//rowLayout -numberOfColumns 2;
						//	button -height 20 -width 100 -recomputeSize 0 -label "All On" 	-command "boltSwitchHavokOptions 1" -ann "Turns everything on";
						//	button -height 20 -width 100 -recomputeSize 0 -label "All Off" 	-command "boltSwitchHavokOptions 0" -ann "Turns everything off";
						//setParent ..;
						//rowLayout -numberOfColumns 1; 
						//	button -height 20 -width 202 -recomputeSize 0 -label "Define User Edited Nodes" -command "boltUserEditedHavokGUI" -ann "Allows you to flag user defined custom havok nodes - these will not then be overwritten or deleted by the add Havok tool";
	    				//setParent ..;                
						//rowLayout -numberOfColumns 1;
	    				//	button -height 20 -width 202 -recomputeSize 0 -label "Move hinges to selection center" 	-command "boltMoveHKHinge" -ann "Moves the hinges on the object to the center of the selected verts, edges, or faces.";
						//setParent ..;                
						rowLayout -numberOfColumns 1;
							button -height 20 -width 202 -recomputeSize 0 -label "Add Havok nodes" 	-command "boltAddHavokNodes" -ann "Removes and rebuilds all havok nodes with the above options";
	    				setParent ..;
	    				rowLayout -numberOfColumns 2 -cw2 150 50;
	    					button -height 20 -width 150 -recomputeSize 0 -label "Delete Havok (Selected)" 	-command "boltRemoveHavok" -ann "Deletes all havok nodes on selected objects";
	    					button -height 20 -width 50 -recomputeSize 0 -label "All" 	-command "boltDeleteAllHavokGUI" -ann "Deletes all havok nodes in the scene";
	    				setParent..;
	    				//button -height 20 -width 200 -recomputeSize 0 -label "Copy Havok nodes to swaps" 	-command "boltCopyAllHavokToSwapsGUI" -ann "Copies all existing havok nodes to swap shapes, ready for any further adjustments";
						//checkBox -value 1 -label "Delete Existing Swap Havok"		-ann "Any exisitng swap shape Havok nodes will be deleted and replaced with fresh copies." boltHavokDeleteExisting; 	
					setParent ..;
				setParent ..;
	  
	  
	 			//frameLayout -collapsable 1 -label "Rigging" -mw 5 -mh 5 -labelAlign "center" -borderStyle "etchedOut";
				//	columnLayout;
				//		rowLayout -numberOfColumns 2;
				//			button -height 20 -width 100 -recomputeSize 0 -label "Rig Wishbone..." -ann "Rigs suspension - suitable for single wishbone, double wishbone, or McPherson strut style suspension." -command "boltRigWishbone";
				//			button -height 20 -width 100 -recomputeSize 0 -label "Rig Solid Axle..." -ann "Rigs suspension - suitable for solid axle, trailing arm, style suspension." -command "boltRigSolidAxle";
				//		setParent ..;
				//		rowLayout -numberOfColumns 2;
				//			button -height 20 -width 100  -recomputeSize 0 -label "Unrig Front"  -ann "Removes rigging from front suspension" -command "boltUnrigF;";
				//			button -height 20 -width 100  -recomputeSize 0 -label "Unrig Back" -ann "Removes rigging from back suspension" -command "boltUnrigB;";
				//		setParent ..;
				//		rowLayout -numberOfColumns 2;
				//			button -height 20 -width 100  -recomputeSize 0 -label "Animate Susp"  -ann "Adds random keyframes to steering and wheel height" -command "boltAnimateSuspensionRandom;";
				//			button -height 20 -width 100  -recomputeSize 0 -label "Un Animate Susp" -ann "Removes suspension animation" -command "boltUnAnimateSuspension;";
				//		setParent ..;
				//		//button -height 20 -width 100 -recomputeSize 0 -label "Add Occlus. Vol" -backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Adds ambient occlusion volume to the scene" -command "boltAddOcclusionVolume" boltButtonAddOcclusionVolumes;
				//		//button -height 20 -width 100 -recomputeSize 0 -label "Add Ragdoll Vols" -backgroundColor $colBolt[0] $colBolt[1] $colBolt[2] -ann "Adds ragdoll collision volumes to the scene" -command "boltAddRagdollVolumes" boltButtonAddRagdollVolumes;
				//	setParent ..;
				//setParent ..;
	  
	  
	  
	  
			setParent ..;					
		
	setParent ..;   
	
	showWindow boltRiggingWindow;
	//display the window
	
	window -e -height 302 -width 200 boltRiggingWindow;

}


//auto setup of sorted windscreen
global proc boltWindscreenSorting()
{
	$win = "WINDOW_F";
	$win2 = "WINDOW_F2";
	$win_lod = "WINDOW_F_LOD1";
	$win2_lod = "WINDOW_F2_LOD1";
	
	//quit if already done
	if (`objExists $win2`) error "WINDOW_F2 already exists in scene - has windsceen sorting already been setup?";
	if (`objExists $win2_lod`) error "WINDOW_F2_LOD1 already exists in scene - has windsceen sorting already been setup?";
	if (!`objExists $win`) error "WINDOW_F not found in scene - can't setup windsceen sorting";
	if (!`objExists $win_lod`) error "WINDOW_F_LOD1 not found in scene - can't setup windsceen sorting";
	
	//get windscreen shader
	string $winShader = "";
	string $materials[] = boltGetMaterialsOnObj($win);
	if (size($materials) > 1) error "More than 1 shader found on WINDOW_F - tool expects only glass_laminated_damage";
	for ($mat in $materials)
	{
		$xmlpath =  boltGetShaderPreset($mat);
		if (`gmatch $xmlpath "*glass_laminated_damage.xml"`) $winShader = $mat;
	}
	if ($winShader == "") error ("Could not find glass_laminated_damage.xml shader preset on " + $win);
	
	boltRemoveHierarchy;
	
	//dupe windscreens
	$newScreen = `duplicate -rr $win`;
	rename $newScreen[0] $win2;
	$newScreen_lod = `duplicate -rr $win_lod`;
	rename $newScreen_lod[0] $win2_lod;
	
	//create new shaders
	string $inside[] = `duplicate -inputConnections $winShader`; //preserves user defined glass textures for us
	string $outside[] = `duplicate -inputConnections $winShader`;
	setAttr -type "string" ($inside[0] + ".RawPath") "M:/assets/noodle/Materials/Library/Vehicles_DC/glass/glass_laminated_damage_inside.xml";
	setAttr -type "string" ($outside[0] + ".RawPath") "M:/assets/noodle/Materials/Library/Vehicles_DC/glass/glass_laminated_damage_outside.xml";
	string $outShad = `rename $outside[0] "glass_laminated_damage_outside"`;
	string $inShad = `rename $inside[0] "glass_laminated_damage_inside"`;
	
	//replace with single sided shaders
	select -r $win $win_lod; hyperShade -assign $inShad;
	select -r $win2 $win2_lod; hyperShade -assign $outShad;
	
	//flip normals on inside
	select -r ($win + ".f[*]");
	ReversePolygonNormals;
	select -r ($win_lod + ".f[*]");
	ReversePolygonNormals;
	select -cl;
	
	//fixes screwed up uvs?
	select -r ($win + ".f[*]"); select -cl;
	select -r ($win_lod + ".f[*]"); select -cl;
	
	//fix hierarchy
	boltRestoreHierarchy;
	parent $win2 $win;
	parent $win2_lod $win2;
}



global proc boltAddPhotoMirrors()
{
	
	string $nodes[] = `ls -long "MirrorPointNode*"`;
	if (size($nodes) > 0)
	{
		string $confirm = `confirmDialog -title "Add Photo Mirrors" 
			-message "Existing mirror point nodes found in the scene. Delete and add new ones?" 
			-button "Delete Exisiting" -button "Quit" 
			-defaultButton "Quit" -cancelButton "Quit" -dismissString "Quit"`;
		if ($confirm == "Delete Exisiting")
		{
			for ($node in $nodes) delete `listRelatives -parent $node`;
		}
		else
		{
			return; 
		}
	}
	//delete existing volumes?
	
	//import shaders if needed
	$mirrorShaders = {"mirror_rearview","mirror_rearview_l","mirror_rearview_r"};
	for ($shader in $mirrorShaders)
	{
		if (objExists($shader) == 0)
		{			
			string $materialPath = ("M:/assets/noodle/Materials/Library/Vehicles_DC/" + $shader + ".xml");
			string $shaderNode = `shadingNode -asShader ATGMaterial -name $shader`;                                                                 
			setAttr ($shaderNode + ".SelectMode") 0;                                                        
			setAttr -type "string" ($shaderNode + ".RawPath") $materialPath;
			$shadingGroup = `sets -renderable true -noSurfaceShader true -empty -name ($shaderNode+"SG")`;
			connectAttr -f ($shaderNode+".outColor") ($shadingGroup+".surfaceShader");
			//add a shading group
		}
		
	}
	
	boltSetupMirror ("MIRROR_L", "mirror_rearview_l", 0);
	boltSetupMirror ("MIRROR_R", "mirror_rearview_r", 1);
	boltSetupMirror ("INTERIOR_SHELL", "mirror_rearview", 2);
}


global proc boltSetupMirror (string $obj, string $shader, int $position)
{	
	//apply shaders to wing mirrors
	
	if (objExists($obj))
	{
		string $mirrorPolys[] = boltListShadedPolygons({$obj}, "mirror_rearview");
		string $sg[] = `getSGFromMaterial $shader`;
		sets -fe $sg[0] $mirrorPolys;
		
		$mirrorPolys = boltListShadedPolygons({$obj}, $shader);
			
		//find mirror centers, and apply evo attr nodes	
		if (size($mirrorPolys) == 0) 
		{
			error ($obj + " mirror polygons not found!");
		}
		else
		{
			select -r $mirrorPolys;
			float $bb[6] = `polyEvaluate -bc`;
			float $center[] = { ($bb[0]+$bb[1])/2 , ($bb[2]+$bb[3])/2 , ($bb[4]+$bb[5])/2 };
		
			string $mirrorNode =  `createNode evoAttributeNode`;
			$mirrorNode = `evoAttrib -as "MirrorPoint" $mirrorNode`;
			//columnLayout -edit -visible false evoAttribMaincol;
			setAttr ($mirrorNode + ".Position") $position;
			string $transformNodes[] =  `listRelatives -parent $mirrorNode`;
			string $transformNode =  $transformNodes[0];
			setAttr ($transformNode + ".translate") $center[0] $center[1] $center[2];
			setAttr ($transformNode + ".scale") 0.020 0.020 0.020;
			setAttr ($transformNode + ".rotateX") -90;
			parent $transformNode $obj;
			rename $transformNode ($obj + "_MIRRORPOINT");
		}
	}	
}


global proc boltCreateDeadShapes()
//clones selected geometry to a dead shape ready for modification
//edited to get swap part naming order correct
{
	string $selection[] = `ls -o -sl`;
	
	int $spreadFlag = 0;
	if (objExists("spreadCarScriptNode"))
	{
		error "Create Deads tool is disabled while car is spread!";
	}
	
	for ($obj in $selection)
	{
		
		string $deadShapeP[]   = `listRelatives -type "transform" -parent $obj`;
		
		boltRemoveHierarchy;
		//strip hierarchy
		
		if (`gmatch $obj "*_LOD?" `)
		{
			int $sizeObj = size($obj);
			string $baseObj =  `substring $obj 1 ($sizeObj - 5)`;
			string $lodNo = `substring $obj ($sizeObj - 4) ($sizeObj)`;
			
			string $deadObj;
			
			if (`gmatch $obj "*_SWP*"`)
			{
				$deadObj = (`substitute "_SWP" $obj "_DEAD_SWP"`);
			}
			else
			{
				$deadObj = ($baseObj + "_DEAD" + $lodNo);
			}
					
			if (`objExists $deadObj`) delete $deadObj;
			duplicate -n $deadObj $obj;
			boltDeleteHavokNodes $deadObj;
			
			string $deadParent = ($baseObj + "_DEAD");
			if (`objExists $deadParent`) parent $deadObj $deadParent; 
			
			print ("\n" + $deadObj + " CREATED\n");			
		}
		//creates dead shapes from lods
		else
		{
			string $deadObj;
			
			if (`gmatch $obj "*_SWP*"`)
			{
				$deadObj = `substitute "_SWP" $obj "_DEAD_SWP"`;
			}
			else
			{
				$deadObj = ($obj + "_DEAD");
			}
			
			if (`objExists $deadObj`) delete $deadObj;
			duplicate -n $deadObj $obj;
			boltDeleteHavokNodes $deadObj;
			
			if ($deadShapeP[0] != "") parent $deadObj $deadShapeP[0]; 
			print ("\n" + $deadObj + " CREATED\n");
		}
		//creates dead shape from base object.
		
		boltRestoreHierarchy;
	}
	
	print "\nDEAD SHAPE CREATION SUCCESSFUL\n";
}


















global proc boltRigWishbone()
//gui for boltDoRigWishbone()
{

if (`window -exists boltRigWindow`) {deleteUI boltRigWindow;} 
//delete the window if it already exists 

window -height 162 -width 208 -title "Rig Wishbone Suspension" -toolbox 1 boltRigWindow;
	//create window
		formLayout rigWishboneFormLayout;
			checkBox -label "Front" -ann "apply to front suspension"  boltCheckBoxF; 	
			checkBox -label "Back" 	-ann "apply to back suspension"   boltCheckBoxB; 	
			optionMenu -label "Connect shocks to:"  boltOptionMenuShockConnection;
 				menuItem -label "WISHBONE_B"  	boltMenuItemWishboneT;
 				menuItem -label "WISHBONE_T"  	boltMenuItemWishboneB;
				menuItem -label "HUB_"  		boltMenuItemHub;
			button -height 20 -width 188 -recomputeSize 0 
				   -label "Rig Suspension" -ann "Goes ahead and rigs the suspension according to your settings"
				   -command ("string $cornerList[] = {}; string $shockMount;" +
							"if (`checkBox -q -value boltCheckBoxF` == 1) {$cornerList[`size($cornerList)`] = \"FL\"; $cornerList[`size($cornerList)`] = \"FR\";}" +
							"if (`checkBox -q -value boltCheckBoxB` == 1) {$cornerList[`size($cornerList)`] = \"BL\"; $cornerList[`size($cornerList)`] = \"BR\";}" +
							"$shockMount = `optionMenu -q -value boltOptionMenuShockConnection`;" +
							"boltDoRigWishbone $cornerList $shockMount;")
					boltButtonRig;
				
formLayout -e	
	-af "boltCheckBoxF" 				"left" 50 	-af "boltCheckBoxF" 					"top" 10
	-af "boltCheckBoxB" 				"left" 130 	-af "boltCheckBoxB" 					"top" 10
	-af "boltOptionMenuShockConnection" "left" 1 	-af "boltOptionMenuShockConnection" 	"top" 70                                                                          
	-af "boltButtonRig" 				"left" 6 	-af "boltButtonRig" 					"top" 110 
	rigWishboneFormLayout;    

                                 
showWindow boltRigWindow;
//display the window
}



global proc boltRigSolidAxle()
//gui for boltDoSolidAxle()
{

if (`window -exists boltRigWindow`) {deleteUI boltRigWindow;} 
//delete the window if it already exists 

window -height 162 -width 230 -title "Rig Solid Axle Suspension" -toolbox 1 boltRigWindow;
	//create window
		columnLayout;
			optionMenu -label "Connect shocks to:"  boltOptionMenuShockConnection;
 				menuItem -label "TRAILING_ARM_" boltMenuItemTrailingArm;
 				menuItem -label "HUB_"  		boltMenuItemHub;
 				menuItem -label "AXLE_"  		boltMenuItemAxle;
 			optionMenu -label "Connect tierods to:"  boltOptionMenuTierodConnection;
 				menuItem -label "BODY" 			boltMenuItemTieBody;
 				menuItem -label "AXLE_"  		boltMenuItemTieAxle;
 			button -height 20 -width 188 -recomputeSize 0 
				   -label "Rig Front Solid Axle" -ann "Rigs the front suspension according to your settings"
				   -command ("string $shockMount;" +
							"$shockMount = `optionMenu -q -value boltOptionMenuShockConnection`;" +
							"string $tieMount;" +
							"$tieMount = `optionMenu -q -value boltOptionMenuTierodConnection`;" +
							"boltDoRigSolidAxle \"F\" $shockMount $tieMount;")
					boltButtonRigF;
			button -height 20 -width 188 -recomputeSize 0 
				   -label "Rig Back Solid Axle" -ann "Rigs the back suspension according to your settings"
				   -command ("string $shockMount;" +
							"$shockMount = `optionMenu -q -value boltOptionMenuShockConnection`;" +
							"string $tieMount;" +
							"$tieMount = `optionMenu -q -value boltOptionMenuTierodConnection`;" +
							"boltDoRigSolidAxle \"B\" $shockMount $tieMount;")
					boltButtonRigB;		
			
                       
showWindow boltRigWindow;
//display the window
}

global proc boltDoRigWishbone(string $cornerList[], string $shockMount)
//rigs wishbone suspension
{
	
//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Move pivots
	
	for ($corner in $cornerList)   
	{

		if( `objExists ("HUB_"+$corner)`) 
		{
			float $wheelAttr[] = `xform -q -ws -rp ("WHEEL_"+$corner)`;
			float $hubAttr[] = `xform -q -ws -rp ("HUB_"+$corner)`;
						
			float $x = $hubAttr[0]; 
			float $y = $wheelAttr[1];   
    		float $z = $wheelAttr[2]; 
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("HUBTEMP_" + $corner);        
    	}
    	//temp hub locators - used to position hub axis

		if (`objExists ("SPRING_"+$corner+"1")`) 	boltMatchPivot ("SPRING_"+$corner+"1")	("DAMPER_T"+$corner+"1");
		if (`objExists ("SPRING_"+$corner+"2")`) 	boltMatchPivot ("SPRING_"+$corner+"2")	("DAMPER_T"+$corner+"2");
		if (`objExists ("HUB_"+$corner)`) 			boltMatchPivot ("HUB_"+$corner)			("HUBTEMP_" + $corner);
		if (`objExists ("DISC_"+$corner)`) 			boltMatchPivot ("DISC_"+$corner)		("HUBTEMP_" + $corner);
		if (`objExists ("HUB_"+$corner)`) 			delete ("HUBTEMP_"+$corner);
//		if the object exists........................move the pivot of the object............to match this object. 		

		
	}
	
	print "\n**** Pivots Moved ****\n\n";	

	
//////////////////////////////////////////////////////////////////////////////////////////
//Place locators
	
	string $corner;
	
	for ($corner in $cornerList)
	{	
			
		if( `objExists ("WISHBONE_T"+$corner)`) 
		{
			
			float $wishTAttr[] = `xform -q -ws -rp ("WISHBONE_T"+$corner)`;
			float $hubAttr[] = `xform -q -ws -rp ("HUB_"+$corner)`;
			float $box[] = `xform -q -ws -bb ("WISHBONE_T"+$corner)`;
			
			float $x = $hubAttr[0]; 
			float $y = ($box[4] - ($wishTAttr[1] - $box[1]));   
    		float $z = $hubAttr[2];  
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("WISHBONE_T" + $corner + "_TARGET");        
    		
		}
		//add top wishbone target
		//must be directly above hub steering axis to avoid suspension twisting
		
		
		if( `objExists ("WISHBONE_B"+$corner)`) 
		{
			float $wishBAttr[] = `xform -q -ws -rp ("WISHBONE_B"+$corner)`;
			float $hubAttr[] = `xform -q -ws -rp ("HUB_"+$corner)`;
			float $box[] = `xform -q -ws -bb ("WISHBONE_B"+$corner)`;
			
			float $x = $hubAttr[0]; 
			float $y = ($box[4] - ($wishBAttr[1] - $box[1]));   
    		float $z = $hubAttr[2]; 
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("WISHBONE_B" + $corner + "_TARGET");        
    	}
    	//add bottom wishbone target
		//must be directly below hub steering axis to avoid suspension twisting
    	
		
		if( `objExists ("TIEROD_"+$corner)`) 
		{
			float $tieRodAttr[] = `xform -q -ws -rp ("TIEROD_"+$corner)`;
			float $box[] = `xform -q -ws -bb ("TIEROD_"+$corner)`;
			
			float $x = ($box[3] - ($tieRodAttr[0] - $box[0])); 
			float $y = ($box[4] - ($tieRodAttr[1] - $box[1]));   
    		float $z = ($box[5] - ($tieRodAttr[2] - $box[2]));  
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("TIEROD_" + $corner + "_TARGET");     
    		
		}
		//add tierod target
		
		
						
		if( `objExists ("DRIVESHAFT_"+$corner)`) 
		{
		   	float $driveShaftAttr[] = `xform -q -ws -rp ("DRIVESHAFT_"+$corner)`;
		   	float $box[] = `xform -q -ws -bb ("DRIVESHAFT_"+$corner)`;
		   	
			float $x = ($box[3] - ($driveShaftAttr[0] - $box[0])); 
			float $y = ($box[4] - ($driveShaftAttr[1] - $box[1]));   
    		float $z = ($box[5] - ($driveShaftAttr[2] - $box[2]));  
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("DRIVESHAFT_" + $corner + "_TARGET");     
    		
		}
		//add DRIVESHAFT target
		
		if( `objExists ("DAMPER_T"+$corner+"1")`) 
		{
    	 	string $loc[] = `spaceLocator`; setAttr ($loc[0]+".scale") 0.05 0.05 0.05;
			float $damperBAttr[] = `xform -q -ws -rp ("DAMPER_B"+$corner+"1")`;
			setAttr ($loc[0]+".t")  $damperBAttr[0] $damperBAttr[1] $damperBAttr[2];
			rename $loc[0] ("DAMPER_T" + $corner + "1_TARGET"); 
			   
		}
		//add damper 1 target 
		
		if( `objExists ("DAMPER_T"+$corner+"2")`)  
		{                                          
			string $loc[] = `spaceLocator`; setAttr ($loc[0]+".scale") 0.05 0.05 0.05;
			float $damperBAttr[] = `xform -q -ws -rp ("DAMPER_B"+$corner+"2")`;
			setAttr ($loc[0]+".t")  $damperBAttr[0] $damperBAttr[1] $damperBAttr[2];
			rename $loc[0] ("DAMPER_T" + $corner + "2_TARGET");    
			   
		} 
		//add damper 2 target                          
	}
	
    print "\n**** Locators Added ****\n\n";

//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Align pivots
	
	for ($corner in $cornerList)   
	{

		if (`objExists ("WISHBONE_B"+$corner)`)		boltOrientX ("WISHBONE_B"+$corner) 		("WISHBONE_B"+$corner+"_TARGET");  
		if (`objExists ("WISHBONE_T"+$corner)`) 	boltOrientX ("WISHBONE_T"+$corner) 		("WISHBONE_T"+$corner+"_TARGET");    
		if (`objExists ("TIEROD_"+$corner)`) 		boltOrientX ("TIEROD_"+$corner) 		("TIEROD_"+$corner+"_TARGET");    
		if (`objExists ("DRIVESHAFT_"+$corner)`) 	boltOrientX ("DRIVESHAFT_"+$corner) 	("DRIVESHAFT_"+$corner+"_TARGET");   
		if (`objExists ("DAMPER_T"+$corner+"1")`) 	boltOrientVerticalX ("DAMPER_T"+$corner+"1")	("DAMPER_B"+$corner+"1");  
		if (`objExists ("DAMPER_B"+$corner+"1")`) 	boltOrientVerticalX ("DAMPER_B"+$corner+"1")	("DAMPER_T"+$corner+"1"); 
		if (`objExists ("SPRING_"+$corner+"1")`) 	boltOrientVerticalX ("SPRING_"+$corner+"1")		("DAMPER_B"+$corner+"1");   
		if (`objExists ("DAMPER_T"+$corner+"2")`) 	boltOrientVerticalX ("DAMPER_T"+$corner+"2")	("DAMPER_B"+$corner+"2");  
		if (`objExists ("DAMPER_B"+$corner+"2")`) 	boltOrientVerticalX ("DAMPER_B"+$corner+"2")	("DAMPER_T"+$corner+"2");
		if (`objExists ("SPRING_"+$corner+"2")`) 	boltOrientVerticalX ("SPRING_"+$corner+"2")		("DAMPER_B"+$corner+"2");   
	}
//		if (`objExists ("STEERING_RACK")`) 			boltOrientX ("STEERING_RACK") 			("STEERING_RACK_TARGET");    
//		if the object exists........................orient the x axis of the object.........to point at this object.    		

	print "\n**** Pivots Aligned ****\n\n";
    
//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Build constraints
	
	for ($corner in $cornerList)   
	{	                           
		string $end = "F";
		if ($corner == "FL") $end = "F"; if ($corner == "FR") $end = "F";
		if ($corner == "BL") $end = "B"; if ($corner == "BR") $end = "B";
		//work out which end this is
						
		catchQuiet(`parent ("HUB_"+$corner)		("BODY")`);
		catchQuiet(`parent ("DISC_"+$corner)	("HUB_"+$corner)`); 
		catchQuiet(`parent ("WHEEL_"+$corner)	("BODY")`); 
		catchQuiet(`parent ("TYRE_"+$corner)	("WHEEL_"+$corner)`); 
		//link hub to the body, and wheels to the body
		
		if (`objExists ("DAMPER_B"+$corner+"1")`) catchQuiet(`parent ("DAMPER_T"+$corner+"1") ("BODY")`);
		if (`objExists ("DAMPER_B"+$corner+"2")`) catchQuiet(`parent ("DAMPER_T"+$corner+"2") ("BODY")`);
		//link top dampers to the body
		
		if (`objExists ("DAMPER_B"+$corner+"1")`) catchQuiet(`parent ("DAMPER_T" + $corner + "1_TARGET") 	($shockMount+$corner)`);
		if (`objExists ("DAMPER_B"+$corner+"1")`) catchQuiet(`parent ("DAMPER_B" + $corner + "1") 			($shockMount+$corner)`);
		if (`objExists ("DAMPER_B"+$corner+"2")`) catchQuiet(`parent ("DAMPER_T" + $corner + "2_TARGET") 	($shockMount+$corner)`);
		if (`objExists ("DAMPER_B"+$corner+"2")`) catchQuiet(`parent ("DAMPER_B" + $corner + "2")			($shockMount+$corner)`);
		//link bottom dampers to the t/bwishbone/hub via the top damper target locator
					
		if (`objExists ("WISHBONE_B"+$corner)`) 
		{
			catchQuiet(`parent ("WISHBONE_B"+$corner)	("BODY")`);
			catchQuiet(`parent ("WISHBONE_B"+$corner+"_TARGET")	("HUB_"+$corner)`);
			aimConstraint -worldUpType "objectrotation" ("WISHBONE_B"+$corner+"_TARGET") ("WISHBONE_B"+$corner);
			boltScale ("WISHBONE_B"+$corner) ("WISHBONE_B"+$corner+"_TARGET");		
		}
		if (`objExists ("WISHBONE_T"+$corner)`) 
		{
			catchQuiet(`parent ("WISHBONE_T"+$corner)	("BODY")`);
			catchQuiet(`parent ("WISHBONE_T"+$corner+"_TARGET")	("HUB_"+$corner)`);
			aimConstraint -worldUpType "objectrotation" ("WISHBONE_T"+$corner+"_TARGET") ("WISHBONE_T"+$corner);    
			boltScale ("WISHBONE_T"+$corner) ("WISHBONE_T"+$corner+"_TARGET");		
		}
		//link, aim + scale the wishbones
		
		if (`objExists ("DAMPER_B"+$corner+"1")`) aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T"+$corner+"1") 			("DAMPER_B"+$corner+"1");
		if (`objExists ("DAMPER_T"+$corner+"1")`) aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + "1_TARGET") ("DAMPER_T"+$corner+"1");    
		if (`objExists ("DAMPER_B"+$corner+"2")`) aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T"+$corner+"2") 			("DAMPER_B"+$corner+"2");
		if (`objExists ("DAMPER_T"+$corner+"2")`) aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + "2_TARGET") ("DAMPER_T"+$corner+"2");    
		//aim the dampers
		
		if (`objExists ("SPRING_"+$corner+"1")`)
		{
			catchQuiet(`parent ("SPRING_"+$corner+"1") ("BODY")`);
			aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + "1_TARGET") ("SPRING_"+$corner+"1");
			boltScale ("SPRING_"+$corner+"1") ("DAMPER_T" + $corner + "1_TARGET");
		}
		
		if (`objExists ("SPRING_"+$corner+"2")`)
		{
			catchQuiet(`parent ("SPRING_"+$corner+"2") ("BODY")`);
			aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + "2_TARGET") ("SPRING_"+$corner+"2");
			boltScale ("SPRING_"+$corner+"2") ("DAMPER_T" + $corner + "2_TARGET");
		}
		//parent, aim + scale springs
				
		if (`objExists ("DRIVESHAFT_"+$corner)`)
		{
			catchQuiet(`parent ("DRIVESHAFT_"+$corner) ("HUB_"+$corner)`);
			catchQuiet(`parent ("DRIVESHAFT_"+$corner+"_TARGET") ("BODY")`);
			aimConstraint -worldUpType "objectrotation" ("DRIVESHAFT_"+$corner+"_TARGET") ("DRIVESHAFT_"+$corner); 
			boltScale ("DRIVESHAFT_"+$corner) ("DRIVESHAFT_" + $corner + "_TARGET");
		}
		//parent and aim driveshafts
	
	
		if (`objExists ("TIEROD_"+$corner)`)
		{
			catchQuiet(`parent ("TIEROD_"+$corner) ("HUB_"+$corner)`);
			catchQuiet(`parent ("TIEROD_"+$corner+"_TARGET") ("BODY")`);
			aimConstraint -worldUpType "objectrotation" ("TIEROD_"+$corner+"_TARGET") ("TIEROD_"+$corner); 
			boltScale ("TIEROD_"+$corner) ("TIEROD_"+$corner+"_TARGET");
			//version with no rack
		}
		
	}
	print "\n**** Constraints Built ****\n\n";	
	print "**** RIGGING COMPLETE ****";	
}


global proc boltDoRigSolidAxle(string $end, string $shockMount, string $tieMount)
//rigs solid axle suspension
{
	
string $cornerList[] = {($end+"L"), ($end+"R")}; 
//set up a corner list


	
//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Move pivots
	
	for ($corner in $cornerList)   
	{

		if( `objExists ("HUB_"+$corner)`) 
		{
			float $wheelAttr[] = `xform -q -ws -rp ("WHEEL_"+$corner)`;
			float $hubAttr[] = `xform -q -ws -rp ("HUB_"+$corner)`;
						
			float $x = $hubAttr[0]; 
			float $y = $wheelAttr[1];   
    		float $z = $wheelAttr[2]; 
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("HUBTEMP_" + $corner);        
    	}
    	//temp hub locators - used to position hub axis

		if (`objExists ("HUB_"+$corner)`) 			boltMatchPivot ("HUB_"+$corner)			("HUBTEMP_" + $corner);
		if (`objExists ("DISC_"+$corner)`) 			boltMatchPivot ("DISC_"+$corner)		("HUBTEMP_" + $corner);
		if (`objExists ("HUB_"+$corner)`) 			delete ("HUBTEMP_"+$corner);
//		if the object exists........................move the pivot of the object............to match this object. 		

	}
	
	print "\n**** Hub + Disc Pivots Moved ****\n\n";	
	
	

	
	
//////////////////////////////////////////////////////////////////////////////////////////
//Place locators

	
	float $pos[];

	for ($corner in $cornerList)
	{	
		if( `objExists ("TIEROD_"+$corner)`) 
		{
			float $tieRodAttr[] = `xform -q -ws -rp ("TIEROD_"+$corner)`;
			float $box[] = `xform -q -ws -bb ("TIEROD_"+$corner)`;
			
			float $x = ($box[3] - ($tieRodAttr[0] - $box[0])); 
			float $y = ($box[4] - ($tieRodAttr[1] - $box[1]));   
    		float $z = ($box[5] - ($tieRodAttr[2] - $box[2]));  
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("TIEROD_" + $corner + "_TARGET");     
    		
		}
		//add tierod targets
		
		if( `objExists ("TRAILING_ARM_"+$corner)`) 
		{
			float $armAttr[] = `xform -q -ws -rp ("TRAILING_ARM_"+$corner)`;
			float $box[] = `xform -q -ws -bb ("TRAILING_ARM_"+$corner)`;
			
			float $x = ($box[3] - ($armAttr[0] - $box[0])); 
			float $y = ($box[4] - ($armAttr[1] - $box[1]));   
    		float $z = ($box[5] - ($armAttr[2] - $box[2]));  
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("TRAILING_ARM_" + $corner + "_TARGET");     
    		
		}
		//add TRAILING_ARM targets
		
		if( `objExists ("TRAILING_ARM_"+$corner+"2")`) 
		{
			float $armAttr[] = `xform -q -ws -rp ("TRAILING_ARM_"+$corner+"2")`;
			float $box[] = `xform -q -ws -bb ("TRAILING_ARM_"+$corner+"2")`;
			
			float $x = ($box[3] - ($armAttr[0] - $box[0])); 
			float $y = ($box[4] - ($armAttr[1] - $box[1]));   
    		float $z = ($box[5] - ($armAttr[2] - $box[2]));  
    		
    		string $loc[] = `spaceLocator`; 
    		setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    		setAttr ($loc[0]+".t") $x $y $z;   
    		rename $loc[0] ("TRAILING_ARM_" + $corner + "2_TARGET");     
    		
		}
		//add TRAILING_ARM 2 targets
				
		if( `objExists ("DAMPER_T"+$corner+"1")`) 
		{
    	 	string $loc[] = `spaceLocator`; setAttr ($loc[0]+".scale") 0.05 0.05 0.05;
			float $damperBAttr[] = `xform -q -ws -rp ("DAMPER_B"+$corner+"1")`;
			setAttr ($loc[0]+".t")  $damperBAttr[0] $damperBAttr[1] $damperBAttr[2];
			rename $loc[0] ("DAMPER_T" + $corner + "1_TARGET"); 
			   
		}
		//add damper 1 target 
		
		if( `objExists ("DAMPER_T"+$corner+"2")`)  
		{                                          
			string $loc[] = `spaceLocator`; setAttr ($loc[0]+".scale") 0.05 0.05 0.05;
			float $damperBAttr[] = `xform -q -ws -rp ("DAMPER_B"+$corner+"2")`;
			setAttr ($loc[0]+".t")  $damperBAttr[0] $damperBAttr[1] $damperBAttr[2];
			rename $loc[0] ("DAMPER_T" + $corner + "2_TARGET");    
			   
		} 
		//add damper 2 target  
		
		
				                        
	}
	
	if( `objExists ("PROPSHAFT_"+$end)`) 
	{
	   	float $propShaftAttr[] = `xform -q -ws -rp ("PROPSHAFT_"+$end)`;
	   	float $box[] = `xform -q -ws -bb ("PROPSHAFT_"+$end)`;
	   	
		float $x = ($box[3] - ($propShaftAttr[0] - $box[0])); 
		float $y = ($box[4] - ($propShaftAttr[1] - $box[1]));   
    	float $z = ($box[5] - ($propShaftAttr[2] - $box[2]));  
    		
    	string $loc[] = `spaceLocator`; 
    	setAttr ($loc[0]+".scale") 0.05 0.05 0.05; 
    	setAttr ($loc[0]+".t") $x $y $z;   
    	rename $loc[0] ("PROPSHAFT_" + $end + "_TARGET");     
   	}
	//add PROPSHAFT target
		
	
    print "\n**** LOCATORS ADDED ****\n\n";

//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Reorient pivots
	for ($corner in $cornerList)   
	{
		if (`objExists ("SPRING_"+$corner+"1")`) 		boltMatchPivot ("SPRING_"+$corner+"1")		("DAMPER_T"+$corner+"1");
		if (`objExists ("SPRING_"+$corner+"2")`) 		boltMatchPivot ("SPRING_"+$corner+"2")		("DAMPER_T"+$corner+"2");
//		if the object exists........................	move the pivot of the object............	to match this object. 		
		                                            	                                        	
		if (`objExists ("TIEROD_"+$corner)`) 			boltOrientX ("TIEROD_"+$corner) 			("TIEROD_"+$corner+"_TARGET");    
		if (`objExists ("TRAILING_ARM_"+$corner)`) 		boltOrientX ("TRAILING_ARM_"+$corner) 		("TRAILING_ARM_"+$corner+"_TARGET");
		if (`objExists ("TRAILING_ARM_"+$corner+"2")`) 	boltOrientX ("TRAILING_ARM_"+$corner+"2") 	("TRAILING_ARM_"+$corner+"2_TARGET");
		if (`objExists ("DAMPER_T"+$corner+"1")`) 		boltOrientVerticalX ("DAMPER_T"+$corner+"1")		("DAMPER_B"+$corner+"1");  
		if (`objExists ("DAMPER_B"+$corner+"1")`) 		boltOrientVerticalX ("DAMPER_B"+$corner+"1")		("DAMPER_T"+$corner+"1"); 
		if (`objExists ("SPRING_"+$corner+"1")`) 		boltOrientVerticalX ("SPRING_"+$corner+"1")			("DAMPER_B"+$corner+"1");   
		if (`objExists ("DAMPER_T"+$corner+"2")`) 		boltOrientVerticalX ("DAMPER_T"+$corner+"2")		("DAMPER_B"+$corner+"2");  
		if (`objExists ("DAMPER_B"+$corner+"2")`) 		boltOrientVerticalX ("DAMPER_B"+$corner+"2")		("DAMPER_T"+$corner+"2");
		if (`objExists ("SPRING_"+$corner+"2")`) 		boltOrientVerticalX ("SPRING_"+$corner+"2")			("DAMPER_B"+$corner+"2");   
		
//		if the object exists........................	orient the x axis of the object.........	to point at this object. 
	}                                               	                                        	
	                                                	                                        	
		if (`objExists ("PROPSHAFT_"+$end)`) 			boltOrientX ("PROPSHAFT_"+$end) 			("PROPSHAFT_"+$end+"_TARGET");   
	    if (`objExists ("AXLE_"+$end)`) 				boltMatchPivot ("AXLE_"+$end)				("HUB_"+$end+"L");
		if (`objExists ("AXLE_"+$end)`) 				boltOrientX ("AXLE_"+$end)					("HUB_"+$end+"R");
	                                                	                                        	
   

	print "\n**** PIVOTS CORRECTED ****\n\n";


//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Build constraints

	
	for ($corner in $cornerList)   
	{	                           

		catchQuiet(`parent ("HUB_"+$corner)		("BODY")`);
		catchQuiet(`parent ("DISC_"+$corner)	("HUB_"+$corner)`); 
		catchQuiet(`parent ("WHEEL_"+$corner)	("BODY")`); 
		catchQuiet(`parent ("TYRE_"+$corner)	("WHEEL_"+$corner)`); 
		//link hub to the body, and wheels to the body
				
		if (`objExists ("DAMPER_B"+$corner+"1")`) catchQuiet(`parent ("DAMPER_T"+$corner+"1") ("BODY")`);
		if (`objExists ("DAMPER_B"+$corner+"2")`) catchQuiet(`parent ("DAMPER_T"+$corner+"2") ("BODY")`);
		//link top dampers to the body
				
		string $mount;
		if ($shockMount == "AXLE_") 
		{
			$mount = ("AXLE_" + $end);
		}
		else 
		{
			$mount = ($shockMount+$corner);
		}
		//get the right name for the suspension mount			
		
		if (`objExists ("DAMPER_B"+$corner+"1")`) catchQuiet(`parent ("DAMPER_T" + $corner + "1_TARGET") 	($mount)`);
		if (`objExists ("DAMPER_B"+$corner+"1")`) catchQuiet(`parent ("DAMPER_B" + $corner + "1") 			($mount)`);
		if (`objExists ("DAMPER_B"+$corner+"2")`) catchQuiet(`parent ("DAMPER_T" + $corner + "2_TARGET") 	($mount)`);
		if (`objExists ("DAMPER_B"+$corner+"2")`) catchQuiet(`parent ("DAMPER_B" + $corner + "2")			($mount)`);
		//link bottom dampers + top target to the hub/axle/arm
		
					
		if (`objExists ("TRAILING_ARM_"+$corner)`)
		{
			catchQuiet(`parent ("TRAILING_ARM_"+$corner) ("BODY")`);
			catchQuiet(`parent ("TRAILING_ARM_"+$corner+"_TARGET")	("AXLE_"+$end)`);
			aimConstraint -worldUpType "objectrotation" ("TRAILING_ARM_"+$corner+"_TARGET")  ("TRAILING_ARM_"+$corner);
			boltScale ("TRAILING_ARM_"+$corner) ("TRAILING_ARM_"+$corner+"_TARGET");
		}
		if (`objExists ("TRAILING_ARM_"+$corner+"2")`)
		{
			catchQuiet(`parent ("TRAILING_ARM_"+$corner+"2") ("BODY")`);
			catchQuiet(`parent ("TRAILING_ARM_"+$corner+"2_TARGET")	("AXLE_"+$end)`);
			aimConstraint -worldUpType "objectrotation" ("TRAILING_ARM_"+$corner+"2_TARGET")  ("TRAILING_ARM_"+$corner+"2");
			boltScale ("TRAILING_ARM_"+$corner+"2") ("TRAILING_ARM_"+$corner+"2_TARGET");
		}
		//parent, aim and scale trailing arms
			
		string $nums[] = {"1","2"};
		for ($num in $nums)
		{
			if (`objExists ("DAMPER_B"+$corner+$num)` && `objExists ("DAMPER_T"+$corner+$num)`)
			{
				aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T"+$corner+$num) 					("DAMPER_B"+$corner+$num);
				aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + $num + "_TARGET") 	("DAMPER_T"+$corner+$num); 
			}
		}
			
		
		if (`objExists ("SPRING_"+$corner+"1")`)
		{
			catchQuiet(`parent ("SPRING_"+$corner+"1") ("BODY")`);
			aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + "1_TARGET") ("SPRING_"+$corner+"1");
			boltScale ("SPRING_"+$corner+"1") ("DAMPER_T" + $corner + "1_TARGET");
		}
		if (`objExists ("SPRING_"+$corner+"2")`)
		{
			catchQuiet(`parent ("SPRING_"+$corner+"2") ("BODY")`);
			aimConstraint -worldUpType "vector" -worldUpVector 1 0 0 ("DAMPER_T" + $corner + "2_TARGET") ("SPRING_"+$corner+"2");
			boltScale ("SPRING_"+$corner+"2") ("DAMPER_T" + $corner + "2_TARGET");
		}
		//parent, aim + scale springs
		
				
		
		if (`objExists ("TIEROD_"+$corner)`)
		{
			catchQuiet(`parent ("TIEROD_"+$corner) ("HUB_"+$corner)`);
			
			if ($tieMount == "BODY")
			{
				catchQuiet(`parent ("TIEROD_"+$corner+"_TARGET") ("BODY")`);
			}
			if ($tieMount == "AXLE_")
			{
				catchQuiet(`parent ("TIEROD_"+$corner+"_TARGET") ("AXLE_" + $end)`);
			}
			
			aimConstraint -worldUpType "objectrotation" ("TIEROD_"+$corner+"_TARGET") ("TIEROD_"+$corner); 
			boltScale ("TIEROD_"+$corner) ("TIEROD_"+$corner+"_TARGET");
			//parent and aim tierods
			
		}
		//setup steering linkage if present
	}
	
	if (`objExists ("PROPSHAFT_"+$end)`)
	{
		catchQuiet(`parent ("PROPSHAFT_"+$end) 				("BODY")`);
		catchQuiet(`parent ("PROPSHAFT_"+$end+"_TARGET") 	("AXLE_"+$end)`);
		aimConstraint -worldUpType "objectrotation" ("PROPSHAFT_"+$end+"_TARGET") ("PROPSHAFT_"+$end); 
		boltScale ("PROPSHAFT_"+$end) ("PROPSHAFT_"+$end+"_TARGET");
	}
	//parent and aim + scale propshaft
	
	if (`objExists ("AXLE_"+$end)`)
	{
		catchQuiet(`parent ("AXLE_"+$end) ("HUB_"+$end+"L")`);
		aimConstraint -worldUpType "objectrotation" ("HUB_"+$end+"R") ("AXLE_"+$end); 
	}
	//parent and aim axle
	
	
	print "\n**** CONSTRAINTS BUILT ****\n\n";	
}



global proc boltDoRigTrailingArmBike()
//rigs Bike rear suspension
//optional second trailing arm introduced for chopper chain
{
//////////////////////////////////////////////////////////////////////////////////////////
//Place locators

	float $pos[];
		
	if( `objExists ("DAMPER_TB")`) 
	{
   	 	string $loc[] = `spaceLocator`; setAttr ($loc[0]+".scale") 1 1 1;
		float $damperBAttr[] = `xform -q -ws -rp ("DAMPER_BB")`;
		setAttr ($loc[0]+".t")  $damperBAttr[0] $damperBAttr[1] $damperBAttr[2];
		rename $loc[0] ("DAMPER_TB_TARGET"); 
	}
	//add damper target 

	
    print "\n**** LOCATORS ADDED ****\n\n";

//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Reorient pivots

	if (`objExists ("SPRING_B")`) 					boltMatchPivot ("SPRING_B")					("DAMPER_TB");
//	if the object exists........................	move the pivot of the object............	to match this object. 		
	                                            	                                        	
	if (`objExists ("TRAILING_ARM_B")`) 			boltOrientX ("TRAILING_ARM_B")		 		("WHEEL_B");
	if (`objExists ("TRAILING_ARM_B2")`) 			boltOrientX ("TRAILING_ARM_B2")		 		("WHEEL_B");
	if (`objExists ("DAMPER_TB")`) 					boltOrientX ("DAMPER_TB")					("DAMPER_BB");  
	if (`objExists ("DAMPER_BB")`) 					boltOrientX ("DAMPER_BB")					("DAMPER_TB"); 
	if (`objExists ("SPRING_B")`) 					boltOrientX ("SPRING_B")					("DAMPER_BB");   
//	if the object exists........................	orient the x axis of the object.........	to point at this object. 
 
	print "\n**** PIVOTS CORRECTED ****\n\n";


//////////////////////////////////////////////////////////////////////////////////////////////////////    
// Build constraints

	catchQuiet(`parent ("WHEEL_B")		("BODY")`); 
	//link hub to the body, and wheels to the body
		
	if (`objExists ("DAMPER_TB")`) catchQuiet(`parent ("DAMPER_TB") ("BODY")`);
	//link top damper to the body
			
	if (`objExists ("DAMPER_TB")`) catchQuiet(`parent ("DAMPER_TB_TARGET") 	("TRAILING_ARM_B")`);
	if (`objExists ("DAMPER_BB")`) catchQuiet(`parent ("DAMPER_BB") 		("TRAILING_ARM_B")`);
	//link bottom damper + top target to the arm
	
				
	if (`objExists ("TRAILING_ARM_B")`) 
		{
		catchQuiet(`parent ("TRAILING_ARM_B") 			("BODY")`);
		aimConstraint -worldUpType "objectrotation" ("WHEEL_B")  ("TRAILING_ARM_B");
		boltScale ("TRAILING_ARM_B") ("WHEEL_B");
	}
	//parent, aim and scale trailing arm
	
	if (`objExists ("TRAILING_ARM_B2")`) 
		{
		catchQuiet(`parent ("TRAILING_ARM_B2") 			("BODY")`);
		aimConstraint -worldUpType "objectrotation" ("WHEEL_B")  ("TRAILING_ARM_B2");
		boltScale ("TRAILING_ARM_B2") ("WHEEL_B");
	}
	//parent, aim and scale trailing arm
	
		
	
	if (`objExists ("DAMPER_BB")`) aimConstraint -worldUpType "objectrotation" ("DAMPER_TB") 			("DAMPER_BB");
	if (`objExists ("DAMPER_TB")`) aimConstraint -worldUpType "objectrotation" ("DAMPER_TB_TARGET") 	("DAMPER_TB");    
	//aim the dampers
	
	if (`objExists ("SPRING_B")`)
	{
		catchQuiet(`parent ("SPRING_B") ("BODY")`);
		aimConstraint -worldUpType "objectrotation" ("DAMPER_TB_TARGET") ("SPRING_B");
		boltScale ("SPRING_B") ("DAMPER_TB_TARGET");
	}
	//parent, aim + scale the spring
		

	
	print "\n**** CONSTRAINTS BUILT ****\n\n";	
}







global proc boltDoRigBikeForks()
//rigs Bike front suspension
{
//////////////////////////////////////////////////////////////////////////////////////////
//Place locators

	float $forkAngle = `boltGetForkAngle`; 	//angle of forks from vertical in degrees.
	
	if ($forkAngle == 0)
	{
		error "Vehicle type not recognised or not a bike - could not rig front forks";
	}
	
	if (objExists("HANDLE_BARS"))
	{
		catchQuiet(`parent "HANDLE_BARS" "BODY"`);
		boltSetPivotRotation("HANDLE_BARS", {(-1 * $forkAngle),0,0});
	}
	
	if (objExists("DAMPER_BF"))
	{
		catchQuiet(`parent "DAMPER_BF" "BODY"`);
		boltSetPivotRotation("DAMPER_BF", {(-1 * $forkAngle),0,0});
	}

	if (objExists("DAMPER_TF"))
	{
		catchQuiet(`parent "DAMPER_TF" "HANDLE_BARS"`);
	}

	string $confirm = `confirmDialog -title "Bike fork rigging complete" 
			-message "Please ensure mudguards, lights etc. are parented to the correct part of the \n front forks - either DAMPER_BF or HANDLE_BARS depending on bike design." 
			-button "OK" 
			-defaultButton "OK" -cancelButton "OK" -dismissString "OK"`;
		//warn about parenting other parts
}




















global proc boltUnrigF()
{
	currentTime 0;
	
	string $unrigList[];
	string $deleteList[];
	
	$unrigList = {"STEERING_RACK", 
							"DAMPER_TFL1", "DAMPER_TFL2", "DAMPER_BFL1", "DAMPER_BFL2", 
							"DAMPER_TFR1", "DAMPER_TFR2", "DAMPER_BFR1", "DAMPER_BFR2", 
							"DISC_FL", "DISC_FR", "HUB_FL", "HUB_FR", "WHEEL_FL", "WHEEL_FR",
							"TIEROD_FL", "TIEROD_FR", "HUB_FL", "HUB_FR", "DRIVESHAFT_FL", "DRIVESHAFT_FR",
							"TRAILING_ARM_FL", "TRAILING_ARM_FR", "TRAILING_ARM_FL2", "TRAILING_ARM_FR2",
							"AXLE_F", "PROPSHAFT_F", "DAMPER_BF", "DAMPER_TF", "HANDLE_BARS",
							"WISHBONE_BFL", "WISHBONE_TFL", "WISHBONE_BFR", "WISHBONE_TFR", 
							"SPRING_FL1", "SPRING_FL2", "SPRING_FR1", "SPRING_FR2", "LEAF_FL", "LEAF_FR"};
	$deleteList = {"WISHBONE_BFL_TARGET", "WISHBONE_BFR_TARGET", "WISHBONE_TFL_TARGET", "WISHBONE_TFR_TARGET",
							"TIEROD_FL_TARGET", "TIEROD_FR_TARGET", "HUB_F", "HANDLE_BARS_LOC", "HANDLE_BARS_TARGET",
							"DRIVESHAFT_FL_TARGET", "DRIVESHAFT_FR_TARGET", "PROPSHAFT_F_TARGET",
							"DAMPER_TFL1_TARGET", "DAMPER_TFL2_TARGET", 
							"DAMPER_TFR1_TARGET", "DAMPER_TFR2_TARGET",
							"TRAILING_ARM_FL_TARGET", "TRAILING_ARM_FR_TARGET", 
							"TRAILING_ARM_FL2_TARGET", "TRAILING_ARM_FR2_TARGET",
							"LEAF_FL_TARGET", "LEAF_FR_TARGET"};
							
	string $object;
	
	for ($object in $unrigList)
	{
		if (`objExists($object)`)
		{ 
		string $expression[] = `listConnections -type expression -d true -s false -scn true $object`;
		if (size($expression) > 0) {delete $expression[0];}
		//deletes any expressions
		
		string $constraint[] = `listConnections -type constraint -d true -s false -scn true $object`;
		if (size($constraint) > 0) {delete $constraint[0];}
		//deletes any constraints
				
		catchQuiet(`parent -world $object`);
		//unparent the object
		}
	}
	for ($object in $deleteList)
	{
		if (`objExists $object`)
		{
			$childObjs = `listRelatives -children -type "transform" $object`;
			for ($obj in $childObjs) parent -world $obj;
			//prevents child objects such as swap shapes disappearing
			
			delete $object;
		}
	}
}



global proc boltUnrigB()
{
	currentTime 0;
	
	string $unrigList[];
	string $deleteList[];
	
	$unrigList = { 
							"DAMPER_TBL1", "DAMPER_TBL2", "DAMPER_BBL1", "DAMPER_BBL2", "DAMPER_TB",
							"DAMPER_TBR1", "DAMPER_TBR2", "DAMPER_BBR1", "DAMPER_BBR2", "DAMPER_BB",
							"DISC_BL", "DISC_BR", "HUB_BL", "HUB_BR", "WHEEL_BL", "WHEEL_BR",
							"TIEROD_BL", "TIEROD_BR", "HUB_BL", "HUB_BR", "DRIVESHAFT_BL", "DRIVESHAFT_BR",
							"TRAILING_ARM_BL", "TRAILING_ARM_BR", "TRAILING_ARM_BL2", "TRAILING_ARM_BR2", 
							"AXLE_B", "PROPSHAFT_B", "TRAILING_ARM_B", "TRAILING_ARM_B2", "SPRING_B",
							"WISHBONE_BBL", "WISHBONE_TBL", "WISHBONE_BBR", "WISHBONE_TBR", 
							"SPRING_BL1", "SPRING_BL2", "SPRING_BR1", "SPRING_BR2", "LEAF_BL", "LEAF_BR"};
	$deleteList = {"WISHBONE_BBL_TARGET", "WISHBONE_BBR_TARGET", "WISHBONE_TBL_TARGET", "WISHBONE_TBR_TARGET",
							"TIEROD_BL_TARGET", "TIEROD_BR_TARGET", "HUB_B",
							"DRIVESHAFT_BL_TARGET", "DRIVESHAFT_BR_TARGET", "PROPSHAFT_B_TARGET",
							"DAMPER_TBL1_TARGET", "DAMPER_TBL2_TARGET", "TRAILING_ARM_B_TARGET",
							"DAMPER_TBR1_TARGET", "DAMPER_TBR2_TARGET", "DAMPER_TB_TARGET", 
							"TRAILING_ARM_BL2_TARGET", "TRAILING_ARM_BR2_TARGET",
							"TRAILING_ARM_BL_TARGET", "TRAILING_ARM_BR_TARGET",
							"LEAF_BL_TARGET", "LEAF_BR_TARGET"};
							
	string $object;
	
	for ($object in $unrigList)
	{
		if (`objExists($object)`)
		{ 
		string $expression[] = `listConnections -type expression -d true -s false -scn true $object`;
		if (size($expression) > 0) {delete $expression[0];}
		//deletes any expressions
		
		string $constraint[] = `listConnections -type constraint -d true -s false -scn true $object`;
		if (size($constraint) > 0) {delete $constraint[0];}
		//deletes any constraints
				
		catchQuiet(`parent -world $object`);
		//unparent the object
		}
	}
	for ($object in $deleteList)
	{
		if (`objExists $object`)
		{
			$childObjs = `listRelatives -children -type "transform" $object`;
			for ($obj in $childObjs) parent -world $obj;
			//prevents child objects such as swap shapes disappearing
			
			delete $object;
		}
	}
}


global proc boltAnimateSuspension()
{
	playbackOptions -min 0 -max 79;
	currentTime 0;
	
	setKeyframe -time 0 -time 40 -time 80 -value 0   "STEERING_LOC.rotateY";
	setKeyframe -time 20 				  -value -30 "STEERING_LOC.rotateY";
	setKeyframe -time 60 				  -value 30  "STEERING_LOC.rotateY";
	
	float $rest = `getAttr("WHEEL_HEIGHT_FL_LOC.ty")`;
	
	setKeyframe -time 0 -time 40 -time 80 -value $rest		  "WHEEL_HEIGHT_FL_LOC.translateY";
	setKeyframe -time 20 				  -value ($rest + .20) "WHEEL_HEIGHT_FL_LOC.translateY";
	setKeyframe -time 60 				  -value ($rest - .20) "WHEEL_HEIGHT_FL_LOC.translateY";
	
	setKeyframe -time 0 -time 40 -time 80 -value $rest		  "WHEEL_HEIGHT_FR_LOC.translateY";
	setKeyframe -time 20 				  -value ($rest - .20) "WHEEL_HEIGHT_FR_LOC.translateY";
	setKeyframe -time 60 				  -value ($rest + .20) "WHEEL_HEIGHT_FR_LOC.translateY";
	
	float $rest = `getAttr("WHEEL_HEIGHT_BL_LOC.ty")`;
	
	setKeyframe -time 0 -time 40 -time 80 -value $rest		  "WHEEL_HEIGHT_BL_LOC.translateY";
	setKeyframe -time 20 				  -value ($rest - .20) "WHEEL_HEIGHT_BL_LOC.translateY";
	setKeyframe -time 60 				  -value ($rest + .20) "WHEEL_HEIGHT_BL_LOC.translateY";
	
	setKeyframe -time 0 -time 40 -time 80 -value $rest		  "WHEEL_HEIGHT_BR_LOC.translateY";
	setKeyframe -time 20 				  -value ($rest + .20) "WHEEL_HEIGHT_BR_LOC.translateY";
	setKeyframe -time 60 				  -value ($rest - .20) "WHEEL_HEIGHT_BR_LOC.translateY";
	
}


global proc boltAnimateSuspensionRandom()
{
	int $aLength = 1500;  //set to 1 minute long @ 25fps
	int $bumpRate = 500; //set bumps per minute
	int $steerRate = 45;	//steers per minute
	float $suspMin = -0.075; 
	float $suspMax = 0.075; 
	float $steerMin = -30; 
	float $steerMax = 30; 
	
	playbackOptions -min 0 -max $aLength; 
	currentTime 0;
	
	string $cornerList[] = {"FL", "FR", "BL", "BR"};
	
	boltUnAnimateSuspension;
	//delete existing keys
	
	for ($corner in $cornerList)
	{
		
	
		float $wRest = `getAttr("WHEEL_"+$corner+".ty")`;
		float $hRest = `getAttr("HUB_"+$corner+".ty")`;
				
		setKeyframe -time 0 -time $aLength -value $wRest ("WHEEL_"+$corner+".ty");
		setKeyframe -time 0 -time $aLength -value $hRest ("HUB_"+$corner+".ty");
						
		for ($i = 0; $i < (($aLength/1500)*$bumpRate); $i++)
		{
			int $rTime = rand(1,($aLength-1));
			float $rHeight = rand($suspMin,$suspMax);
			//get a random height and time
	
			setKeyframe -time $rTime -value ($wRest + $rHeight) ("WHEEL_"+$corner+".ty");
			setKeyframe -time $rTime -value ($hRest + $rHeight) ("HUB_"+$corner+".ty");
			//set the keys
		}
		//bump
	}
	
	
	
	float $wRestS = `getAttr("WHEEL_FL.ry")`;
	float $hRestS = `getAttr("HUB_FL.ry")`;
	//get rest pos for this wheel    
	     
	setKeyframe -time 0 -time $aLength -value $wRestS ("WHEEL_FL.ry");        
	setKeyframe -time 0 -time $aLength -value $hRestS ("HUB_FL.ry");   
		setKeyframe -time 0 -time $aLength -value $wRestS ("WHEEL_FR.ry");        
	setKeyframe -time 0 -time $aLength -value $hRestS ("HUB_FR.ry");    	
	//set start and end frames                                                   
	
	for ($i = 0; $i < (($aLength/1500)*$steerRate); $i++)
	{
		int $rTime = rand(1,($aLength-1));
		float $rSteer = rand($steerMin,$steerMax);
		//get a random angle and time
	
		setKeyframe -time $rTime -value ($wRestS + $rSteer) ("WHEEL_FL.ry");
		setKeyframe -time $rTime -value ($hRestS + $rSteer) ("HUB_FL.ry");
		setKeyframe -time $rTime -value ($wRestS + $rSteer) ("WHEEL_FR.ry");    
		setKeyframe -time $rTime -value ($hRestS + $rSteer) ("HUB_FR.ry");      
		//set the keys
	}
	//steer
	
	
}

global proc boltUnAnimateSuspension()
//removes suspension animation keys
{	
	
	currentTime 0;
	string $corners[] = {"FL", "FR", "BL", "BR"};
	
	for ($cor in $corners)
	{
		cutKey -clear -time ":" -hierarchy none -controlPoints 0 -shape 1 {"WHEEL_"+$cor};
		cutKey -clear -time ":" -hierarchy none -controlPoints 0 -shape 1 {"HUB_"+$cor};
		//delete existing keys
	}
}
	
global proc string[] boltGetVerts (string $obj)
//returns a list of verts for the given object
//returns empty if not a mesh
{

	string $verts[] = {};
	
	if (size(`listRelatives -type "mesh" $obj`) == 0) return $verts;
	
	int $counts[] = `polyEvaluate -v $obj`;
	int $count = $counts[0];
	
	for($i=0 ; $i < $count; $i++)
	{
		$verts[$i] = ($obj+".vtx["+$i+"]");
	}
	return $verts;
}
	
	
global proc boltSetPivotRotation(string $obj, float $rot[])
//sets the pivot of the object to a given rotation
{
	string $loc[] = `spaceLocator`; 
	float $pos[] = `xform -q -ws -rp $obj`;
	setAttr ($loc[0]+".t")  $pos[0] $pos[1] $pos[2];
	setAttr ($loc[0]+".r")  $rot[0] $rot[1] $rot[2];

	boltMatchPivot($obj, $loc[0]);

	delete $loc[0];
}

global proc boltMatchPivot(string $nodeToAlign, string $target)
// moves the object's pivot to the same position as the target objects
{
	boltRemoveHierarchy;
	//strip hierarchy
	
	boltZeroPivotOffsetVertCheck $target;
	boltZeroPivotOffsetVertCheck $nodeToAlign;
	//zero pivot offsets

	float $matrix[] = `xform -q -m $target`;
	string $matrixString = "";
	for ($m in $matrix) $matrixString = ($matrixString + " " + $m);
	//get the target transform matrix as a string
	
	string $vtxList[] = `boltGetVerts $nodeToAlign`;
	float $vtxArray[];
	for ($n=0; $n<(size($vtxList)); $n++)
	{
		float $vtxPos[3]=`pointPosition -w $vtxList[$n]`;
		$vtxArray[$n*3+0]=$vtxPos[0];
		$vtxArray[$n*3+1]=$vtxPos[1];
		$vtxArray[$n*3+2]=$vtxPos[2];
	}
	//store vertex positions
	
	eval ("xform -m " + $matrixString + " " + $nodeToAlign);	
	//apply transform matrix to node

	for ($n=0; $n<(size($vtxList)); $n++)
		move -a $vtxArray[$n*3+0] $vtxArray[$n*3+1] $vtxArray[$n*3+2] $vtxList[$n];
	//move verts back into place

	clear $vtxArray; clear $vtxList;
	//clear arrays

	boltRestoreHierarchy;
	//restore hierarchy

	select $nodeToAlign;
	selectPref -xns 0;	// re-enable object selecting
	select -cl;
}



global proc boltOrientX(string $nodeToAlign, string $target)
//orients the object's x-axis to point at the specified target.
{
	select $nodeToAlign;
	string $obj[] = `ls -sl -tr`;

	string $allChildren[]=`listRelatives -f`;		// ALL immediate children of selection
	string $dummy = ("dummy"+$obj[0]);
	
	print $dummy;
	
	group -n $dummy -empty;
	for ($n=1; $n<(size($allChildren)); $n++)
		if ((size(`ls -tr $allChildren[$n]`))!=0)	// is it a TRANSFORM?
			parent $allChildren[$n] $dummy;	// then move it to dummyParent

	select $obj[0];
	//move any children to a dummy parent so they are not affected
	
	string $vtxList[] = `getVerts`;
	float $vtxArray[];
	for ($n=0; $n<(size($vtxList)); $n++)
	{
		float $vtxPos[3]=`pointPosition -w $vtxList[$n]`;
		$vtxArray[$n*3+0]=$vtxPos[0];
		$vtxArray[$n*3+1]=$vtxPos[1];
		$vtxArray[$n*3+2]=$vtxPos[2];
	}
	//store vertex positions
	
	string $aimConst[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 0 1 0 $target $nodeToAlign`;
	delete $aimConst[0];
	//aim the x axis, then delete the constraint
	


	for ($n=0; $n<(size($vtxList)); $n++)
		move -a $vtxArray[$n*3+0] $vtxArray[$n*3+1] $vtxArray[$n*3+2] $vtxList[$n];
	//move verts back into place

	string $dummyChildren[]=`listRelatives -f $dummy`;	// ALL immediate children of dummyParent
	for ($n=0; $n<(size($dummyChildren)); $n++)
		if ((size(`ls -tr $dummyChildren[$n]`))!=0)	// is it a TRANSFORM?
			parent $dummyChildren[$n] $obj[0];		// then move it back to original selection
	delete $dummy;
	//restore children

	select $obj[0];
	selectPref -xns 0;	// re-enable object selecting
}

/////////////////////////////////////////////////////


global proc boltOrientVerticalX(string $nodeToAlign, string $target)
//orients the object's x-axis to point at the specified target.
//this version works better with vertical objects - prevents the Y/Z axis from
//ending up completely randomised
//used on shocks and dampers
{
	select $nodeToAlign;
	string $obj[] = `ls -sl -tr`;

	string $allChildren[]=`listRelatives -f`;		// ALL immediate children of selection
	string $dummy = ("dummy"+$obj[0]);
	group -n $dummy -empty;
	for ($n=1; $n<(size($allChildren)); $n++)
		if ((size(`ls -tr $allChildren[$n]`))!=0)	// is it a TRANSFORM?
			parent $allChildren[$n] $dummy;	// then move it to dummyParent

	select $obj[0];
	//move any childrem to a dummy parent so they are not affected
	
	string $vtxList[] = `getVerts`;
	float $vtxArray[];
	for ($n=0; $n<(size($vtxList)); $n++)
	{
		float $vtxPos[3]=`pointPosition -w $vtxList[$n]`;
		$vtxArray[$n*3+0]=$vtxPos[0];
		$vtxArray[$n*3+1]=$vtxPos[1];
		$vtxArray[$n*3+2]=$vtxPos[2];
	}
	//store vertex positions
	
	string $aimConst[] = `aimConstraint -offset 0 0 0 -weight 1 -aimVector 1 0 0 -upVector 0 1 0 -worldUpType "vector" -worldUpVector 1 0 0 $target $nodeToAlign`;
	delete $aimConst[0];
	//aim the x axis, then delete the constraint
	


	for ($n=0; $n<(size($vtxList)); $n++)
		move -a $vtxArray[$n*3+0] $vtxArray[$n*3+1] $vtxArray[$n*3+2] $vtxList[$n];
	//move verts back into place

	string $dummyChildren[]=`listRelatives -f $dummy`;	// ALL immediate children of dummyParent
	for ($n=0; $n<(size($dummyChildren)); $n++)
		if ((size(`ls -tr $dummyChildren[$n]`))!=0)	// is it a TRANSFORM?
			parent $dummyChildren[$n] $obj[0];		// then move it back to original selection
	delete $dummy;
	//restore children

	select $obj[0];
	selectPref -xns 0;	// re-enable object selecting
}

/////////////////////////////////////////////////////




global proc boltScale(string $source, string $target)
//adds a scale expression, and an in-game scale flag
{

	float $a1[] = `xform -q -worldSpace -translation $source`;
	float $a2[] = `xform -q -worldSpace -translation $target`;
	float $difX = ($a1[0] - $a2[0]); float $difY = ($a1[1] - $a2[1]); float $difZ = ($a1[2] - $a2[2]);
	float $startLength = sqrt (($difX*$difX) + ($difY*$difY) + ($difZ*$difZ));
	float $startScale = `getAttr ($source + ".scaleX")`;
	expression -s ("float $initialLength = " + $startLength + ";\r\n" +
						  "float $initialScale  = " + $startScale + ";\r\n" +
						  "float $a1[] = `xform -q -worldSpace -translation " + $source + "`;\r\n" +
						  "float $a2[] = `xform -q -worldSpace -translation " + $target + "`;\r\n" +
						  "float $difX = ($a1[0] - $a2[0]); float $difY = ($a1[1] - $a2[1]); float $difZ = ($a1[2] - $a2[2]);\r\n" +
						  "float $currentLength = sqrt (($difX*$difX) + ($difY*$difY) + ($difZ*$difZ));\r\n" +
						  "scaleX = ($initialScale * ($currentLength / $initialLength));")  
						  -object $source -alwaysEvaluate 1 -unitConversion all ;
	//adds expression to scale source depending in position of target
	

    string $conns[] = `listConnections -destination true -source false $source`;
    for($c in $conns)
    {
        $type = `nodeType $c`;
        if($type == "aimConstraint")
        {
            int $found = 0;
            string $attrs[] = `listAttr $c`;
            for($a in $attrs)
            {
                if($a == "scaled")
                {
                    $found = 1;
                    setAttr ($c + ".scaled") true;
                    //scaled flag found, set it to true
                }
            }

            if($found == 0)
            {
                addAttr -longName "scaled" -shortName "sca" -attributeType bool $c;
                setAttr ($c + ".scaled") true;
                //scaled flag created and set to be true.
            }
        }
    }
    //add ingame "scaled" flag to source object's aim constraint
	
}

global proc boltParent(string $node, string $parent)
// atempts to parent two objects
{	
	if (objExists($parent) && objExists($node))
	{
		string $currentParent[] = `listRelatives -parent $node`;
		if ($currentParent[0] != $parent)
		{
			parent $node $parent;
		}
	}
	else
	{
		//print ("\n Could not find correct parent " + $parent + " and/or node " + $node); 
	}
}
	

global proc boltAddOcclusionVolume()
//deletes any existing ambient occlusion nodes in the scene and then adds a new one
{
	string $nodes[] = `ls -long -type "evoamboccvollocator"`;
	if (size($nodes) > 0)
	{
		string $confirm = `confirmDialog -title "Add Ambient Occlusion Volumes" 
			-message "Existing ambient occlusion volume found in the scene. Delete and add a new one?" 
			-button "Delete Exisiting" -button "Quit" 
			-defaultButton "Quit" -cancelButton "Quit" -dismissString "Quit"`;
		if ($confirm == "Delete Exisiting")
		{
			for ($node in $nodes) delete `listRelatives -parent $node`;
		}
		else
		{
			return; 
		}
	}
	//delete existing volumes?
	
	boltVehicleDisplayManager();
	boltVehicleDisplayButton(2);
	boltUnhideAll;
	hide `ls "WINDOW_*"`;
	hide `ls "REFLECTION_*"`;
	hide `ls "ENV_CUBE*"`;
	//setup visibility for rendering
	
	//get bb of full car
	string $objsToCheck[] = {"BUMPER_F","BUMPER_B","BODY","CHASSIS","SPOILER","WHEEL_FL","WHEEL_FR","WHEEL_FR","WHEEL_FR"};
	string $bbObjs[] = {};
	for ($obj in $objsToCheck)
	{
		if (`objExists $obj`) $bbObjs[size($bbObjs)] = $obj;
	}
	float $bb[] = `polyEvaluate -boundingBox $bbObjs`;	
	//xmin xmax ymin ymax zmin zmax
	
	//get bb of shell, not including wheels
	string $objsToCheck[] = {"BUMPER_F","BUMPER_B","BODY","CHASSIS","SPOILER"};
	string $bbObjs[] = {};
	for ($obj in $objsToCheck)
	{
		if (`objExists $obj`) $bbObjs[size($bbObjs)] = $obj;
	}
	float $bodybb[] = `polyEvaluate -boundingBox $bbObjs`;	
	//xmin xmax ymin ymax zmin zmax
	
	//get bb of interior
	string $objsToCheck[] = {"STEERING_WHEEL","SEAT_DRIVER","SEAT_PASSENGER","SEAT_BACK_D","SEAT_BACK_P"};
	string $bbObjs[] = {};
	for ($obj in $objsToCheck)
	{
		if (`objExists $obj`) $bbObjs[size($bbObjs)] = $obj;
	}
	float $intbb[] = `polyEvaluate -boundingBox $bbObjs`;	
	//xmin xmax ymin ymax zmin zmax
	
	//exterior sizes
	float $vol_width  = ($bb[1]-$bb[0]+1.8);
	float $vol_height = ($bb[3]-$bb[2]+1.8);
	float $vol_length = ($bb[5]-$bb[4]+1.8);
	float $car_width  = ($bb[1]-$bb[0]);
	float $car_height = ($bb[3]-$bb[2]);
	float $car_length = ($bb[5]-$bb[4]);
	float $body_height = ($bodybb[3]-$bodybb[2]-0.1); //height without wheels, -0.1 off bottom
	
	//interior size
	float $int_width  = ($intbb[1]-$intbb[0])+0.2;
	float $int_height = ($intbb[3]-$intbb[2])-0.1;
	float $int_length = ($intbb[5]-$intbb[4])+0.4;
	
	//work out main pivot center	
	float $x = 0.0;
	float $y = ($bb[3]+$bb[2])/2;
	float $z = ($bb[5]+$bb[4])/2;
	
	//interior pivot center
	float $int_y = ($intbb[3]+$intbb[2])/2 +0.05;
	float $int_z = ($intbb[5]+$intbb[4])/2;
	
	//create new occlusion node
	string $occlusionNode =  `createNode evoamboccvollocator`;
	string $transformNodes[] =  `listRelatives -parent $occlusionNode`;
	string $transformNode =  $transformNodes[0];
	
	//set attributes for new node
	setAttr ($occlusionNode + ".amboccvol_x_divisions") 32;
	setAttr ($occlusionNode + ".amboccvol_y_divisions") 32;
	setAttr ($occlusionNode + ".amboccvol_z_divisions") 32;
	setAttr ($occlusionNode + ".amboccvol_num_rays") 3;
		
	setAttr ($transformNode + ".translateX") $x;
	setAttr ($transformNode + ".translateY") $y;
	setAttr ($transformNode + ".translateZ") $z;
	setAttr ($transformNode + ".scaleX") ($vol_width/2);
	setAttr ($transformNode + ".scaleY") ($vol_height/2);
	setAttr ($transformNode + ".scaleZ") ($vol_length/2);
	
	
	//set Oli's new attributes:
	setAttr ($occlusionNode + ".amboccvol_hemisphere_region_x") ($car_width/$vol_width);
	setAttr ($occlusionNode + ".amboccvol_hemisphere_region_y") ($body_height/$vol_height);
	setAttr ($occlusionNode + ".amboccvol_hemisphere_region_z") ($car_length/$vol_length);	
	setAttr ($occlusionNode + ".amboccvol_hemisphere_region_offset_y") (($car_height-$body_height)/$vol_height);
	setAttr ($occlusionNode + ".amboccvol_soapbar_pow_x") 8;
	setAttr ($occlusionNode + ".amboccvol_soapbar_pow_y") 7.4;
	setAttr ($occlusionNode + ".amboccvol_soapbar_pow_z") 8;
	
	setAttr ($occlusionNode + ".amboccvol_sphere_region_x") ($int_width/$vol_width);
	setAttr ($occlusionNode + ".amboccvol_sphere_region_y") ($int_height/$vol_height);
	setAttr ($occlusionNode + ".amboccvol_sphere_region_z") ($int_length/$vol_length);	
	
	
	print ("\ny:" + $y);
	print ("\nint_y:" + $int_y);
	print ("\nVolHt:" + $vol_height);
	
	setAttr ($occlusionNode + ".amboccvol_sphere_region_offset_x") 0;
	setAttr ($occlusionNode + ".amboccvol_sphere_region_offset_y") ((($int_y-$y)/$vol_height)*2);
	setAttr ($occlusionNode + ".amboccvol_sphere_region_offset_z") ((($int_z-$z)/$vol_length)*2);
	
	//setAttr -type "string" ($occlusionNode + ".amboccvol_pre_generated_vol") $path;
	
	if (objExists("BODY_COL")) 
		parent $transformNode "BODY_COL";
	else
		error "Could not find BODY_COL node to attach occlusion volume to.";
	
	string $confirm = `confirmDialog -title "IMPORTANT! - Manual Texture Generation Required!" 
			-message 	"You will now need to open the attribute editor for evoamboccvollocator1 \nClick on 'Generate .DDS', and save this file as a .DDS texture to the \nvehicle's texture directory. You will then need to assign the generated \ntexture to the 'Reference DDS' slot. \n Keep settings at defaults, & window meshes hidden for rendering" 
			-button "OK" 
			-defaultButton "OK" -cancelButton "OK" -dismissString "OK"`;
			
	showEditor $occlusionNode;

}

global proc boltAddLightProbes()
//deletes any existing light probe nodes in the scene and then adds a new one
{
	string $nodes[] = `ls -long "LocalLightProbeNode*"`;
	if (size($nodes) > 0)
	{
		string $confirm = `confirmDialog -title "Add Light Probes" 
			-message "Existing light probe volume found in the scene. Delete and add a new one?" 
			-button "Delete Exisiting" -button "Quit" 
			-defaultButton "Quit" -cancelButton "Quit" -dismissString "Quit"`;
		if ($confirm == "Delete Exisiting")
		{
			for ($node in $nodes) delete `listRelatives -parent $node`;
		}
		else
		{
			return; 
		}
	}
	//delete existing volumes?
		
	//get bb of full car
	string $objsToCheck[] = {"BUMPER_F","BUMPER_B","BODY","CHASSIS","SPOILER","WHEEL_FL","WHEEL_FR","WHEEL_FR","WHEEL_FR"};
	string $bbObjs[] = {};
	for ($obj in $objsToCheck)
	{
		if (`objExists $obj`) $bbObjs[size($bbObjs)] = $obj;
	}
	float $bb[] = `polyEvaluate -boundingBox $bbObjs`;	
	//xmin xmax ymin ymax zmin zmax
	
	//exterior sizes
	float $vol_width  = ($bb[1]-$bb[0]+0.6);
	float $vol_height = ($bb[3]-$bb[2]+0.3);
	float $vol_length = ($bb[5]-$bb[4]+0.6);
	float $car_width  = ($bb[1]-$bb[0]);
	float $car_height = ($bb[3]-$bb[2]);
	float $car_length = ($bb[5]-$bb[4]);
	
	//work out main pivot center	
	float $x = 0.0;
	float $y = (($bb[3]+$bb[2])/2) + 0.15;
	float $z = ($bb[5]+$bb[4])/2;
	
	//create new occlusion node
	string $probeNode =  `createNode evoAttributeNode`;
	$probeNode = `evoAttrib -as "LocalLightProbe" $probeNode`;
	//columnLayout -edit -visible false evoAttribMaincol; //caused crash for dave
	string $transformNodes[] =  `listRelatives -parent $probeNode`;
	string $transformNode =  $transformNodes[0];
	
	//set attributes for new node
		
	setAttr ($transformNode + ".translateX") $x;
	setAttr ($transformNode + ".translateY") $y;
	setAttr ($transformNode + ".translateZ") $z;
	setAttr ($transformNode + ".scaleX") ($vol_width/2);
	setAttr ($transformNode + ".scaleY") ($vol_height/2);
	setAttr ($transformNode + ".scaleZ") ($vol_length/2);
		
	if (objExists("BODY"))
	{
		parent $transformNode "BODY"; 
		rename $transformNode "EXTERIOR_LIGHTPROBE";
	}
	else
	{
		error "Could not find BODY node to attach light probe volume to.";
	}
	print "\nLight probe added successfully! Ignore following error:";
}

global proc boltTagExterior()
//deletes any existing light probe nodes in the scene and then adds a new one
{
	//create new occlusion node
	$objs = `ls -sl -transforms`;
	
	for ($obj in $objs)
	{
		select $obj;
		string $node =  `createNode evoAttributeNode -parent $obj`;
		$node = `evoAttrib -as "ExteriorOnly" $node`;
		rename $node ($obj + "_EXTERIOR_ONLY");
	}
	select $objs;
}
global proc boltTagInterior()
//deletes any existing light probe nodes in the scene and then adds a new one
{
	//create new occlusion node
	$objs = `ls -sl -transforms`;
	
	for ($obj in $objs)
	{
		select $obj;
		string $node =  `createNode evoAttributeNode -parent $obj`;
		$node = `evoAttrib -as "InteriorOnly" $node`;
		rename $node ($obj + "_INTERIOR_ONLY");
	}
	select $objs;
}



global proc boltAddRagdollVolumes()
//adds some starter ragdoll volumes ready for the user to position
//asks whether to delete existing volumes
{
	string $ragdollBoxes[] = `ls -transforms "*RAGDOLL_*"`;
	
	if (size($ragdollBoxes) > 0)
	{
		string $confirm = `confirmDialog -title "Add Ragdoll Volumes" 
			-message "Existing ragdoll collision volumes found in the scene. Delete and add fresh boxes?" 
			-button "Delete Exisiting" -button "Quit" 
			-defaultButton "Quit" -cancelButton "Quit" -dismissString "Quit"`;
		if ($confirm == "Delete Exisiting")
		{
			for ($box in $ragdollBoxes) delete $box;
		}
		else
		{
			return; 
		}
	}
	//asks for permission to delete any existing ragdoll boxes, else quits.
	
	if (`boltGetVehicleLayout` == 0)
	{
		error "Could not determine vehicle class - check filename and path are correct";
	}
	
	if (`boltGetVehicleLayout` == 5)
	//if car type vehicle
	{
		$cube = `polyCube -w 1.0 -h 1.0 -d 2 -name "RAGDOLL_01_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 2 1 0; 
		$cube = `polyCube -w 1.0 -h 1.0 -d 2 -name "RAGDOLL_02_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") -2 1 0;
		$cube = `polyCube -w 2.4 -h 1.0 -d 2 -name "RAGDOLL_03_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 -0.7 0; 
		$cube = `polyCube -w 2.4 -h 1.0 -d 1.4 -name "RAGDOLL_04_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 3 -0.3;
		$cube = `polyCube -w 1.0 -h 1.0 -d 2 -name "RAGDOLL_05_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 1.9 1.8 0;
		setAttr ($cube[0] + ".rotateZ") 15;
		$cube = `polyCube -w 1.0 -h 1.0 -d 2 -name "RAGDOLL_06_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") -1.9 1.8 0;
		setAttr ($cube[0] + ".rotateZ") -15;
		$cube = `polyCube -w 2.4 -h 1.0 -d 1.0 -name "RAGDOLL_07_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 1 2;
		$cube = `polyCube -w 2.4 -h 2.0 -d 1.0 -name "RAGDOLL_08_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 1.5 -2;
		
		if (objExists("STEERING_WHEEL"))
		{
			$cube = `polyCube -w 0.35 -h 0.35 -d 0.25 -name "RAGDOLL_09_COL" -ch 0`; 
			float $tWheel[] = `xform -q -ws -t "STEERING_WHEEL"`; 
			setAttr ($cube[0] + ".translate") $tWheel[0] ($tWheel[1]-0.03) ($tWheel[2]+0.1);
			setAttr ($cube[0] + ".rotateX") 15;
		}		
		//add steering wheel collison
		
		string $ragdollBoxes[] = `ls -transforms "RAGDOLL_*"`;
		for ($box in $ragdollBoxes) 
		{
			if (objExists("BODY_COL")) parent $box "BODY_COL";	
		}			
		//parent boxes
	
	}
	else
	//place bike boxes
	{
		$cube = `polyCube -w 0.85 -h 0.35 -d 0.25 -name "RAGDOLL_01_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 1.09 0.33;
		setAttr ($cube[0] + ".rotateX") -29;
		if (objExists("HANDLE_BARS")) parent "RAGDOLL_01_COL" "HANDLE_BARS";
		
		$cube = `polyCube -w 0.13 -h 0.55 -d 0.78 -name "RAGDOLL_02_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 0.65 0.12;
		setAttr ($cube[0] + ".rotateX") -9;
		if (objExists("BODY_COL")) parent "RAGDOLL_02_COL" "BODY_COL";
		
		$cube = `polyCube -w 0.13 -h 0.55 -d 0.78 -name "RAGDOLL_03_COL" -ch 0`; 
		setAttr ($cube[0] + ".translate") 0 0.63 -0.58;
		setAttr ($cube[0] + ".rotateX") 3;
		if (objExists("BODY_COL")) parent "RAGDOLL_03_COL" "BODY_COL";
	}
	
	string $ragdollBoxes[] = `ls -transforms "RAGDOLL_*"`;
	for ($box in $ragdollBoxes) 
	{
		RigCar_MakeRB($box,0,2);
	} 
	//add havok too all boxes
	
	string $confirm = `confirmDialog -title "Add Ragdoll Volumes Complete" 
		-message 
"Initial Ragdoll boxes placed in scene. These now need to be positioned manually to\n\
confine the driver ragdoll to the cockpit of the vehicle, or to prevent riders from\n\
falling through bikes and ATVs.\n\n\
Boxes must remain square with pivot aligned to the box, and a scale of 1. Super Car\n\
Validator will check and fix these potential problems if you run it after the ragdoll\n\
boxes have been adjusted." 
		-button "OK" 
		-defaultButton "OK" -cancelButton "OK" -dismissString "OK"`;
	
}





global proc float[] boltGetVertBB(float $xmin, float $xmax, float $ymin, float $ymax, float $zmin, float $zmax, string $objs[])
//returns bounding box of verts within the given area
{
	float $bb[] = {};
	
	for ($obj in $objs)
	{	
		string $verts[] = `ls -fl ($obj + ".vtx[*]")`;
		for ($vert in $verts)
		{
			float $pos[] = `xform -q -t -ws $vert`;
			
			if ( ($pos[0]>$xmin) && ($pos[0]<$xmax) &&
				 ($pos[1]>$ymin) && ($pos[1]<$ymax) &&
				 ($pos[2]>$zmin) && ($pos[2]<$zmax) )
			//include this vert in bb
			{
				if (size($bb)==0) $bb = {$pos[0],$pos[0],$pos[1],$pos[1],$pos[2],$pos[2]};
				
				if ($pos[0]<$bb[0]) $bb[0]=$pos[0];
				if ($pos[0]>$bb[1]) $bb[1]=$pos[0];
				if ($pos[1]<$bb[2]) $bb[2]=$pos[1];
				if ($pos[1]>$bb[3]) $bb[3]=$pos[1];
				if ($pos[2]<$bb[4]) $bb[4]=$pos[2];
				if ($pos[2]>$bb[5]) $bb[5]=$pos[2];
			}
		} 
	}
	if (size($bb)==0) $bb = {0,0,0,0,0,0};
	
	return $bb;
}



global proc vector boltGetNearestVertPos(vector $pos, string $objs[])
//returns the ws position of thenearest vert on a given list of objects to given pos.
{
	string $verts[] = {};
	
	for ($obj in $objs)
	{
		if (`objExists $obj`)
		{
			$verts = stringArrayCatenate($verts,`ls -flatten ($obj + ".vtx[*]")`);
		}
	}
	
	float $closestDistance = 1000000;
	vector $closestVertPos = $pos;
	
	for ($vert in $verts)
	{
		vector $p = `xform -q -t -ws $vert`;
		float $dist = mag($pos-$p);
		if ($dist < $closestDistance)
		{
			$closestDistance = $dist;
			$closestVertPos = $p;
		}
	}
	return $closestVertPos;
}





//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
// HAVOK
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////////






global proc int RigCar_FindNodeID(string $trans[], string $f)
{
	int $id;
	int $count = size($trans);

	for($id = 0; $id < $count; $id++)
	{
		if($f==$trans[$id])
		{
			return $id;
		}
	}
	return -1;
}

global proc RigCar_MakeRB(string $node, float $mass, int $col_type)
{
	string $temp = $node+"_hkRigidBody1";
	if(!`objExists $temp`)
	{
		string $node_rb = hkProcPhysics_addRigidBodyNode($node);
		hkProcPhysics_addShapeNode($node );
		print("RB created "+$node_rb  +"\n");
	}
	eval("setAttr "+$temp+".mass "+$mass);

	string $shape = $node+"_hkShape1";
	eval("setAttr "+$shape+".shapeType "+$col_type);

}

global proc RigCar_MakeShape(string $node, int $col_type)
//adds a havok shape, used to build compound rigid bodies
{
	string $shapeNode = $node+"_hkShape1";
	
	if(!`objExists $shapeNode`)
	{
		$shapeNode = hkProcPhysics_addShapeNode($node);;
	}

	setAttr ($shapeNode+".shapeType") $col_type;
}



global proc RigCar_RigHinge(string $par, string $node, string $side)
{

	//The hinge its self...

	string $hinge = $node+"_hkHingeConstraint1";
	if(!`objExists $hinge`) 
	{
		hkProcPhysics_addConstraintNode( $node, "hkNodeHingeConstraint" );
		print("Hinge created "+$hinge+"\n");
		hkProcPhysics_setConstraintParentNode( $hinge, $par, 1 );
	}

	
	//Subject to change....

	eval("setAttr "+$hinge+".isLimited 1");

	eval("setAttr "+$hinge+".parentSpaceTranslationLocked 1");
	eval("setAttr "+$hinge+".parentSpaceRotationLocked 1");

	eval("setAttr "+$hinge+".childSpaceTranslation 0 0 0");

	eval("setAttr "+$hinge+".childSpaceTranslationLocked 1");
	eval("setAttr "+$hinge+".childSpaceRotationLocked 0");




	if(("FL"==$side) || ("RL"==$side))
	{
		eval("setAttr "+$hinge+".childSpaceRotationX -90");
		eval("setAttr "+$hinge+".childSpaceRotationY 90");
		eval("setAttr "+$hinge+".limitMin 0");
		eval("setAttr "+$hinge+".limitMax -70");
	}
	if(("FR"==$side) || ("RR"==$side))
	{
		eval("setAttr "+$hinge+".childSpaceRotationX -90");
		eval("setAttr "+$hinge+".childSpaceRotationY 90");
		eval("setAttr "+$hinge+".limitMin 0");
		eval("setAttr "+$hinge+".limitMax 70");
	}

	if("BOOT"==$side)
	{
		eval("setAttr "+$hinge+".childSpaceRotationX 0");
		eval("setAttr "+$hinge+".childSpaceRotationY 90");
		eval("setAttr "+$hinge+".limitMin 0");
		eval("setAttr "+$hinge+".limitMax 70");
	}			
	if("BONNET"==$side)
	{
		eval("setAttr "+$hinge+".childSpaceRotationX 0");
		eval("setAttr "+$hinge+".childSpaceRotationY 270");
		eval("setAttr "+$hinge+".limitMin 0");
		eval("setAttr "+$hinge+".limitMax 70");
	}	

}



global proc RigCar_RigDroopHinge(string $parent, string $node, float $x, float $y, float $z, float $cone, float $pmax, float $pmin, float $tmin, float $tmax)
//create a havok ragdoll hinge based on the given info
{
	string $hinge = $node+"_hkRagDollConstraint1";
	if(!`objExists $hinge`) 
	{
		hkProcPhysics_addConstraintNode( $node, "hkNodeRagDollConstraint" );
		print("Hinge created "+$hinge+"\n");
		hkProcPhysics_setConstraintParentNode( $hinge, $parent, 1 );
	}
	//create hinge

	setAttr ($hinge + ".parentSpaceTranslationLocked") 1;
	setAttr ($hinge + ".parentSpaceRotationLocked") 1;
	setAttr ($hinge + ".childSpaceTranslation") 0 0 0;
	setAttr ($hinge + ".childSpaceTranslationLocked") 1;
	setAttr ($hinge + ".childSpaceRotationLocked") 0;
	//setup hinge

	setAttr ($hinge + ".childSpaceRotationX") $x;
	setAttr ($hinge + ".childSpaceRotationY") $y;
	setAttr ($hinge + ".childSpaceRotationZ") $z;
	setAttr ($hinge + ".coneAngle") $cone;
	setAttr ($hinge + ".planeAngleMax") $pmax;
	setAttr ($hinge + ".planeAngleMin") $pmin;
	setAttr ($hinge + ".twistMin") $tmin;
	setAttr ($hinge + ".twistMax") $tmax;
	//set up variables

}


global proc RigCar_RigWobbleHinge(string $parent, string $node, float $x, float $y, float $z, float $min, float $max)
//create a havok wobble hinge based on the given info
{
	string $hinge = $node+"_hkHingeConstraint1";
	if(!`objExists $hinge`) 
	{
		hkProcPhysics_addConstraintNode( $node, "hkNodeHingeConstraint" );
		print("Hinge created "+$hinge+"\n");
		hkProcPhysics_setConstraintParentNode( $hinge, $parent, 1 );
	}
	//create hinge

	setAttr ($hinge + ".isLimited") 1;
	setAttr ($hinge + ".parentSpaceTranslationLocked") 1;
	setAttr ($hinge + ".parentSpaceRotationLocked") 1;
	setAttr ($hinge + ".childSpaceTranslation") 0 0 0;
	setAttr ($hinge + ".childSpaceTranslationLocked") 1;
	setAttr ($hinge + ".childSpaceRotationLocked") 0;
	//setup hinge

	setAttr ($hinge + ".childSpaceRotationX") $x;
	setAttr ($hinge + ".childSpaceRotationY") $y;
	setAttr ($hinge + ".childSpaceRotationZ") $z;
	setAttr ($hinge + ".limitMin") $min;
	setAttr ($hinge + ".limitMax") $max;
	//set up variables
	
}

global proc BuildPanels(string $par, string $node, string $Panels[])
{
	int $s = size($Panels);
	int $r;

	for($r=0;$r<$s;$r++)
	{
		//does the word in $Panels[r] occur in $node
		string $pattern = "*"+$Panels[$r]+"*";
		if(`gmatch $node $pattern`)
		{
			if(!`gmatch $node "*CAM*"`)
			{
				print ("Node :"+$node+" matches pattern :"+$Panels[$r]+"\n");

				RigCar_MakeRB($node,10,2);

				if($Panels[$r] == "DOOR")
				{
					string $bits[];
					tokenize $node "_" $bits;
					RigCar_RigHinge($par,$node,$bits[1]);
				}
				if($node =="BONNET")
				{
					RigCar_RigHinge($par,$node,"BONNET");
				} 
				if($node == "BOOT")
				{
					RigCar_RigHinge($par,$node,"BOOT");
				}
				return;
			}
		}

	}
}

global proc boltDeleteHavokNotUser(string $nodeTypes, string $user[])
//deletes the specified type of havok node, unless it is connected to a protected object
//on the user edited list.
{
	string $hknodes[] = `ls -type $nodeTypes`;

	for($node in $hknodes)
	{
		string $parents[] = `listRelatives -parent $node`;
		if (`sFindItem $user $parents[0]` == -1)
		{ 
			delete $node;
		}
		//delete the node if it is not on the protected list
	}
}






global proc boltDeleteAllHavokGUI()
//deletes all havok nodes in scene - gui
{
	string $result = `confirmDialog -message "Delete All Havok nodes in scene?" -button "Cancel" -button "Delete All Havok" -defaultButton "Cancel" -cancelButton "Cancel" -dismissString "Cancel"`;
	if ($result == "Delete All Havok") boltDeleteAllHavok();
}


global proc boltDeleteAllHavok()
{
	string $havokNodeTypes[] = boltGetHavokNodeTypes();
	string $havokNodes[];
	for ($nodeType in $havokNodeTypes)
	{
		$havokNodes = `ls -long -type $nodeType`;
		for ($node in $havokNodes)
		{
			lockNode -lock off $node;
			delete $node;
		}
	}
}

global proc boltRemoveHavok()
//deletes havok nodes for all selected objects.
{
	string $selected[] = `ls -o -sl`;
	for ($obj in $selected)
	{
		boltDeleteHavokNodes $obj;
		print ("\nREMOVED HAVOK NODES FROM " + $obj + "\n");
	}
}




global proc boltDeleteHavokNodes(string $obj)
//delete havok nodes from an object
{
	string $havokNodeTypes[] = boltGetHavokNodeTypes();
	string $havokNodes[];
		
	for ($nodeType in $havokNodeTypes)
	{
		$havokNodes = `listRelatives -fullPath -type $nodeType $obj`;
		for ($node in $havokNodes)
		{
			lockNode -lock off $node;
			delete $node;
			print ("\nDeleted " + $node);
		}
	}
	
}






global proc rigCarGUI()
//creates the rig car GUI 
{
	if (`window -exists rigCarGUIWindow`) {deleteUI rigCarGUIWindow;} 
	//delete the window if it already exists
	
	window -title "Add vehicle Havok nodes" -toolbox 1 -width 150 -height 400 rigCarGUIWindow;
		scrollLayout;
	    	columnLayout;
	    		
	    		


				setParent ..;					
			setParent ..;
		setParent ..;   
                 		                             
	showWindow rigCarGUIWindow;
	//display the window

}



global proc boltSwitchHavokOptions (int $state)
//switches all check boxes on/off
{
	int $i; 
	for ($i=1; $i<100; $i++) 
	{
		string $checkBox;
		if ($i < 10)
			$checkBox = ("rigCheckBox0" + $i);
		else
			$checkBox = ("rigCheckBox" + $i);
				
		if (`checkBox -exists $checkBox`)
			checkBox -edit -value $state $checkBox;
	}
}


global proc boltAddHavokNodes()
//rigs the car based on the settings in the GUI
{


	string $lods[] = `ls -transforms "*_LOD*"`;
	string $dams[] = `ls -transforms "*_DAM"`;
	string $dead[] = `ls -transforms "*_DEAD"`;
	string $swps[] = `ls -transforms "*_SWP*"`;
	string $user[];
	
	$havokRBs = `ls -type "hkNodeRigidBody"`;
	if (size($havokRBs)) //prevents crash if no rbs in scene!
	{
		for ($node in $havokRBs)
		{
			if (`attributeExists "userModifiedHavokNode" $node`)
			{
				if (`getAttr ($node + ".userModifiedHavokNode")` == 1)
				{
					string $transforms[] = `listRelatives -parent $node`;
					$user[size($user)] = $transforms[0];
				}
			}
		}
		//get list of user edited nodes  
	}
	
	string $cull[] = `stringArrayCatenate $lods $dams`;
	$cull = `stringArrayCatenate $cull $dead`;
	$cull = `stringArrayCatenate $cull $user`;
	$cull = `stringArrayCatenate $cull $swps`;
	$cull = `stringArrayRemoveDuplicates $cull`;
	//get list of parts not to add havok to by accident
	
	if (`checkBox -q -value rigCheckBox60` == 1)
	{
		boltDeleteHavokNotUser "hkNodeHingeConstraint" $user;
		boltDeleteHavokNotUser "hkNodeRagDollConstraint" $user;
		boltDeleteHavokNotUser "hkNodeShape" $user;
		boltDeleteHavokNotUser "hkNodeRigidBody" $user;
	}
	//delete all old havoc nodes
	
	if (`checkBox -q -value rigCheckBox40` == 1)
	{
		if (`objExists "BODY_COL"`)
		{
			RigCar_MakeRB("BODY_COL",500,1);
		
			string $hkNode[] = `listRelatives -type "hkNodeShape" "BODY_COL"`;
			setAttr ($hkNode[0] + ".changeExtraRadius") 1;
			setAttr ($hkNode[0] + ".extraRadius") 0;
			//fix for body col lodding on export
			
			$compoundBodyCols = `ls -transforms "BODY?_COL"`; //list all sub body cols
			for ($compoundBodyCol in $compoundBodyCols)
			{
				string $parent[] = `listRelatives -parent $compoundBodyCol`;
				if ($parent[0] != "BODY_COL") parent $compoundBodyCol "BODY_COL";
				RigCar_MakeShape($compoundBodyCol, 1);
				
				string $hkNode[] = `listRelatives -type "hkNodeShape" $compoundBodyCol`;
				setAttr ($hkNode[0] + ".changeExtraRadius") 1;
				setAttr ($hkNode[0] + ".extraRadius") 0;
				//fix for body col lodding on export
			}
			
		}
	}
	//rig body_col

	if (`checkBox -q -value rigCheckBox41` == 1)
	{
		string $parts[] = `ls -transforms "RAGDOLL_*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,0,2);
		}
	}
	//rig ragdoll boxes

	if (`checkBox -q -value rigCheckBox02` == 1)
	{
		string $parts[] = `ls -transforms "BUMPER_F*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig bumper_f

	if (`checkBox -q -value rigCheckBox03` == 1)
	{
		string $parts[] = `ls -transforms "BUMPER_B*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig bumper_b
	
	if (`checkBox -q -value rigCheckBox04` == 1)
	{
		string $parts[] = `ls -transforms "DOOR_*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig doors
	
	if (`checkBox -q -value rigCheckBox05` == 1)
	{
		string $parts[] = `ls -transforms "BONNET"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig bonnet

	if (`checkBox -q -value rigCheckBox06` == 1)
	{
		string $parts[] = `ls -transforms "BOOT"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig boot

	if (`checkBox -q -value rigCheckBox07` == 1)
	{
		string $parts[] = `ls -transforms "LIGHT_F*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}		
	}
	//rig front lights

	if (`checkBox -q -value rigCheckBox08` == 1)
	{
		string $parts[] = `ls -transforms "LIGHT_B*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig back lights
	
	if (`checkBox -q -value rigCheckBox09` == 1)
	{
		string $parts[] = `ls -transforms "SPOT_*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig spot lamps

	if (`checkBox -q -value rigCheckBox10` == 1)
	{
		string $parts[] = `ls -transforms "MIRROR_*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig mirrors

	if (`checkBox -q -value rigCheckBox11` == 1)
	{
		string $parts[] = `ls -transforms "SPOILER"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}		
	}
	//rig spoiler

	if (`checkBox -q -value rigCheckBox13` == 1)
	{
		string $parts[] = `ls -transforms "WING_F*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig front wings

	if (`checkBox -q -value rigCheckBox14` == 1)
	{
		string $parts[] = `ls -transforms "WING_B*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_MakeRB($part,10,2);
		}
	}
	//rig back wings


/////////////////////////////////////////////////////////////////////////////////
//Add Hinges

	
	if (`checkBox -q -value rigCheckBox20` == 1)
	{
		string $parts[] = `ls -transforms "DOOR_*"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			string $bits[];
			tokenize $part "_" $bits;
			RigCar_RigHinge("BODY_COL",$part,$bits[1]);
		}
	}
	//hinge doors
	
	if (`checkBox -q -value rigCheckBox21` == 1)
	{
		string $parts[] = `ls -transforms "BONNET"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_RigHinge("BODY_COL",$part,$part);
		}
	}
	//hinge bonnet
	
	if (`checkBox -q -value rigCheckBox22` == 1)
	{
		string $parts[] = `ls -transforms "BOOT"`;
		$parts = `stringArrayRemove $cull $parts`;
		for ($part in $parts) 
		{
			RigCar_RigHinge("BODY_COL",$part,$part);
		}
	}
	//hinge boot
	
	
/////////////////////////////////////////////////////////////////////////////////
//Add Wobble Hinges
	
	boltDoWobble "BUMPER_F" 		"rigCheckBox70" $cull {0.0,0,180,0,45} 	{0.0,0,0,0,-45};
	boltDoWobble "BUMPER_B" 		"rigCheckBox71" $cull {0.0,0,180,0,45}		{0.0,0,0,0,-45};
	boltDoWobble "LIGHT_F*"  		"rigCheckBox72" $cull {0.0,-90,0,5,-5}		{0.0,-90,0,5,-5};
	boltDoWobble "LIGHT_B*"  		"rigCheckBox73" $cull {0.0,-90,0,5,-5}		{0.0,-90,0,5,-5};
	boltDoWobble "MIRROR_*"  		"rigCheckBox74" $cull {0.0,0,0,0,-45} 		{0.0,0,180,0,45};
	boltDoWobble "SPOILER"  		"rigCheckBox76" $cull {0.0,0,180,0,-15}	{0.0,0,0,0,15};
  	boltDoWobble "SPOT_*"  			"rigCheckBox77" $cull {0.0,-90,0,5,-5}		{0.0,-90,0,5,-5};
	boltDoWobble "WING_F*" 			"rigCheckBox79" $cull {0.0,0,-90,0,25} 	{0.0,0,-90,0,-25};
	boltDoWobble "WING_B*" 			"rigCheckBox80" $cull {0.0,0,-90,0,25} 	{0.0,0,-90,0,-25};
	
	
  //array = {float $x, float $y, float $z, float $cone, float $pmax, float $pmin, float $tmin, float $tmax}
	//boltDoDroop "BUMPER_B"			"rigCheckBox90"
	boltDoDroop "BUMPER_B"			"rigCheckBox91" $cull {0.0,0,-90,45,45,0,5,90}	{0.0,0,-90,45,0,-45,-5,-90};
	boltDoDroop "DOOR_*"				"rigCheckBox92" $cull {0.0,0,90,5,5,-5,-10,-70}		{0.0,0,90,5,5,-5,10,70};

	



	print "\nHavok rigging completed.";
	
}


global proc boltDoWobble(string $node, string $checkBox, string $cull[], float $hL[], float $hR[])
//rigs havok hinges depending on side of car
{
	if (`checkBox -q -value $checkBox` == 1)
	{
		
		string $parts[] = `ls -transforms $node`;        
		$parts = `stringArrayRemove $cull $parts`;          
		for ($part in $parts)                               
		{                                                   
			string $p[] = `listRelatives -parent $part`;
			if ($p[0] == "BODY")  $p[0] = "BODY_COL";
			float $t[] = `xform -q -rp -ws $part`;
			
			if ($p[0] == "BODY_COL")
			// Temporary hack to prevent hinges on hinges
			{
				if ($t[0]>0)
					RigCar_RigWobbleHinge($p[0],$part,$hL[0],$hL[1],$hL[2],$hL[3],$hL[4]);
				else
					RigCar_RigWobbleHinge($p[0],$part,$hR[0],$hR[1],$hR[2],$hR[3],$hR[4]);
			}
				
		}
	}
}	



global proc boltDoDroop(string $node, string $checkBox, string $cull[], float $hL[], float $hR[])
//rigs havok ragdoll droops depending on side of car
{
	if (`checkBox -q -value $checkBox` == 1)
	//if this part is ticked
	{
		
		string $parts[] = `ls -transforms $node`;        
		$parts = `stringArrayRemove $cull $parts`;          
		for ($part in $parts)                               
		{                                                   
			string $p[] = `listRelatives -parent $part`;
			if ($p[0] == "BODY")  $p[0] = "BODY_COL";
			float $t[] = `xform -q -rp -ws $part`;
			
			if ($p[0] == "BODY_COL")
			// Temporary hack to prevent hinges on hinges
			{
				if ($t[0]>0)
					RigCar_RigDroopHinge($p[0],$part,$hL[0],$hL[1],$hL[2],$hL[3],$hL[4],$hL[5],$hL[6],$hL[7]);
				else
					RigCar_RigDroopHinge($p[0],$part,$hR[0],$hR[1],$hR[2],$hR[3],$hR[4],$hR[5],$hR[6],$hR[7]);
			}
				
		}
	}
}	
	



// Get list of havok nodes
// Get list of user edited statuses
// Update display


global proc boltUserEditedHavokGUI()
{
	if (`window -exists boltUserEditedHavokWindow`) {deleteUI boltUserEditedHavokWindow;} 
	//delete the window if it already exists
	
	window -title "Define User Edited Havok Nodes" -toolbox 1 boltUserEditedHavokWindow;
	
			formLayout -numberOfDivisions 100 boltUserEditedHavokForm;
					
				scrollLayout -backgroundColor 1 1 1 boltUserEditedHavokScroll1;
					rowLayout -numberOfColumns 2 -columnWidth2 36 300;
						textScrollList -numberOfRows 50 -width 34 -allowMultiSelection 0 
							boltUserEditedHavokFlagScrollList;
						textScrollList -numberOfRows 50 -width 298 -allowMultiSelection 0 
	    					-selectCommand "boltToggleUserEditedHavok"
	    					boltUserEditedHavokNameScrollList;
	    			setParent ..;
	    		setParent ..;			
    		   
    		   	columnLayout boltUserEditedHavokCol1;   		   		
	    			rowLayout -numberOfColumns 2;
	    			setParent ..;
	    		setParent ..;	
	    	setParent ..;					
		setParent ..;   
	    		
	 	formLayout -edit
   			-attachForm     "boltUserEditedHavokScroll1"    	 "top"    5
  			-attachForm     "boltUserEditedHavokScroll1"      	"left"   5
    		-attachControl  "boltUserEditedHavokScroll1"      	"bottom" 5 		"boltUserEditedHavokCol1"
    		-attachPosition "boltUserEditedHavokScroll1"      	"right"  5 95
    			
    		-attachNone     "boltUserEditedHavokCol1"    		"top"
    		-attachForm     "boltUserEditedHavokCol1"  	  		"left"   5
    		-attachForm     "boltUserEditedHavokCol1"  	    	"bottom" 5
    		-attachForm     "boltUserEditedHavokCol1"   	    "right"  5
    	boltUserEditedHavokForm;	
	
                 		                             
	showWindow boltUserEditedHavokWindow;
	//display the window

	boltUpdateUserEditedHavokGUI;
}

global proc boltUpdateUserEditedHavokGUI()
//updates the user edited havok gui
{
	string $havokObjs[] = `ls -type "hkNodeRigidBody"`;
	//get a list of havok rigid bodies
	
	int $userEditedFlags[];
	for ($obj in $havokObjs)
	{
		int $userEditedFlag = 0;
		
		if  (`attributeExists "userModifiedHavokNode" $obj`)
		{
			if (`getAttr ($obj + ".userModifiedHavokNode")` == 1)
			{
				$userEditedFlag = 1;
			}
		}		
		$userEditedFlags[size($userEditedFlags)] = $userEditedFlag;
	}
	//get a list of user edited flags	
		
	for ($i=0; $i<size($havokObjs); $i++)
	{
		string $transforms[] = `listRelatives -parent $havokObjs[$i]`;
		$havokObjs[$i] = $transforms[0];
	}
	//convert rigid bodies to parent transform names
	
	textScrollList -e -removeAll boltUserEditedHavokFlagScrollList;
	textScrollList -e -removeAll boltUserEditedHavokNameScrollList;
	
	for ($flag in $userEditedFlags)
	{
		if ($flag == 0)	textScrollList -e -append " "	boltUserEditedHavokFlagScrollList;
		if ($flag == 1)	textScrollList -e -append "X"	boltUserEditedHavokFlagScrollList;
	}
	for ($name in $havokObjs)
	{
		textScrollList -e -append $name	boltUserEditedHavokNameScrollList;
	}
}

global proc boltToggleUserEditedHavok()
//toggles user edited havok on/off
{
	string $selected[] = `textScrollList -q  -si boltUserEditedHavokNameScrollList`;
	string $havokNodes[] = `listRelatives -type "hkNodeRigidBody" $selected[0]`;
	string $havokNode = $havokNodes[0];
	
	if  (`attributeExists "userModifiedHavokNode" $havokNode`)
	{
		if (`getAttr ($havokNode + ".userModifiedHavokNode")` == 1)
		{
			setAttr ($havokNode + ".userModifiedHavokNode") 0;
		}
		else
		{
			setAttr ($havokNode + ".userModifiedHavokNode") 1;
		}
	}
	else
	{
		addAttr -at bool -longName "userModifiedHavokNode" -defaultValue 1 $havokNode;
	}
	//toggle or add the userModifiedHavok attr.
	
	boltUpdateUserEditedHavokGUI;
	//textScrollList -deselectAll boltDecalVisScrollList;
}


global proc boltCopyAllHavokToSwapsGUI()
//copies all havok nodes to swap shapes, passing on the "delete existing" flag
{
	string $baseSwaps[] = boltGetSwappableBaseParts();
	int $deleteExisting = `checkBox -q -value boltHavokDeleteExisting`; 	

	boltRemoveHierarchy;
	for ($baseSwap in $baseSwaps)
	{
		if (`referenceQuery -isNodeReferenced $baseSwap`==0)
		{
			boltCopyHavokToSwaps ($baseSwap, $deleteExisting);
		}
	}
	boltRestoreHierarchy;
}


global proc boltCopyHavokToSwaps (string $obj, int $deleteExisting)
//copies the havoc nodes from an object to its swap shapes
{
	//get list of swaps
	string $swaps[] = `ls -transforms ($obj + "_SWP??")`;
	
	//check pivots on swaps
	for ($swap in $swaps)
	{
		if (`gmatch $swap "BOOST*"` == 0)
		{
			boltMovePivotTest $swap $obj <<0,0,0>>;
		}
		//correct the pivot if necessary
	}
	
	for ($swap in $swaps)
	{
		boltCopyHKRigidBody($obj, $swap, $deleteExisting);
		boltCopyHKShape($obj, $swap, $deleteExisting);
		boltCopyHKHinge($obj, $swap, $deleteExisting);
		boltCopyHKRagdoll($obj, $swap, $deleteExisting);
	}
}
	

global proc boltCopyHKRigidBody(string $obj, string $swap, int $deleteExisting)
{
	string $nodeToCopy = ($obj+"_hkRigidBody1");
	string $nodeToBuild = ($swap+"_hkRigidBody1");
	
	if (objExists($nodeToCopy))
	{
		if (boltCopyHKCheckExisting("hkNodeRigidBody", $swap, $deleteExisting)==0) return;
		
		hkProcPhysics_addRigidBodyNode($swap);
		
		setAttr ($nodeToBuild + ".mass") `getAttr ($nodeToCopy + ".mass")`;
	}
}

global proc boltCopyHKShape(string $obj, string $swap, int $deleteExisting)
{
	string $nodeToCopy = ($obj+"_hkShape1");
	string $nodeToBuild = ($swap+"_hkShape1");
	
	if (objExists($nodeToCopy))
	{
		if (boltCopyHKCheckExisting("hkNodeShape", $swap, $deleteExisting)==0) return;
		hkProcPhysics_addShapeNode($swap);
		
		setAttr ($nodeToBuild + ".shapeType") `getAttr ($nodeToCopy + ".shapeType")`;
		setAttr ($nodeToBuild + ".extraRadius") `getAttr ($nodeToCopy + ".extraRadius")`;
		setAttr ($nodeToBuild + ".changeExtraRadius") `getAttr ($nodeToCopy + ".changeExtraRadius")`;
	}
}

global proc boltCopyHKHinge(string $obj, string $swap, int $deleteExisting)
{
	string $nodeToCopy = ($obj+"_hkHingeConstraint1");
	string $nodeToBuild = ($swap+"_hkHingeConstraint1");
	
	if (objExists($nodeToCopy))
	{
		if (boltCopyHKCheckExisting("hkNodeHingeConstraint", $swap, $deleteExisting)==0) return;
		
		hkProcPhysics_addConstraintNode( $swap, "hkNodeHingeConstraint" );
		hkProcPhysics_setConstraintParentNode( $nodeToBuild, "BODY_COL", 1 );
		
		setAttr ($nodeToBuild + ".isLimited") `getAttr ($nodeToCopy + ".isLimited")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationLocked") `getAttr ($nodeToCopy + ".parentSpaceTranslationLocked")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationLocked") `getAttr ($nodeToCopy + ".parentSpaceRotationLocked")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationX") `getAttr ($nodeToCopy + ".parentSpaceTranslationX")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationY") `getAttr ($nodeToCopy + ".parentSpaceTranslationY")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationZ") `getAttr ($nodeToCopy + ".parentSpaceTranslationZ")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationX") `getAttr ($nodeToCopy + ".parentSpaceRotationX")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationY") `getAttr ($nodeToCopy + ".parentSpaceRotationY")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationZ") `getAttr ($nodeToCopy + ".parentSpaceRotationZ")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationX") `getAttr ($nodeToCopy + ".childSpaceTranslationX")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationY") `getAttr ($nodeToCopy + ".childSpaceTranslationY")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationZ") `getAttr ($nodeToCopy + ".childSpaceTranslationZ")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationLocked") `getAttr ($nodeToCopy + ".childSpaceTranslationLocked")`;
		setAttr ($nodeToBuild + ".childSpaceRotationLocked") `getAttr ($nodeToCopy + ".childSpaceRotationLocked")`;
		setAttr ($nodeToBuild + ".childSpaceRotationX") `getAttr ($nodeToCopy + ".childSpaceRotationX")`;
		setAttr ($nodeToBuild + ".childSpaceRotationY") `getAttr ($nodeToCopy + ".childSpaceRotationY")`;
		setAttr ($nodeToBuild + ".childSpaceRotationZ") `getAttr ($nodeToCopy + ".childSpaceRotationZ")`;
		setAttr ($nodeToBuild + ".limitMin") `getAttr ($nodeToCopy + ".limitMin")`;
		setAttr ($nodeToBuild + ".limitMax") `getAttr ($nodeToCopy + ".limitMax")`;
	}
}

global proc boltCopyHKRagdoll(string $obj, string $swap, int $deleteExisting)
{
	string $nodeToCopy = ($obj+"_hkRagDollConstraint1");
	string $nodeToBuild = ($swap+"_hkRagDollConstraint1");
	
	if (objExists($nodeToCopy))
	{
		if (boltCopyHKCheckExisting("hkNodeRagDollConstraint", $swap, $deleteExisting)==0) return;
		
		hkProcPhysics_addConstraintNode( $swap, "hkNodeRagDollConstraint" );
		hkProcPhysics_setConstraintParentNode( $nodeToBuild, "BODY_COL", 1 );
		
		setAttr ($nodeToBuild + ".parentSpaceTranslationLocked") `getAttr ($nodeToCopy + ".parentSpaceTranslationLocked")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationLocked") `getAttr ($nodeToCopy + ".parentSpaceRotationLocked")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationX") `getAttr ($nodeToCopy + ".parentSpaceTranslationX")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationY") `getAttr ($nodeToCopy + ".parentSpaceTranslationY")`;
		setAttr ($nodeToBuild + ".parentSpaceTranslationZ") `getAttr ($nodeToCopy + ".parentSpaceTranslationZ")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationX") `getAttr ($nodeToCopy + ".parentSpaceRotationX")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationY") `getAttr ($nodeToCopy + ".parentSpaceRotationY")`;
		setAttr ($nodeToBuild + ".parentSpaceRotationZ") `getAttr ($nodeToCopy + ".parentSpaceRotationZ")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationX") `getAttr ($nodeToCopy + ".childSpaceTranslationX")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationY") `getAttr ($nodeToCopy + ".childSpaceTranslationY")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationZ") `getAttr ($nodeToCopy + ".childSpaceTranslationZ")`;
		setAttr ($nodeToBuild + ".childSpaceTranslationLocked") `getAttr ($nodeToCopy + ".childSpaceTranslationLocked")`;
		setAttr ($nodeToBuild + ".childSpaceRotationLocked") `getAttr ($nodeToCopy + ".childSpaceRotationLocked")`;
		setAttr ($nodeToBuild + ".childSpaceRotationX") `getAttr ($nodeToCopy + ".childSpaceRotationX")`;
		setAttr ($nodeToBuild + ".childSpaceRotationY") `getAttr ($nodeToCopy + ".childSpaceRotationY")`;
		setAttr ($nodeToBuild + ".childSpaceRotationZ") `getAttr ($nodeToCopy + ".childSpaceRotationZ")`;
		setAttr ($nodeToBuild + ".coneAngle") `getAttr ($nodeToCopy + ".coneAngle")`;
		setAttr ($nodeToBuild + ".planeAngleMax") `getAttr ($nodeToCopy + ".planeAngleMax")`;
		setAttr ($nodeToBuild + ".planeAngleMin") `getAttr ($nodeToCopy + ".planeAngleMin")`;
		setAttr ($nodeToBuild + ".twistMin") `getAttr ($nodeToCopy + ".twistMin")`;
		setAttr ($nodeToBuild + ".twistMax") `getAttr ($nodeToCopy + ".twistMax")`;
		
	}
}


global proc int boltCopyHKCheckExisting(string $nodeType, string $swap, int $deleteExisting)
//checks for existing havok node, and deletes if deleteExisting ticked.
//returns 1 if okay to continue, or 0 if node not deleted.
{
	string $existing[] = `listRelatives -children -type $nodeType $swap`;
	if (size($existing)>0)
	{
		if ($deleteExisting==1)
		{
			for ($hkNode in $existing) delete $hkNode;
		}
		else
		{
			return 0;
		}
	}
	return 1;
	
}


global proc boltMoveHKHinge()
//moves hk hinges to the average point of the selected geometry 
{
	string $sel[] = `ls -sl "*.vtx[*]" "*.f[*]" "*.e[*]"`;
	if (size($sel)==0) error "please select verts, edges, or polys to define new hinge pos";
	
	string $obj = `match "^[^\.]*" $sel[0]`;
	
	//catch any components with shape names
	if (nodeType($obj)!="transform")
	{
		string $objs[] = `listRelatives -type "transform" -parent $obj`;
		$obj = $objs[0];
	}
	
	float $bb[6] = `polyEvaluate -boundingBoxComponent $sel`;
	float $center[] = { ($bb[0]+$bb[1])/2 , ($bb[2]+$bb[3])/2 , ($bb[4]+$bb[5])/2 };
	
	boltMoveHKHingesTo($obj, $center);
}

global proc boltMoveHKHingesTo(string $obj, float $posWS[])
//moves the havok hinges/ragdolls on an object to a new point in ws.
{
	float $objWS[] = `xform -q  -t -ws $obj`;
	
	string $hinge[] = `listRelatives -children -type "hkNodeHingeConstraint" $obj`;
	
	if (size($hinge)>0)
	{
		setAttr ($hinge[0]+".childSpaceTranslationX")  ($posWS[0] - $objWS[0]);
		setAttr ($hinge[0]+".childSpaceTranslationY")  ($posWS[1] - $objWS[1]);
		setAttr ($hinge[0]+".childSpaceTranslationZ")  ($posWS[2] - $objWS[2]);
		select -add $hinge;
	}
	
	string $hinge[] = `listRelatives -children -type "hkNodeRagDollConstraint" $obj`;
	
	if (size($hinge)>0)
	{
		setAttr ($hinge[0]+".childSpaceTranslationX")  ($posWS[0] - $objWS[0]);
		setAttr ($hinge[0]+".childSpaceTranslationY")  ($posWS[1] - $objWS[1]);
		setAttr ($hinge[0]+".childSpaceTranslationZ")  ($posWS[2] - $objWS[2]);
		select -add $hinge;
	}
	
	select -add $obj;
}

global proc boltFracture()
//breaks the first selected object into 2 pieces, using the second selected object as a fracture plane
//for best results second object should be un-enclosed, and should cut fully through the first object.

{

	string $objectList[] = `ls -sl -et transform`;
	
	if (`size $objectList` != 2) error "Please select the object to fracture, followed by the fracture plane"; 
	// quit if we don't have just 2 objects selected.
	
	string $newObject[] = `duplicate -rr $objectList[0]`;
	string $newPlane[] 	= `duplicate -rr $objectList[1]`;
	// duplicate the objects
	
	polyNormal -normalMode 0 -ch 0 $newPlane[0];
	// flip normals on one of the planes
	
	polyBoolOp -op 2 -ch 0 $objectList[0] $objectList[1];
	polyBoolOp -op 2 -ch 0 $newObject[0] $newPlane[0];
	//do the booleans	
	
}