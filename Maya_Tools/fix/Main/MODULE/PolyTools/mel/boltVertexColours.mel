source boltDebugShaderGUI;
source boltHierarchy;
//source boltLodStats; //used to get top lods for uv ratio
source boltShaderTools; //used to get bodypaint shader for uv ratio
//source boltGlobalProcs; //float to string
source boltNormalToolbox; //poly loop
//source boltCarData;
python("import superVertPaint");
python("reload(superVertPaint)");


global proc boltVertexColours.GUI()
//vehicle naming and hierarchy tools
{
	string $windowName = "boltVertexColoursWindow";
	
	if (`window -exists $windowName`)
	{ 
		deleteUI $windowName;
	}
	//delete the window if it already exists
	
	window -height 307 -width 208 -title "Vertex Colour Tools" -toolbox 1 $windowName;
	//create window
		//scrollLayout;
			frameLayout -mw 0 -mh 0 -bv 0 -lv 0;
				columnLayout;

					frameLayout -collapsable 1 -label "Vertex Colour Display:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
						columnLayout;
							rowLayout -numberOfColumns 6;
								button -height 20 -width 25 -recomputeSize 0 -backgroundColor 1 0.29 0.29	-label "R" 		-command "boltEditDebugPresets RVertexCol";	
								button -height 20 -width 25 -recomputeSize 0 -backgroundColor 0.34 1 0.31	-label "G"	-command "boltEditDebugPresets GVertexCol";
								button -height 20 -width 25 -recomputeSize 0 -backgroundColor 0 0.45 1		-label "B"		-command "boltEditDebugPresets BVertexCol";
								button -height 20 -width 25 -recomputeSize 0 -backgroundColor 0.64 0.64 0.64	-label "A"	-command "boltEditDebugPresets AVertexCol";
								button -height 20 -width 46 -recomputeSize 0 -backgroundColor 1 0.47 0.95	-label "RGB"				-command "boltEditDebugPresets VertexCols";
								button -height 20 -width 46 -recomputeSize 0 -label "Off"	-command "boltRemoveDebugShaders(1)";
							setParent ..;
							
						setParent ..;
					setParent ..;	
					
					frameLayout -collapsable 1 -label "Edit colours:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
						columnLayout;
					
							rowLayout -numberOfColumns 2;
								button -height 20 -width 100  -recomputeSize 0 -label "Apply Colours"   -ann "Opens the apply colours options" -command "PolygonApplyColorOptions;";
								button -height 20 -width 100  -recomputeSize 0 -label "Fast Paint"  	-ann "Runs the fast paint tool" 	-command "source FastPaintSet; FastPaintSet" boltButtonFastPaint;
							setParent ..;
							rowLayout -numberOfColumns 2;
								button -height 20 -width 100  -recomputeSize 0 -label "Paint Disk Glow"   -ann "Paints blue colour channel to define front and back brake disks for glow effect" -command "boltPaintDiskGlow;";
								text -label "";
							setParent ..;
							//rowLayout -numberOfColumns 2;
							//	button -height 20 -width 100  -recomputeSize 0 -label "Paint Damage" -ann "Paints vertex green channel for crumple and safety zones" -command "boltDoDamageUVs 0.1 0.1 0.8;";
							//	button -height 20 -width 100  -recomputeSize 0 -label "Paint Mud" 	-ann "Paints vertex red channel for mud" -command "boltMudPainterGUI";
							//setParent ..;
							
						setParent ..;
					setParent ..;		

					frameLayout -collapsable 1 -label "Paint Occlusion:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
						columnLayout;
	    			    		
	    					
	    					checkBox -visible 0 -label "Darken wheels & brakes"     					-v 0 boltCheckBoxOcc2;
	    					checkBox -label "Fix black intersecting verts (slower)"			-v 0 boltCheckBoxOcc5;
							checkBox -label "Turn off 'Display Colors' flag"				-v 1 boltCheckBoxOcc6;
				
							//disabled for now...
							checkBox -visible 0 -label "Auto occlude exhaust tips"   					-v 0 boltCheckBoxOcc1;
							checkBox -visible 0 -label "Brighten chrome on mirrors"  				 	-v 0 boltCheckBoxOcc3;
	    					checkBox -visible 0 -label "Brighten chrome on lights"  					-v 0 boltCheckBoxOcc4;
				
							rowLayout -numberOfColumns 2 -cw2 140 60;
								text -label "Number of vertex rays:";
								floatField -value 1024 -precision 0 boltTextFieldOccRays;
							setParent ..;
							rowLayout -numberOfColumns 2 -cw2 140 60;
								text -label "Number of texture rays:";
								floatField -value 128 -precision 0 boltTextFieldTOccRays;
							setParent ..;
	    					
	    					rowLayout -numberOfColumns 2 -cw2 100 100;
	    						button -height 20 -width 100 -label "Add wheel occs" -command "boltOcclusion.AddWheelOccs" -ann "Adds temporary wheel occluders";
	    						button -height 20 -width 100 -label "Add disc occs" -command "boltOcclusion.AddDiscOccs" -ann "Adds temporary disc / caliper occluders";
				    		setParent ..;
				    		rowLayout -numberOfColumns 2 -cw2 100 100;
	    						button -height 20 -width 100 -label "Add ground plane" -command "boltOcclusion.AddGroundOcc" -ann "Adds temporary ground plane occluder";
	    						button -height 20 -width 100 -label "Delete Occluders" -command "boltOcclusion.DeleteOccs" -ann "Deletes all temporary occluders";
				    		setParent ..;
				    		rowLayout -numberOfColumns 2 -cw2 100 100;
	    						button -height 20 -width 100 -label "Explode Decals" -command "boltOcclusion.ExplodeDecals(1)" -ann "Moves selected decals away from the body";
	    						button -height 20 -width 100 -label "Un-explode" -command "boltOcclusion.ExplodeDecals(-1)" -ann "Moves selected decals back onto body";
				    		setParent ..;
							rowLayout -numberOfColumns 2;
	    						button -height 20 -width 100 -label "Paint Mud" -command "python(\"superVertPaint.paintMud()\")" -ann "Paints mud into green channel of selected objects";
				    			button -height 20 -width 100 -label "Mud Off" -command "python(\"superVertPaint.paintMudOff()\")" -ann "Paints zero mud into green channel of selected objects";
				    		setParent ..;
	    					rowLayout -numberOfColumns 1;
	    						button -height 20 -width 202 -label "Paint Occlusion" -command "boltDoOcclusionFromGUI" -ann "Renders occlusion with the above settings" boltButtonPaintOcclusion;
				    		setParent ..;
				    		rowLayout -numberOfColumns 2;
	    						button -height 20 -width 180 -label "Brighten Cockpit Metal AO" -command "python(\"superVertPaint.brightenCockpitAO(1)\")" -ann "Should be used to brighten AO of metal parts in cockpits. Raytraces reflections based on drivers head position.";
				    			button -height 20 -width 20  -label "S" -command "python(\"superVertPaint.brightenCockpitAO(0)\")" -ann "Selection only - allows you to tweak before brightening";
				    		setParent ..;
				    		
				    		rowLayout -numberOfColumns 2 -cw2 100 100;
				    			button -height 20 -width 100 -label "Heal" -command "boltHealVertexAlpha" -ann "Fixes glitches in occlusion on selected verts, by look at surrounding vertex alpha colours.";
				    			button -height 20 -width 100 -label "Smooth" -command "boltSmoothVertexAlpha" -ann "Smooths out any hard edges in the occlusion on selected vertices";
							setParent ..;
							rowLayout -numberOfColumns 1;
								button -height 20 -width 202 -label "Match seam vertex alpha" -command "boltNorms.MatchSeamAlphas()" -ann "Given 2 adjacent edge loops on a seam, averages the vertex alpha AO across the seam";
							setParent ..;
							rowLayout -numberOfColumns 3;
								button -height 20 -width 75  -backgroundColor 0.2 0.2 0.2 -recomputeSize 0 -label "Darken"    -ann "Darkens the ambient occlusion of selected objects"    -command "boltDarken";
								button -height 20 -width 75  -backgroundColor 0.8 0.8 0.8 -recomputeSize 0 -label "Brighten"  -ann "Brightens the ambient occlusion of selected objects"  -command "boltBrighten";
								floatField -width 48 -value 0.05 -precision 3 -ann "amount to brighten/darken by" boltTextFieldBrightenAmount;
							setParent ..;
						setParent ..;
					setParent ..;	
				
					frameLayout -collapsable 1 -label "Vehicle Light Shader:" -marginHeight 5 -marginWidth 5 -labelAlign "center" -borderStyle "etchedOut";
						columnLayout;
	    			    	
	    			    	rowLayout -numberOfColumns 2;
	    						text -label "Glow Type:" -width 70;
	    						optionMenu  -width 130 boltLightGlowType;
 									menuItem -label "Head light";
 									menuItem -label "Side light";
									menuItem -label "Tail light";
									menuItem -label "Brake light";
 									menuItem -label "Combi light";
									menuItem -label "Reverse light";
									menuItem -label "Courtesy light";
									menuItem -label "No Light";
	    					setParent ..;
	    					rowLayout -numberOfColumns 2;
	    						text -label "Construction:" -width 70;
	    						optionMenu  -width 130 boltLightConstructionType;
 									menuItem -label "Standard";
 									menuItem -label "Frosted glass";
									menuItem -label "Matt reflector";
									menuItem -label "Matt ref, no lens";
 									menuItem -label "Chrome ref, no lens";
	    					setParent ..;
	    			    	
	    			    	checkBox -value 0 -label "Mirrored" -ann "Corrects normal and parallax maps for mirrored UVs" boltLightMirrored;
	    			    	checkBox -value 0 -label "+1" -ann "Temporary fix for adjacent light types that get their vertex colours blended by the game" boltLightPlusone;
	    			    	rowLayout -numberOfColumns 1;
	    			    		button -height 20 -width 202 -label "Paint Light Type To Selected" -command "boltPaintLightTypeGUI" -ann "Paints the above settings into the blue vertex colour channel of the selected components";
	    			    	setParent ..;	
	    			    	rowLayout -numberOfColumns 1;
	    			    		button -height 20 -width 202 -label "Get Light Type From Poly" -command "boltGetLightType" -ann "Gets the light settings from the currently selected polygon";
	    			    	setParent ..;
	    			    	rowLayout -numberOfColumns 1;
	    			    		button -height 20 -width 202 -label "Fix mirror flags" -command "boltFixLightShaderMirrorFlags" -ann "Checks UV winding order and sets the correct 'mirror' flag for all light shader polys";
	    			    	setParent ..;
	    			    	separator -height 4;
	    			    	rowLayout -numberOfColumns 4;
	    			    		text -label "Select:" -width 50;
	    			    		button -height 20 -width 58 -label "Exact" -command "boltSelLightTypeGUI(1)" -ann "Selects any light shader polys using the all of the exact settings above";
	    			    		button -height 20 -width 66 -label "Mirrored" -command "boltSelLightTypeGUI(4)" -ann "Selects any light shader polys using the 'mirrored' flag selected above";
	    			    		button -height 20 -width 22 -label "+1" -command "boltSelLightTypeGUI(5)" -ann "Selects any light shader polys using the '+1' flag selected above";
	    			    	setParent ..;	
	    			    	rowLayout -numberOfColumns 3;
	    			    		button -height 20 -width 66 -label "Glow Type" -command "boltSelLightTypeGUI(2)" -ann "Selects any light shader polys using the 'glow type' selected above";
	    			    		button -height 20 -width 74 -label "Construction" -command "boltSelLightTypeGUI(3)" -ann "Selects any light shader polys using the 'construction' method selected above";
		    			    	button -height 20 -width 58 -label "Broken" -command "boltSelLightTypeGUI(6)" -ann "Selects any light shader polys with a gradient of vertex colours across them - this is usually undesirable";
		    			    setParent ..;		
	    			    	separator -height 4;
	    			    	rowLayout -numberOfColumns 2;
	    						text -label "Test Lights:" -width 70;
	    						optionMenu -changeCommand "boltLightShaderTestUpdate;" -width 130 boltLightTestOption;
 									menuItem -label "All off";
 									menuItem -label "All on";
									menuItem -label "Head lights";
									menuItem -label "Side lights";
									menuItem -label "Tail lights";
									menuItem -label "Brake lights";
 									menuItem -label "Combi lights";
 									menuItem -label "Courtesy light";
									menuItem -label "Reverse light";
							setParent ..;
	    			    	
	    			    setParent ..;
					setParent ..;			
	
	
	
	
	
	
	
	
	
	
	
				setParent ..;  
			setParent ..;
		setParent ..;
	setParent ..;







	showWindow $windowName;
	//display the window
	      
	window -e -height 480 -width 220 $windowName;    

	//check plugins
	if ( catchQuiet(`loadPlugin burncolourstoalpha.mll`) )
		{
			button -e -enable 0 -ann "Can't find burncolourstoalpha.mll" boltButtonPaintOcclusion;
			warning "Can't find burncolourstoalpha.mll - paint occlusion disabled.";
		}
	if ( catchQuiet(`loadPlugin vertexcolourcopy.mll`) )
		{
			button -e -enable 0 -ann "Can't find vertexcolourcopy.mll" boltButtonPaintOcclusion;
			warning "Can't find vertexcolourcopy.mll - paint occlusion disabled.";
		}	
		
		
	if ( catchQuiet(`loadPlugin fastpaint.mll`) )
		{
			button -e -enable 0 -ann "Can't find fastpaint.mll" boltButtonFastPaint;
			warning "Can't find fastpaint.mll - fast paint disabled.";
		}
	
	print "\n ";
}



global proc boltOcclusion.AddWheelOccs()
{
	string $wheels[]    = {"WHEEL_FL","WHEEL_FR","WHEEL_BL","WHEEL_BR"};
	string $wheelOccs[] = {"TEMP_OCCLUDER_WHEEL_FL","TEMP_OCCLUDER_WHEEL_FR","TEMP_OCCLUDER_WHEEL_BL","TEMP_OCCLUDER_WHEEL_BR"};
	
	for ($obj in $wheelOccs)
	{
		if (`objExists $obj`) delete $obj;
	}
	
	for ($i=0; $i<4; $i++)
	{
		float $bb[] = `polyEvaluate -boundingBox $wheels[$i]`;	
		//xmin xmax ymin ymax zmin zmax
		
		float $width = $bb[1] - $bb[0];
		float $diam  = $bb[3] - $bb[2];
		
		string $cyl[] = `polyCylinder -ch on -o on -r (($diam/2)+0.02) -h ($width + 0.16) -sx 120 -sc 1`;
		setAttr ($cyl[0] + ".rz") 90;
		if ( ($wheels[$i]=="WHEEL_FL") || ($wheels[$i]=="WHEEL_BL") ) setAttr ($cyl[0] + ".rz") -90;
		setAttr ($cyl[0] + ".tx") (($bb[0]+$bb[1])/2);
		setAttr ($cyl[0] + ".ty") (($bb[2]+$bb[3])/2);
		setAttr ($cyl[0] + ".tz") (($bb[4]+$bb[5])/2);
		
		string $del[] = `polyListComponentConversion -toFace {($cyl[0]+".vtx[241]")}`;
		delete $del;
		
		rename $cyl[0] $wheelOccs[$i];
		
	}
}


global proc boltPaintDiskGlow()
{
	string $f_discs[] = `ls -transforms "DISC_F*"`;
	string $b_discs[] = `ls -transforms "DISC_B*"`;
	
	for ($d in $f_discs)
	{
		polyColorSet -currentColorSet -colorSet "colorSet1" $d; //force colorSet1
		polyColorPerVertex -e -b 0 $d;
	}
	for ($d in $b_discs)
	{
		polyColorSet -currentColorSet -colorSet "colorSet1" $d; //force colorSet1
		polyColorPerVertex -e -b 1 $d;
	}
}


global proc boltOcclusion.AddDiscOccs()
{
	string $discs[]    = {"DISC_FL","DISC_FR","DISC_BL","DISC_BR"};
	string $discOccs[] = {"TEMP_OCCLUDER_DISC_FL","TEMP_OCCLUDER_DISC_FR","TEMP_OCCLUDER_DISC_BL","TEMP_OCCLUDER_DISC_BR"};
	
	for ($obj in $discOccs)
	{
		if (`objExists $obj`) delete $obj;
	}
	
	for ($i=0; $i<4; $i++)
	{
		float $bb[] = `polyEvaluate -boundingBox $discs[$i]`;	
		//xmin xmax ymin ymax zmin zmax
		
		float $width = $bb[1] - $bb[0];
		float $diam  = $bb[3] - $bb[2];
		
		string $cyl[] = `polyCylinder -ch on -o on -r (($diam/2)+0.04) -h ($width + 0.20) -sx 120 -sc 1`;
		setAttr ($cyl[0] + ".rz") 90;
		if ( ($discs[$i]=="DISC_FL") || ($discs[$i]=="DISC_BL") ) setAttr ($cyl[0] + ".rz") -90;
		setAttr ($cyl[0] + ".tx") (($bb[0]+$bb[1])/2);
		setAttr ($cyl[0] + ".ty") (($bb[2]+$bb[3])/2);
		setAttr ($cyl[0] + ".tz") (($bb[4]+$bb[5])/2);
		
		string $del[] = `polyListComponentConversion -toFace {($cyl[0]+".vtx[241]")}`;
		delete $del;
		
		rename $cyl[0] $discOccs[$i];
		
	}
}


global proc boltOcclusion.SelectDecals()
{
	string $sel[] = `ls -sl -transforms`;
	if (size($sel) == 0) return;
		
	string $mats[] = `ls -type "ATGMaterial"`;
	for ($mat in $mats)
	{
		if ((`gmatch $mat "badge_*"`) || (`gmatch $mat "bolts_*"`)|| (`gmatch $mat "decals_*"`))
		{
			 boltDoSelShader($mat, $sel);
		}
	}
}

global proc boltOcclusion.ExplodeDecals(float $out)
{
	string $sel[] = `ls -sl`;
	string $verts[] = `polyListComponentConversion -toVertex $sel`;
	$verts = `ls -fl $verts`;
	
	vector $zero = <<0,0.3,0>>;
	float $scale = 0.5 * $out;
	
	for ($v in $verts)
	{
		vector $pos = `pointPosition -world $v`;
		vector $os = $pos - $zero;
		$os /= mag($os);
		$os *= $scale;
		move -ws -r ($os.x) ($os.y) ($os.z) $v;
		
		print "\n"; print $v; print $os; print "\n";
	}
}


global proc boltOcclusion.DeleteOccs()
{
	delete `ls "TEMP_OCCLUDER_*"`;
} 
	
	
global proc boltOcclusion.AddGroundOcc()
{
	
	if (`objExists "TEMP_OCCLUDER_GROUND_PLANE"`) delete "TEMP_OCCLUDER_GROUND_PLANE";
	
	//get bb of full car
	string $objsToCheck[] = {"BUMPER_F","BUMPER_B","BODY","CHASSIS","SPOILER","WHEEL_FL","WHEEL_FR","WHEEL_FR","WHEEL_FR"};
	string $bbObjs[] = {};
	for ($obj in $objsToCheck)
	{
		if (`objExists $obj`) $bbObjs[size($bbObjs)] = $obj;
	}
	float $bb[] = `polyEvaluate -boundingBox $bbObjs`;	
	//xmin xmax ymin ymax zmin zmax
	
	//exterior sizes
	float $vol_width  = ($bb[1]-$bb[0]+1.8);
	float $vol_length = ($bb[5]-$bb[4]+1.8);
		
	string $p[] = `polyPlane -ch 1 -width $vol_width -height $vol_length`;
	setAttr ($p[0] + ".tx") 0;
	setAttr ($p[0] + ".ty") 0;
	setAttr ($p[0] + ".tz") (($bb[4]+$bb[5])/2);
	
	rename $p[0] "TEMP_OCCLUDER_GROUND_PLANE";
}

global proc boltPaintLightTypeGUI()
{
	int $glowType  = `optionMenu -q -sl boltLightGlowType` -1;
	int $constType = `optionMenu -q -sl boltLightConstructionType` -1;
	int $mirror    = `checkBox -q -v boltLightMirrored`;
	int $plusone    = `checkBox -q -v boltLightPlusone`;
	
	boltPaintLightType($glowType, $constType, $mirror, $plusone);
}

global proc boltPaintLightType(int $glowType, int $constType, int $mirror, int $plusone)
{
	int $index = ($constType * 16) + ($mirror * 8) + $glowType + ($plusone*128);
	float $colour = ($index / 255.0) + (0.1 / 255.0);
	polyColorPerVertex -b $colour;
	print ("\nBlue vertex colour set to: " + $colour + " (Index: " + $index + ")");
}


global proc boltGetLightType()
{
	string $sel[] = `ls -sl`;
	if (`gmatch $sel[0] "*.f\\[*"` == 0) error "please select a single face!";
	
	string $vfs[] = boltNorms.ToVFs({$sel[0]});  
	
	float $col[] = `polyColorPerVertex -q -b $vfs[0]`;
	for ($vf in $vfs)
	{
		float $newCol[] = `polyColorPerVertex -q -b $vf`;
		print ("\nCol: " + $newCol[0]);
		if ($newCol[0] != $col[0]) error "Face has multiple light types assigned!";
	}
	
	//reverse this:
	//$index = ($constType * 16) + ($mirror * 8) + $glowType + ($plusone*128);
	//float $colour = ($index / 255.0) + (0.1 / 255.0);
	float $fIndex = 255.0 * ($col[0]); //  - (0.1 / 255.0));
	int $index = $fIndex;
	int $glowType = $index % 8;
	int $mirror = ($index/8) % 2;
	int $plusone = ($index/128) % 2;
	int $constType = ($index/16) % 8;
	
	optionMenu -e -sl ($glowType +1) boltLightGlowType;
	optionMenu -e -sl ($constType +1) boltLightConstructionType;
	checkBox -e -v $mirror boltLightMirrored;
	checkBox -e -v $plusone boltLightPlusone;
	

}


global proc boltSelLightTypeGUI(int $mode)
{
	int $glowType  = `optionMenu -q -sl boltLightGlowType` -1;
	int $constType = `optionMenu -q -sl boltLightConstructionType` -1;
	int $mirror    = `checkBox -q -v boltLightMirrored`;
	int $plusone    = `checkBox -q -v boltLightPlusone`;
		
	if ($mode == 1) boltSelectLightType($glowType,$mirror,$plusone,$constType,-1);
	if ($mode == 2) boltSelectLightType($glowType,-1,-1,-1,-1);
	if ($mode == 3) boltSelectLightType(-1,-1,-1,$constType,-1);
	if ($mode == 4) boltSelectLightType(-1,$mirror,-1,-1,-1);
	if ($mode == 5) boltSelectLightType(-1,-1,$plusone,-1,-1);
	if ($mode == 6) boltSelectLightType(-1,-1,-1,-1,1);
}
	

global proc boltSelectLightType(int $glowType,int $mirror,int $plusone,int $constType,int $broken)
{
	string $objs[] = `ls -transforms`;
	string $polys1[] = {}; 
	string $polys2[] = {};
	string $polys3[] = {};
	if (objExists("light_shader"))              $polys1 = boltListShadedPolygons($objs, "light_shader");
	if (objExists("light_shader_standard"))     $polys2 = boltListShadedPolygons($objs, "light_shader_standard");  
	if (objExists("light_shader_under_colour")) $polys3 = boltListShadedPolygons($objs, "light_shader_under_colour"); 
	
	string $polys[] = stringArrayCatenate($polys1,$polys2);
	$polys = stringArrayCatenate($polys,$polys3);
	
	if (size($polys) == 0) error "No light shader polys found in scene";
	
	string $toSelect[] = {};
	
	for ($p in $polys)
	{
		int $p_glowType = -10;
		int $p_mirror = -10;
		int $p_plusone = -10;
		int $p_constType = -10;
		int $p_broken = 0;
				
		string $vfs[] = boltNorms.ToVFs({$p});  
		float $col[] = `polyColorPerVertex -q -b $vfs`;
		for ($c in $col)
		{
			if ($c != $col[0]) 
			{
				$p_broken = 1;
				continue;
			}
		}
		
		if ($p_broken == 1) 
		{
			if ($p_broken == $broken) $toSelect[size($toSelect)] = $p;
		}
		else
		{
			if ($broken == 1) continue;
			
			float $fIndex = 255.0 * ($col[0]);
			int $index = $fIndex;
			$p_glowType = $index % 8;
			$p_mirror = ($index/8) % 2;
			$p_plusone = ($index/128) % 2;
			$p_constType = ($index/16) % 8;
			
			if ($glowType == -1)  $p_glowType = -1;
			if ($mirror == -1)    $p_mirror = -1;
			if ($plusone == -1)   $p_plusone = -1;
			if ($constType == -1) $p_constType = -1;
		
			if ( ($p_glowType == $glowType) && ($p_mirror == $mirror) && ($p_plusone == $plusone) && ($p_constType == $constType) )
			{
				$toSelect[size($toSelect)] = $p;
			}
       	}
    }
    select -cl;
    select $toSelect;
    	     
}            
             

global proc boltOcclusion2(int $rays)
//new version, not dependant on prefs settings in mentalray
//$rays sets quality, default is 64
{
	print "\nboltOcclusion2 - getting selection...";
	string $selection[] = `ls -sl`; //remember what was selected
	
	//Hack that stops vertex corruption in Maya 2013 9.0.SCE
	vertexcolourcopy -copy; //remember vertex colours before mr kills them
	vertexcolourcopy -paste; //paste back original vertex colours
	
	print "\nboltOcclusion2 - looking for mentalrayGlobals...";
	if (size(`ls -type "mentalrayGlobals"`) == 0)
	{
		print "\nCreating a mentalrayGlobals node...";
		createNode "mentalrayGlobals";
	}
	//fix for scenes with missing mr globals node 
	
	print "\nboltOcclusion2 - Hiding lights...";	
	string $lights[] = `ls -type "light"`;
	for ($light in $lights) hide $light;
	//need to hide lights otherwise mental ray complains about dds textures on headlights
	
	print "\nboltOcclusion2 - Initialising colour sets...";	
	for ($obj in $selection)
		polyColorSet -currentColorSet -colorSet "colorSet1" $obj; //force colorSet1
		polyColorPerVertex -r 0 -g 0 -b 0 -a 0 -rel -cdo $obj;
	//trick maya into having vert color sets for all selected objects
	
	print "\nboltOcclusion2 - Remembering vertex colours...";
	select $selection; //reselect everything
	vertexcolourcopy -copy; //remember vertex colours before mr kills them
	
	print "\nboltOcclusion2 - Setting up bake set...";		
	if (`objExists "boltVertexBakeSet"`) delete "boltVertexBakeSet";
	createNode "vertexBakeSet" -n "boltVertexBakeSet";
	setAttr boltVertexBakeSet.colorMode 3;
	setAttr boltVertexBakeSet.occlusionRays $rays;
	//create a fresh occlusion vertex bake set
	
	print "\nboltOcclusion2 - Adding attrs to bake set...";	
    addAttr -ln filterSize -sn fs -min -1 boltVertexBakeSet;
    setAttr boltVertexBakeSet.filterSize 0.0001;
    addAttr -ln filterNormalTolerance -sn fns -min 0 -max 180 boltVertexBakeSet;
    setAttr boltVertexBakeSet.filterNormalTolerance 0.5; 
	//extra attrs needed to keep maya happy
	
	print "\nboltOcclusion2 - convertLightmapSetup...";	
	select $selection; //reselect everything	
	convertLightmapSetup -camera persp -vm -bo boltVertexBakeSet; 
	//works out and runs the convertLightmap command for currently selected objects
	
	print "\nboltOcclusion2 - Restoring vertex colours...";
	select $selection; //reselect everything
	evoBurnColoursToAlpha; //copy occlusion into alpha channel
	vertexcolourcopy -paste; //paste back original vertex colours
	delete "boltVertexBakeSet"; //tidy up

}


global proc boltDeleteUVSet (string $uvSet, string $shape)
//deletes a uv set from a single object, if it exists
{
	string $uvSets[];
	$uvSets = `polyUVSet -q -allUVSets $shape`;	
	if (`stringArrayContains $uvSet $uvSets`)
		polyUVSet -delete -uvSet $uvSet $shape;
}



global proc boltSuperOcclusion (int $smooth, float $darknessLimit, int $rays)
//new version, not dependant on prefs settings in mentalray
//includes fix for black intersecting verts.
//$rays sets quality, default is 64
{
	string $selection[] = `ls -sl`; //remember what was selected
			
	if (`objExists "boltTextureBakeSet"`) delete "boltTextureBakeSet";
	createNode "textureBakeSet" -n "boltTextureBakeSet";
	setAttr boltTextureBakeSet.colorMode 3;
	setAttr boltTextureBakeSet.occlusionRays $rays;
	setAttr -type "string" boltTextureBakeSet.prefix "boltOcc";
	setAttr boltTextureBakeSet.bakeToOneMap 1;
	setAttr boltTextureBakeSet.overrideUvSet 1;
	setAttr -type "string" boltTextureBakeSet.uvSetName "boltOccUVs";
	//create and setup a fresh occlusion texture bake set
	
	for ($obj in $selection)
	{
		string $darkVerts[]={};
		int $vertCounts[] = `polyEvaluate -vertex $obj`;
		for ( $v = 0; $v < $vertCounts[0]; $v++ )
		{
			string $vert = ($obj + ".vtx[" + $v +"]"); //for each vert
			float $currentAlpha[] = `polyColorPerVertex -q -a $vert`;
			if ($currentAlpha[0] < $darknessLimit)
			{
				$darkVerts[size($darkVerts)] = $vert;
			}
		}
		//get a list of any verts that need fixing on this object
		
		int $restoreFlag = 1;
		if (`objExists "hierarchyScriptNode"`) $restoreFlag = 0;
		//remember whether we need to restore hierarchy or not
		
		boltRemoveHierarchy; //helps with auto projection
		
		if (size($darkVerts) > 0)
		//only render texture if it is needed
		{
			setAttr -type "string" boltTextureBakeSet.prefix ("boltOcc_"+$obj);
			//new name for each texture to get round problem of maya caching/not updating textures
			//need to check when updating texture on a single part though - may not update
		
			float $areas[] = `polyEvaluate -worldArea $obj`;
			if ($areas[0] < 0.15)
			{
				setAttr "boltTextureBakeSet.xResolution" 256;
				setAttr "boltTextureBakeSet.yResolution" 256;
				setAttr boltTextureBakeSet.fillTextureSeams 3;
			}
			else
			{
				setAttr "boltTextureBakeSet.xResolution" 512;
				setAttr "boltTextureBakeSet.yResolution" 512;
				setAttr boltTextureBakeSet.fillTextureSeams 5;
			}
			//adjust size of map depending on surface area of object
				
			string $shapes[] = `listRelatives -fullPath -type "mesh" $obj`;
			string $shape = $shapes[0];
			//get the shape
				
			boltDeleteUVSet "boltOccUVs" $shape; //make sure we start with fresh UVs
			select $obj; 
			ConvertSelectionToFaces;
			polyAutoProjection -lm 0 -pb 0 -ibd 1 -cm 1 -l 2 -sc 1 -optimize 1 -planes 6 -uvSetName "boltOccUVs" -ps 1 -ws 1;
			polyUVSet -currentUVSet -uvSet "boltOccUVs" $shape;
			//create bake occlusion autounwrap uv set, and set it to be current
	
			select $obj; //reselect everything	
			convertLightmapSetup -project "M:/art/vehicles/" -keepOrgSG -camera persp -bo boltTextureBakeSet; 
			//works out and runs the convertLightmap command for currently selected objects
		
			int $randomNo = `rand 999999999`;
			string $textureName = ("M:/art/vehicles/lightMap/boltOcc_" + $obj + ".tif");
			string $textureNameNew = ("M:/art/vehicles/lightMap/boltOcc_" + $randomNo + ".tif");
			sysFile -copy $textureNameNew $textureName;
			//randomly rename texture to fool maya into thinking it is new
		 		
			if (`objExists "boltOccFileNode"`) delete boltOccFileNode;
			shadingNode -asTexture file -name "boltOccFileNode";
			setAttr -type "string" boltOccFileNode.fileTextureName $textureNameNew;
			//create a fresh file node with the newly created occlusion texture		
						
			for ( $vert in $darkVerts )
			//for each dark vert
			{
				string $uvNames[] = `polyListComponentConversion -fromVertex -toUV $vert`;
				$uvNames = `ls -flatten $uvNames`;
				//get uvs for this vert
			
				float $totalAlpha = 0;
				int $numAlphas = 0;
				int $flagSmoothThisVert = 0;
			
				for ($uvName in $uvNames)
				{
					float $uvCoords[] = `polyEditUV -q $uvName`;
					//get co-ords of a uv on map
			
					float $rgb[] = `colorAtPoint -u $uvCoords[0] -v $uvCoords[1] boltOccFileNode`;
					//get colour of the occlusion map at this uv
				
					if ($rgb[0] < $darknessLimit) 
					{
						$rgb[0] = `boltRethinkAlpha $uvName $darknessLimit`;
						$flagSmoothThisVert = 1;
						//looks for a better value to use than black 
					}
				
					$totalAlpha = $totalAlpha + $rgb[0];
					$numAlphas ++;
				
					if ($smooth == 0)
					{
						string $vfs[] = `polyListComponentConversion -fromUV -toVertexFace $uvName`;
						$vfs = `ls -flatten $vfs`;
						for ($vf in $vfs)
						{
							polyColorPerVertex -a $rgb[0] -nun $vf;
						}
					}
				}
			
				if (($smooth == 1)||($flagSmoothThisVert==1))			
				{
					float $alpha = $totalAlpha/$numAlphas; //get the average occlusion at this point
					polyColorPerVertex -a $alpha -nun $vert; //set alpha to match map
				}
				//smooth this vert if smoothing is on, or if this vert has been rethunk.
			    
			    
			}
			
			boltDeleteUVSet "boltOccUVs" $shape;
			delete boltOccFileNode;
			sysFile -delete $textureNameNew; //delete the randomly named texture
			
		}
		if ($restoreFlag == 1) boltRestoreHierarchy; //helped with auto projection
	}
	delete "boltTextureBakeSet"; //tidy up
	
	print "Texture based occlusion fixes done!";
	
}


global proc float boltRethinkAlpha(string $uvName, float $darknessLimit)
{
	//print ("\nrethinking " + $uvName);
	
	string $polys[] = `polyListComponentConversion -fromUV -toFace $uvName`;
	$polys = `ls -flatten $polys`;
	string $uvs[]   = `polyListComponentConversion -fromFace -toUV $polys[0]`;
	$uvs = `ls -flatten $uvs`;
	//get a poly from the uv, then a list of all the uvs on that poly.
	
	float $targetUV[] = `polyEditUV -q $uvName`;
	//the uv we are working on
	
	float $avgUV[] = {}; 
	
	for ($uv in $uvs)
	{
		float $uvCoords[] = `polyEditUV -q $uv`; //get co-ords of a uv on map
		$avgUV[0] = $avgUV[0] + $uvCoords[0];
		$avgUV[1] = $avgUV[1] + $uvCoords[1];
	}
	
	$avgUV[0] = $avgUV[0] / `size $uvs`;
	$avgUV[1] = $avgUV[1] / `size $uvs`;
	//average uv co-ord of the selected polygon
	
	float $alpha = 0;
	float $newUV[];
	
	
	for ($i=3; $i>=0; $i--)
	{
		$newUV[0] = ( (($i*$targetUV[0])+($avgUV[0])) / ($i + 1) );
		$newUV[1] = ( (($i*$targetUV[1])+($avgUV[1])) / ($i + 1) );
	
		float $rgb[] = `colorAtPoint -u $newUV[0] -v $newUV[1] boltOccFileNode`;
		if ($rgb[0]>$darknessLimit) return $rgb[0];
	}
	//search for a brighter UV
		
	return 0.5; //$darknessLimit;
}

global proc string[] boltGetExhaustTipPolys(string $obj)
// searches for a large triangle fan near the exhaust pivot - should be the exhaust hole
// returns list of polygons
// used for auto mud and occlusion of exhaust tip.
{
	float $searchDistance = 0.1;  // max distance from pivot to search for tip
	int $minPolygons = 6; //min no of polys the exhaust tip vert must have to be detected
	
	vector $exhaustPos = `xform -q -ws -rp $obj`;
	//get exhaust pivot
	
	string $closeVerts[]={};
	int $closeVertsPolys[]={};
	
	int $noVerts = GetNbMeshVerts($obj);
	for($k=0 ; $k < $noVerts; $k++)
	{
		string $vert = ($obj+".vtx["+$k+"]");
		//get each vertex
				
		vector $vertPos = `pointPosition -w $vert`;
		vector $distVector = $vertPos - $exhaustPos;
		float $dist = `mag $distVector`;
		if ($dist < $searchDistance)
			$closeVerts[size($closeVerts)] = $vert;
		//calc distance from exhaust pivot + store if close
		
	}
	
	for ($vert in $closeVerts)
	{
		string $polys[] = `polyListComponentConversion -fromVertex -toFace $vert`;
		$polys = `ls -flatten $polys`;
		$closeVertsPolys[size($closeVertsPolys)] = size($polys);					
	}
	//store num of polys on each of the close verts 
	
	int $mostPolysIndex = 0;
	int $mostPolys = 0;	
	for ($i=0; $i<size($closeVertsPolys); $i++)
	{
		if ($closeVertsPolys[$i] > $mostPolys)
		{
			$mostPolys = $closeVertsPolys[$i];
			$mostPolysIndex = $i;
		}
	}
	//find the vert with the biggest number of polys
	
	if ($closeVertsPolys[$mostPolysIndex]>$minPolygons)
	{
		$vert = $closeVerts[$mostPolysIndex];
		string $polys[] = `polyListComponentConversion -fromVertex -toFace $vert`;
		$polys = `ls -flatten $polys`;
		
		return $polys;
	}
		
	return {};
}



global proc boltAutoOccludeExhaust(string $obj)
//auto detects exhaust tip and paints it black if found
{
	string $polys[] = `boltGetExhaustTipPolys $obj`;
	
	if (size($polys))
	{
		string $vfs[] = `polyListComponentConversion -fromFace -toVertexFace $polys`;
		$vfs = `ls -flatten $vfs`;
	
		polyColorPerVertex -a 0 $vfs;
	}
}


global proc boltAutoOccludeWheel(string $obj)
//adds shading to inside of wheels + tyres
{

	float $bb[] = `polyEvaluate -boundingBox $obj`;	
	
	string $verts[] = `ls -fl ($obj + ".vtx[*]")`;
	for ($vert in $verts)
	{
		vector $vertPos = `pointPosition -w $vert`;
				
		float $xWidth = $bb[1] - $bb[0];
		float $xPos = $vertPos.x - $bb[0];
		float $xRatio = $xPos / $xWidth;
		float $alphas[] = `polyColorPerVertex -q -a $vert`;
		float $alpha = $alphas[0];
		
		
		
		if (`gmatch $obj "*_FL*"`||`gmatch $obj "*_BL*"`)
		{
			$xRatio = 1-$xRatio;
		}
		
		float $darkenAmount = 0.0;
		
		if ($xRatio > 0.6) $darkenAmount = 1.0;
		if (($xRatio > 0.4)&&($xRatio <= 0.6)) $darkenAmount = 0.95;
		
		//only darken the outside of the tyre on the outside facing portion - avoids darkening the wheel center too much
		if (($xRatio >= 0.0)&&($xRatio <= 0.4)) 
		{
			float $radius = ($bb[3] - $bb[2]) / 2;
			vector $bbCenter2D = << 0, ($bb[3]+$bb[2])/2, ($bb[5]+$bb[4])/2 >>;
					
			vector $vertPos2D = <<0,$vertPos.y,$vertPos.z>>;
			float $dist = mag($vertPos2D-$bbCenter2D);
			if ($dist/$radius > 0.98) $darkenAmount = 0.7;
		}
	
		$alpha = $alpha - $darkenAmount;
		//adjust maths for left/right side
			
		if ($alpha < 0) $alpha = 0;
		if ($alpha > 1) $alpha = 1;
		//clamp values
		
		polyColorPerVertex -a $alpha $vert;
	}
}

global proc boltAutoOccludeChrome(string $obj)
//sets any chrome shaders on given object to be un-occluded
{
	string $oldSel[] = `ls -sl`;
	
	string $chromeShaders[] = `ls -type "evocgfxShader" "*chrome*"`;
	//get list of chrome shaders in scene
	
	for ($shader in $chromeShaders)
	{
		select -cl;
		boltDoSelShader $shader {$obj};
		polyColorPerVertex -a 1;
	}
	//set chrome polys to white occlusion
	
	select $oldSel;
	//restore original selection	
}

global proc boltOcclusionGUI()
{
	if (`window -exists boltOcclusionWindow`) {deleteUI boltOcclusionWindow;} 
	//delete the window if it already exists
	
	window -title "Paint Occlusion" -toolbox 1 boltOcclusionWindow;
		scrollLayout;
	    	columnLayout;
	    			    		
	    		checkBox -label "Auto occlude exhaust tips"   					-v 1 boltCheckBoxOcc1;
	    		checkBox -label "Darken insides of wheels"   					-v 1 boltCheckBoxOcc2;
	    		checkBox -label "Brighten chrome on mirrors"  				 	-v 1 boltCheckBoxOcc3;
	    		checkBox -label "Brighten chrome on lights"  					-v 1 boltCheckBoxOcc4;
 				checkBox -label "Fix black intersecting verts (slow)"			-v 1 boltCheckBoxOcc5;
				checkBox -label "Turn off 'Display Colors' flag"				-v 1 boltCheckBoxOcc6;
				
				rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 50;
					text -label "Number of vertex rays to cast:";
					floatField -value 128 -precision 0 boltTextFieldOccRays;
				setParent ..;
				rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 50;
					text -label "Number of texture rays to cast:";
					floatField -value 32 -precision 0 boltTextFieldTOccRays;
				setParent ..;
	    			
	    		button -height 20 -width 200 -label "Paint Occlusion" -command "boltDoOcclusionFromGUI" -ann "Renders occlusion with the above settings";
	    		text -label "";
	    		button -height 20 -width 200 -label "Smooth Occlusion" -command "boltSmoothOcclusion" -ann "Smooths out any hard edges in the occlusion on selected objects";
				rowLayout -numberOfColumns 2 -cw 1 100 -cw 2 100;
	    			button -height 20 -width 99  -recomputeSize 0 -label "Darken"    -ann "Darkens the ambient occlusion of selected objects"    -command "boltDarken";
					button -height 20 -width 99  -recomputeSize 0 -label "Brighten"  -ann "Brightens the ambient occlusion of selected objects"  -command "boltBrighten";
				setParent ..;
	    		
	    			
			setParent ..;					
		setParent ..;
	setParent ..;   
                 		                             
	showWindow boltOcclusionWindow;
	//display the window
}


global proc boltDoOcclusionFromGUI()
{
	string $sel[] = `ls -sl`;
	
	print ("\nGetting values from GUI...");
	int $rays = `floatField -q -value boltTextFieldOccRays`;
	int $tRays = `floatField -q -value boltTextFieldTOccRays`;
	
	print ("\nCalculating vertex occlusion...");
	boltOcclusion2 $rays;
	//do main vertex occlusion on all selected objects
	print ("\nVertex occlusion complete...");
	
	if 	(`checkBox -q -v boltCheckBoxOcc5`)
	{
		print ("\nCalculating texture occlusion for fully occluded verts...");
		boltSuperOcclusion 1 0.05 $tRays;	
	}
	//fix black verts
	
	select $sel;
	
	if 	(`checkBox -q -v boltCheckBoxOcc1`)
	{
		print ("\nCalculating occlusion for exhaust tips...");
		for ($obj in $sel)
		{
			if (`gmatch $obj "*EXHAUST*"`)
			{
				boltAutoOccludeExhaust $obj;
			}
		}
	}
	//auto occlude exhausts if found

	if 	(`checkBox -q -v boltCheckBoxOcc2`)
	{
		print ("\nDarkening insides of wheels...");
		for ($obj in $sel)
		{
			if (($obj != "WHEEL_F")&&($obj != "WHEEL_B"))
			//prevents bike wheels being shaded
			{
				if (`gmatch $obj "WHEEL_*"`)
				{
					boltAutoOccludeWheel $obj;
				}
			}
		}
	}
	//auto occlude wheels if found

	if 	(`checkBox -q -v boltCheckBoxOcc3`)
	{
		print ("\nBrightening chrome on mirrors...");
		for ($obj in $sel)
		{
			if (`gmatch $obj "*MIRROR*"`)
			{
				boltAutoOccludeChrome $obj;
			}
		}
	}
	//auto occlude mirror chrome if found

	if 	(`checkBox -q -v boltCheckBoxOcc4`)
	{
		print ("\nBrightening chrome on lights...");
		for ($obj in $sel)
		{
			if (`gmatch $obj "*LIGHT*"`)
			{
				boltAutoOccludeChrome $obj;
			}
		}
	}
	//auto occlude light chrome if found
         
    if 	(`checkBox -q -v boltCheckBoxOcc6`)
	{
		print ("\nSwitching off display colours flag on all selected objects...");
		boltSetDisplayColors 0;
	}
	//switch off display colours flag  
         
         
         
}
	

global proc boltSetDisplayColors(int $onOff)
//sets the display colours flag on/off for the current selection
{
	string $selection[] = `ls -sl`;
	string $shapes[] = `boltTransformsToShapes $selection`;
	for ($shape in $shapes)
	{
		setAttr ($shape + ".displayColors") $onOff;
	}
}

	





global proc boltOcclusion()

//does mental ray occlusion baking to vertex colours,
//copies info to vertex alpha channel
//sets vertex colours back to white.

{
	eval("vertexcolourcopy -copy");

	global string $gMrBakeOptionBox;
	mrBakeToVertices 1;
	mrBakeCallback $gMrBakeOptionBox 1;
	hideOptionBox;
	refresh;
	//renders occlusion to colour channels
	//assuming settings in mrBake are right!

	//copies the occlusion value from RGB to the alpha channel.
	//needs BurnColoursToAlpha.mll
	eval("evoBurnColoursToAlpha");

	eval("vertexcolourcopy -paste");
}

global proc boltSmoothOcclusion()
//smooths occlusion by averaging vertex face alphas
{
	string $objList[] = `ls -sl`;
	for ($obj in $objList)
	{
		int $vertCounts[] = `polyEvaluate -vertex $obj`;
		int $vertCount = $vertCounts[0];
		//get num of verts
		
		for ( $v = 0; $v < $vertCount; $v++ )
		//for each vert
		{
			//find vertex faces
						
			string $faces[] = `polyListComponentConversion -toFace ($obj + ".vtx[" + $v +"]")`;
			$faces = `ls -flatten $faces`;
			// Faces associated with vertex
			
			string $vertFaces[] = {};
						
			for ( $f = 0; $f < size($faces); $f++ )
			{
				$faceNum = `match "[^\.]*$" $faces[$f]`;
				$faceNum = `match "[0-9]+" $faceNum`;
				//strip face names back to face numbers			
				$vertFaces[$f] = ($obj + ".vtxFace[" + $v + "][" + $faceNum + "]");				
			}
			// get list of vertex faces.
			
			
			float $vfAlphas[] = {};
			for ($vf in $vertFaces)
			{
				float $temp[] = `polyColorPerVertex -q -a $vf`;
				$vfAlphas[size($vfAlphas)] = $temp[0];
			}
			//store vertex face alphas
			
			float $average = 0;
			for ($vfa in $vfAlphas)
			{
				$average = $average + $vfa;
			}
			$average = $average / (size($vfAlphas));
			//average alphas
			
			for ($vf in $vertFaces)
			{
				$vfAlphas[size($vfAlphas)] = `polyColorPerVertex -notUndoable -a $average $vf`;
			}
			//reapply averaged alphas
		}
	}
}






global proc boltDarken()
{
	float $amount =  `floatField -q -value boltTextFieldBrightenAmount`;
	
	string $sel[] = `ls -sl -fl`;
	string $vertices[] = `polyListComponentConversion -tvf $sel`;
	
	polyColorPerVertex -a (-1 * $amount) -rel $vertices;
	
	for ($vert in $vertices)
	{
	
			float $vertA[] 	 = `polyColorPerVertex -q -a -nun $vert`;
			//get alpha
					
			if ($vertA[0] > 1) polyColorPerVertex -a 1 -nun $vert;
			if ($vertA[0] < 0) polyColorPerVertex -a 0 -nun $vert;
			//cap this value if necessary.
			
	}
	
	print "Occlusion Darkened\n"; 
}

global proc boltBrighten()
{
	float $amount =  `floatField -q -value boltTextFieldBrightenAmount`;
	
	string $sel[] = `ls -sl -fl`;
	string $vertices[] = `polyListComponentConversion -tvf $sel`;
	
	polyColorPerVertex -a $amount -rel $vertices;
		
	for ($vert in $vertices)
	{
	
			float $vertA[] 	 = `polyColorPerVertex -q -a -nun $vert`;
			//get alpha

			if ($vertA[0] > 1) polyColorPerVertex -a 1 -nun $vert;
			if ($vertA[0] < 0) polyColorPerVertex -a 0 -nun $vert;
			//cap this value if necessary.
	}
	
	print "Occlusion Brightened\n"; 
}

global proc boltContrast()
{
	string $sel[] = `ls -sl -fl`;
    string $selObjs[] = `polyListComponentConversion $sel`;
    
// $col=4 for Red. $col=5 for Green. $col=6 for Blue. $col=7 for Alpha.

//	$startTime = `timerX`;
	int $col = 7;

	int $i = 0;
	progressWindow -title "Occlusion Contrast" -st ("Object Number: "+($i+1)) -progress $i -min 0 -max `size $selObjs` -isInterruptable false;

	for ($i=0; $i<`size $selObjs`; $i++)
	{
		delete -ch $selObjs[$i];
		string $verts[];

        	int $mode = 0;
			if (`gmatch $sel[0] "*.vtx*"`)  // If verts are selected
			{
		    	$verts = $sel;
		    	$mode = 1;
			}
			else
			{
		    	$verts = `polyListComponentConversion -tv $selObjs[$i]`;
			}

		$verts = `ls -fl $verts`;
		float $vtxCols[] = `polyColorPerVertex -q -a $verts`;

		// Create a tweak to keep the polyColorPerVertexNode (Flip a normal will do)
        polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($selObjs[$i]+".f[0]");
		polyNormal -normalMode 0 -userNormalMode 0 -ch 1 ($selObjs[$i]+".f[0]");

			// History fudge to find the polyColorPerVertex Node
	        string $oldHistory[] = `listHistory $selObjs[$i]`;
			polyColorPerVertex -rel -a 0 $selObjs[$i];
			string $newHistory[] = `listHistory $selObjs[$i]`;
			string $fastColNode[] = stringArrayRemoveExact($oldHistory, $newHistory);
	        //
		//

		float $numVerts = `size $verts`;
		for ($j=0;$j<$numVerts;$j++)
		{
		string $vertFaceCols[32];
		clear $vertFaceCols;

		int $vertNumber=$j;
		if ($mode == 1) // i.e. we are working on selected verts instead of objects
		{
			string $buffer[];
			tokenize $verts[$j] "[]" $buffer;
			$vertNumber = $buffer[1];
		}

		$vertFaceCols = `listAttr -s -m ($fastColNode[0]+".vclr["+$vertNumber+"]")`;

		int $numFaces = `size $vertFaceCols`;
	    	for ($k=$col;$k<$numFaces;$k+=4)
	    	{
				float $vertAlpha = $vtxCols[$j];
				$vertAlpha *= $vertAlpha;
				if ($vertAlpha > 1) $vertAlpha=1;
				if ($vertAlpha < 0) $vertAlpha=0;
	       		setAttr ($fastColNode[0]+"."+$vertFaceCols[$k]) $vertAlpha;
	    	}
		}
	progressWindow -edit -st ("Object Number: "+($i+1)) -progress $i;
	}
	progressWindow -endProgress;

delete -ch $selObjs;
select -r $sel;

//$totalTime = `timerX -startTime $startTime`;
//print ("Total Time: "+$totalTime+"\n");

	/* OLD SLOW METHOD
	for ($i=0; $i<`size $selObjs`; $i++)
	{
		string $verts[] = `polyListComponentConversion -tv $selObjs[$i]`;
		$verts = `ls -fl $verts`;
		float $vtxCols[] = `polyColorPerVertex -q -a $verts`;

		for ($j=0; $j<`size $verts`; $j++)
		{
			float $vertAlpha = $vtxCols[$j];
			$vertAlpha *= $vertAlpha;

			if ($vertAlpha > 1) $vertAlpha=1;
			if ($vertAlpha < 0) $vertAlpha=0;
			polyColorPerVertex -notUndoable -a $vertAlpha $verts[$j];
		}
	}
	
	*/
	print "\nAmbient Occlusion Contrast Increased\n";
}


global proc boltMudPainter(float $flatOp, float $groundProximityOp, float $normalBiasOp, float $creviceOp, float $wheelEmitOp, float $interiorOp, int $exhaustMud, int $brakeMud, int $lightMud, float $topNormalBiasOp, int $wipeWindscreen, int $delHistory, float $wheelMudLevel)
//paints mud onto selected objects with settings provided from gui
{
	int $debug = 0;
	
	string $allInterior[] = {};	   	
	if (`objExists "INTERIOR_SHELL"`)
	{
		$allInterior = `listRelatives -allDescendents -type "transform" "INTERIOR_SHELL"`;
		$allInterior[size($allInterior)]= "INTERIOR_SHELL";
	}
	
	boltRemoveHierarchy;
	//hack needed otherwise normal directions are wrong on bike forks
	
	$allInterior = `ls -long $allInterior`;
	
	if ($debug==1) confirmDialog -message "Getting object lists...";
	string $locs[] = boltShapesToTransforms(`ls -long -exactType "locator"`); 
	string $defs[] = boltShapesToTransforms(`ls -long -type "lattice"`);
	string $shad[] = boltShapesToTransforms(`ls -long -type "evoamboccvollocator"`);
	string $temp[]	  = `ls -long -type "transform" "*_TEMP"`;     
	string $RDcols[]  = `ls -long -type "transform" "RAGDOLL_*_COL"`;       
	string $cols[]    = `ls -long -type "transform" "*_COL"`; 
	string $cons[]    = `ls -long -type "aimConstraint"`;  
	string $lods[]    = `ls -long -type "transform" "*_LOD*"`;
	$cols = `stringArrayRemove $RDcols $cols`;
	//get misc lists
	
	string $crumpleZones[] = `ls -long -type "transform" "CRUMPLEZONE_*"`;
	//list of full damage crumple zone boxes.
	
	string $safetyZones[] = `ls -long -type "transform" "SAFETYZONE_*"`;
	//list of no damage safety zone boxes.
	
	string $boostShapes[] = `ls -long -type "transform" "BOOST_*"`;
	
	string $wheels[] = boltShapesToTransforms(`ls -long -type "mesh" "WHEEL_??Shape"`);						//all wheels in scene
	if (size($wheels) == 0) $wheels = boltShapesToTransforms(`ls -long -type "mesh" "w:WHEEL_??Shape"`);	//if no wheels found, look for refs.
	if (size($wheels) == 0) $wheels = boltShapesToTransforms(`ls -long -type "mesh" "WHEEL_?Shape"`);		//if no wheels found, look for bikes.
	if (size($wheels) == 0) $wheels = boltShapesToTransforms(`ls -long -type "mesh" "w:WHEEL_?Shape"`);	//if no wheels found, look for bike refs.
	//wheels without spares, lods or swaps
	
	if (size($wheels) == 0) error "Mud painting failed! No wheels found in scene - needed to calculate mud spray";
	
	string $spareWheels[] = boltShapesToTransforms(`ls -long -type "mesh" "WHEEL_SPARE?Shape"`);	//all spare wheels
	string $allWheels[] = boltShapesToTransforms(`ls -long -type "mesh" "WHEEL_*"`);
	$allWheels = `stringArrayRemove $spareWheels $allWheels`;
	
	string $allDiscs[] = `ls -long -type "transform" "DISC_*"`;	
	
	
	   	
	string $objList[] = boltShapesToTransforms(`ls -long -geometry`);
	
	float $bb[] = `polyEvaluate -boundingBox $objList`;	
	float $height = $bb[3];
	//get the max Y value of the vehicle
		
	string $selected[] = `ls -sl -long`;
	if (size($selected)>0) 
	{
		$objList = $selected;
	}
	//if objs are selected, use those instead
	else
	{
		string $confirm = `confirmDialog -title "WARNING" 
			-message "No objects selected! Do you want to redo mud on all objects in scene?" 
			-button "Yes" -button "No" 
			-defaultButton "No" -cancelButton "No" -dismissString "No"`;
		if ($confirm == "No") $objList = {};
	}
	//warn user before mudding everything
	
	
	
	$objList = `stringArrayRemoveDuplicates $objList`;
	$objList = `stringArrayRemove $temp     $objList`;
	$objList = `stringArrayRemove $defs     $objList`;  
	$objList = `stringArrayRemove $RDcols   $objList`;
	$objList = `stringArrayRemove $cols     $objList`;
	$objList = `stringArrayRemove $locs     $objList`;
	$objList = `stringArrayRemove $shad     $objList`;
	$objList = `stringArrayRemove $crumpleZones   $objList`;
	$objList = `stringArrayRemove $safetyZones    $objList`;
	$objList = `stringArrayRemove $boostShapes    $objList`;  
		
		
	//work out objlist of standard muddable shapes
		
	
	if ($delHistory == 1)
	{
		for ($obj in $objList)
		{
			delete -constructionHistory $obj;
		}
	}
	//delete history - 4x speed up in some cases
	
	$allInterior = `stringArrayRemove $temp     $allInterior`;
	$allInterior = `stringArrayRemove $defs     $allInterior`;  
	$allInterior = `stringArrayRemove $RDcols   $allInterior`;
	$allInterior = `stringArrayRemove $cols     $allInterior`;
	$allInterior = `stringArrayRemove $locs     $allInterior`;
	$allInterior = `stringArrayRemove $shad     $allInterior`;
	//clean up locators and stuff from interior
	

	
	string $selWheels[] = {};
	for ($w in $allWheels)
	{ 
		if  (`sFindItem $objList $w` != -1)
			 $selWheels[size($selWheels)]= $w;
	}
	$objList = `stringArrayRemove $wheels $objList`;
	//gets a seperate list of selected wheels
	
	
		
	string $selDiscs[] = {};
	for ($d in $allDiscs)
	{ 
		if  (`sFindItem $objList $d` != -1)
			 $selDiscs[size($selDiscs)]= $d;
	}
	$objList = `stringArrayRemove $allDiscs $objList`;
	//gets seperate list of selected discs
	
	string $selInterior[] = {};
	for ($i in $allInterior) 
	{
		if  (`sFindItem $objList $i` != -1)
			 $selInterior[size($selInterior)]= $i;
	}
	if ($interiorOp == 0) $objList = `stringArrayRemove $allInterior $objList`;
	//gets seperate list of selected interior parts
	//dont calc mud for interior if it is set to full off
		
	
	
	
	float $bb[] = `polyEvaluate -boundingBox $wheels`;	
	float $wheelDiam = $bb[3] - $bb[2];
	float $wheelBase = $bb[5] - $bb[4] - $wheelDiam;
	//calculate wheelbase and diameter
	
		
	
	if ($debug==1)
	{
		print "\n$objList:\n";
		print $objList;
		print "\n$selInterior:\n";
		print $selInterior;
		print "\n$selWheels:\n";
		print $selWheels;
		print "\n$selDiscs:\n";
		print $selDiscs;
	}

	
	undoInfo -state off;
	//turn off otherwise maya runs out of memory.
		
		
float $startTime = `timerX`;

		
		
	for ($obj in $objList)
	{
		//if ($debug==1) confirmDialog -message $obj;
		
		string $vfs[] = `ls -flatten ($obj + ".vtxFace[*][*]")`;
			
		for ($vf in $vfs)
		{
				string $buffer[];
				$numTokens = `tokenize $vf  "[]." $buffer`;
				string $v = ($buffer[0] + ".vtx[" + $buffer[2] + "]");
				//gets the vert name
				
				
//////////BASE COLOUR
//Base mud colour - will be minimum mud colour on vehicle 
		
				float $colour = 0; // base colour now used as a minumum, not additive // $flatOp;
				//set initial base colour

//////////GROUND PROXIMITY
//Fall off depending on distance from ground			
			
				vector $vert = `pointPosition -w $v`;
				float $groundProximity = 1 - ($vert.y / $height);
				
				$colour = $colour + ($groundProximity * $groundProximityOp);
			
/////////NORMAL BIAS
//More Mud on underneath and rear faces
			
				float $vfNormal[] = `boltGetWorldSpaceVector $vf`;

				float $normalBiasX = (1 - abs($vfNormal[0]));
				float $normalBiasY = 1+(-1 * $vfNormal[1]);
				if ($normalBiasY < 0) $normalBiasY = 0;
				
				float $normalBiasZ = 1+(-1 * $vfNormal[2]);
				if ($normalBiasZ < 0) $normalBiasZ = 0;
				
				$colour = $colour + ($normalBiasOp * ($normalBiasX * $normalBiasY * $normalBiasZ));

/////////UP NORMAL BIAS
//More Mud on top facing faces
							
				float $normalBiasY = $vfNormal[1];
				if ($normalBiasY < 0) $normalBiasY = 0;
				$normalBiasY = `pow $normalBiasY 3`;
				
								
				$colour = $colour + ($topNormalBiasOp * $normalBiasY);

			
////////CREVICE MUD
//Takes info from the ambient occlusion data

				float $crevice[] = `polyColorPerVertex -q -a $vf`;
				$colour = $colour + ((1 - $crevice[0]) * $creviceOp);
				
///////WHEEL EMITTERS
				
				float $wheelEmit = 0;
												
				for ($wheel in $wheels) //
				{
					float $wheelPos[] = `xform -q -ws -rp $wheel`;
												
					float $zDist = $vert.z - $wheelPos[2];
					//dist of vert from wheel in z axis direction
			
					float $zCol = 1;
					
					if ($zDist > 0) $zCol = (1 - $zDist/(0.5*$wheelDiam));
					if ($zCol < 0) $zCol = 0;
					//calculate z fade off infront of wheel
					
					if ($zDist < 0) $zCol = 2*(1 - ($zDist/-(1.3*$wheelBase)));
					if ($zCol > 1) $zCol = 1;
					if ($zCol < 0) $zCol = 0;
					//calculate z fade off behind wheel
					
					float $coneSize = (0.5*$wheelDiam);
					if ($zDist < 0) $coneSize = $coneSize+(1.1*($zDist/-$wheelBase));
					$coneSize = `pow $coneSize 2`; 
					//calculate cone diameter squared based on z distance 
					
					float $xyDist = `pow ($vert.x-$wheelPos[0]) 2` + `pow ($vert.y-$wheelPos[1]) 2`;
					float $xyCol = 1-($xyDist/$coneSize);
					if ($xyCol < 0) $xyCol = 0;
					if ($xyCol > 1) $xyCol = 1;
				
				
					$wheelEmit = $wheelEmit + ($zCol*$xyCol);
				}
				
				
											
				$colour = $colour + ($wheelEmit * $wheelEmitOp);
				
///////BRAKE GLOW MUD CORRECTION

				if (($brakeMud == 1) && (`gmatch $obj "*BULB_*"`))
				{
					$colour = 0.5;
				}
				
///////WINDSCREEN WIPE
				if (($wipeWindscreen == 1) && ((`gmatch $obj "*WINDOW_F"`) || (`gmatch $obj "*WINDOW_F_*"`)) )
				//do all front windows, but not _FL windows.
				{
					if (`objExists "WINDOW_F"`)
					{
						float $bounds[] = `polyEvaluate -boundingBox "WINDOW_F"`;
						//returns the object's bounding box in 3d space as 6 floats in MEL: xmin xmax ymin ymax zmin zmax,
						
						vector $screenBottom = << (($bounds[0]+$bounds[1])/2) , $bounds[2], $bounds[5] >>;
						vector $screenTop    = << (($bounds[0]+$bounds[1])/2) , $bounds[3], $bounds[4] >>;
						
						float $screenWidth = ($bounds[1] - $bounds[0])/2;
						
						vector $screenVector = $screenBottom - $screenTop;
						float $screenRadius = `mag $screenVector`;
						
						vector $vertVector = $screenBottom - $vert;
						
						$vertVector = <<($vertVector.x*($screenRadius/$screenWidth)), $vertVector.y, $vertVector.z>>;
						//compensate for width
						
						float $vertRadius = `mag $vertVector`;
						
						float $wipeAmount = $vertRadius/$screenRadius;
						if ($wipeAmount>1) $wipeAmount = 1;
						$wipeAmount = `pow $wipeAmount 5`;
						
						$colour = $colour * $wipeAmount;
						
						print ("\n SCREEN RADIUS = " + $screenRadius);
						
						
						
					}
				}

////////////////////////////////WRITE COLOUR				
				
				if ($colour < $flatOp) $colour = $flatOp;       
				if ($colour > 1) $colour = 1;       
				polyColorPerVertex -g $colour $vf;
				//assign clamped colour
			
		}
		
///////EXHAUST HOLE MUD CORRECTION

		if (($exhaustMud == 1) && (`gmatch $obj "*EXHAUST_*"`))
		{
			string $polys[] = `boltGetExhaustTipPolys $obj`;
			if (size($polys))
			{
				string $vfs[] = `polyListComponentConversion -fromFace -toVertexFace $polys`;
				$vfs = `ls -flatten $vfs`;
				polyColorPerVertex -g 0 $vfs;
			}
		}
		
///////HEADLAMP REFLECTOR MUD CORRECTION

		//obsolete code - mud-free-ness now handled in shader
						
/////////////////////////////////
		
		print ($obj + " mud colours set\n");
		refresh -force;
	}
										
///////WHEELS	
//full mud on outside tread, fading to 50% in center of wheel

	for ($obj in $selWheels)
	{
		int $noVerts = GetNbMeshVerts($obj);
			
		for($k=0 ; $k < $noVerts; $k++)
		{
		
			string $v = ($obj+".vtx["+$k+"]");
			//go through each vertex

			float $wheelPos[] = `xform -q -ws -rp $obj`;
			vector $vert = `pointPosition -w $v`;
			// get wheel pos and vert pos
			
			float $radius = ($wheelDiam/2);
			float $vertDist = `pow ($vert.y-$wheelPos[1]) 2` + `pow ($vert.z-$wheelPos[2]) 2`;
			float $vertDist = `pow $vertDist 0.5`;
			
			float $colour = `pow ($vertDist / $radius) 10`;
			$colour = $colour + 0.2;
			if ($colour < 0.0) $colour = 0.0;       
			if ($colour > 1) $colour = 1;
			$colour = $colour * $wheelMudLevel;       
			string $vfs[] = `polyListComponentConversion -fv -tvf $v`;
			polyColorPerVertex -g $colour $vfs;
			//assign clamped colour
		}	
		print ($obj + " mud colours set\n");
		refresh -force;
	}
		
///////DISCS
//50% mud in center, clean on outside edge - simulates self cleaning

	for ($obj in $selDiscs)
	{
		float $bb[] = `polyEvaluate -boundingBox $obj`;
		float $discDiam = $bb[3] - $bb[2];
		//work out disc diameter
		
		int $noVerts = GetNbMeshVerts($obj);
			
		for($k=0 ; $k < $noVerts; $k++)
		{
		
			string $v = ($obj+".vtx["+$k+"]");
			//go through each vertex

			float $discPos[] = `xform -q -ws -rp $obj`;
			vector $vert = `pointPosition -w $v`;
			// get wheel pos and vert pos
			
			float $radiusSquared = `pow ($discDiam/2) 2`;
			float $vertDist = `pow ($vert.y-$discPos[1]) 2` + `pow ($vert.z-$discPos[2]) 2`;
			
			float $colour = 1 - ($vertDist / $radiusSquared);
			if ($colour < 0) $colour = 0;       
			if ($colour > 0.5) $colour = 0.5;       
			$colour = $colour * $wheelMudLevel;
			string $vfs[] = `polyListComponentConversion -fv -tvf $v`;
			polyColorPerVertex -g $colour $vfs;
			//assign clamped colour
		}	
		print ($obj + " mud colours set\n");
		refresh -force;
	}	
	
///////INTERIOR
//reduce mud on all interior parts
	
	for ($obj in $selInterior)
	{
				
		int $noVerts = GetNbMeshVerts($obj);
		for($k=0 ; $k < $noVerts; $k++)
		{
			string $v = ($obj+".vtx["+$k+"]");
			//go through each vertex
			
			string $vfs[] = `polyListComponentConversion -fv -tvf $v`;
			for ($vf in $vfs)
			{   
				float $currentMud[] = `polyColorPerVertex -q -r $vf`;
				float $colour = $interiorOp * $currentMud[0];
				if ($colour < 0) $colour = 0;       
				if ($colour > 1) $colour = 1; 
				polyColorPerVertex -g $colour $vf;
				//assign new clamped colour
			}
		}
		print ($obj + " mud colours set\n");
		refresh -force;
	}
	
	undoInfo -state on;
	//restore unfo

	if ($debug==1)
	{
		print "\nFINAL LISTS:\n";
		print "\n$objList:\n";
		print $objList;
		print "\n$selInterior:\n";
		print $selInterior;
		print "\n$selWheels:\n";
		print $selWheels;
		print "\n$selDiscs:\n";
		print $selDiscs;
	}

	boltRestoreHierarchy;
	
	print ("TIME TAKEN: " + `timerX -startTime $startTime` + "\n");
	
	print "MUD COLOURS DONE!\n";

}



global proc boltMudPainterGUI()
{
	if (`window -exists boltMudPainterWindow`) {deleteUI boltMudPainterWindow;} 
	//delete the window if it already exists
	
	window -title "Mud Painter" -toolbox 1 boltMudPainterWindow;
		//scrollLayout;
	    	columnLayout;
	    		
	    		text -label "- Vehicle should have ambient occlusion, and a"; 
	    		text -label "completed hierarchy before mudding";
	    		text -label "- After running this script you will need to"; 
	    		text -label "manualy turn off mud on some parts using";
	    		text -label "the controls below - eg inside of doors and boot,";
	    		text -label "light reflectors, exhaust holes and roll cage.";
	    						 
	    						 
	    		separator -style "in" -horizontal 1 -height 10 -width 250;
	    		 
	    		text -font "boldLabelFont" -label "  Mud Layers:  "; 
	    		   		
	    		rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Base Mud:";
	    			floatField -precision 2 -value 0.07 -ann "opacity of solid base coat of mud (ie minimum mud amount)" boltMudBase;
	    		setParent ..;	
	    		rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Height Mud:";
	    			floatField -precision 2 -value 0 -ann "opacity of height layer - more mud closer to ground" boltMudHeight;
	    		setParent ..;	
	    		rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Down and Back Normal Bias:";
	    			floatField -precision 2 -value 0.2 -ann "opacity of normal bias layer - more mud on polys facing downwards and backwards" boltMudNormal;
	    		setParent ..;
	    		rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Top Normal Bias:";
	    			floatField -precision 2 -value 0.6 -ann "opacity of normal bias layer - more mud on polys facing upwards" boltMudTopNormal;
	    		setParent ..;
				rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Crevice Mud:";
	    			floatField -precision 2 -value 0.1 -ann "opacity of crevice layer - paints mud into crevices using ambient occlusion data from model" boltMudCrevice;
	    		setParent ..;
	    		rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Wheel Spray:";
	    			floatField -precision 2 -value 0.12 -ann "opacity of wheel spray layer - sprays a cone of mud back from each wheel on the model" boltMudWheel;
	    		setParent ..;
	    		rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Wheel Mud Level:";
	    			floatField -precision 2 -value 0.4 -ann "Max mud level for wheels" boltWheelMudLevel;
	    		setParent ..;
	    		
	    		separator -style "in" -horizontal 1 -height 10 -width 250;
	    		
				rowLayout -numberOfColumns 2 -cw 1 150 -cw 2 100;
	    			text -label "Interior mud amount:";
	    			floatField -precision 2 -value 0 -ann "Amount of mud on interior - 0 for no mud, up to 1 for full mud" boltMudInterior;
	    		setParent ..;
	    		
	    		separator -style "in" -horizontal 1 -height 10 -width 250;   
	  	  
	    		checkBox -label "Auto Un-Mud Exhaust Hole"  -value 1 boltCheckBoxExhaustMud;
				//checkBox -label "Set Brake light glows to 50% mud"  -value 0 boltCheckBoxBrakeMud;
				checkBox -label "Un-Mud Light Reflectors"   -value 1 boltCheckBoxLightMud;
		  		checkBox -label "Wipe windscreen" -value 1 boltCheckBoxWipeWindscreen;
		  		checkBox -label "Delete history" -value 1 -ann "Can massively speed up mud painting in some cases" boltCheckBoxDeleteHistoryMud;
		  		
	    		separator -style "in" -horizontal 1 -height 10 -width 250;
	    			    		
	    		button -height 20 -width 200 -label "Paint Mud" -command "boltDoMud" -ann "Paints mud into the vehicle's red vertex channel using above settings. Paints selected objects, or all objects if no selection." boltButtonMud;
	    		
	    		separator -style "in" -horizontal 1 -height 10 -width 250;
	    		
	    		text -label "Set selected vertex mud colours:";
	    		button -height 20 -width 100   -label "Off"    -ann "Set vertex colours to no mud"      												-command "boltMudVerts 0" 		boltMud0ff;
				button -height 20 -width 100   -label "Med"    -ann "Set vertex colours to medium mud"  												-command "boltMudVerts 0.5" 	boltMudMid;
				button -height 20 -width 100  -label "Full"   -ann "Set vertex colours to full mud"   												-command "boltMudVerts 1" 		boltMudFull;
				
	    		
	    		//separator -style "in" -horizontal 1 -height 10 -width 250;
	    		
	    		
	    		//button -height 20 -width 200   -label "Set mud and damage scales"    -ann "Sets mud and damage scales on all shaders to be at the same relative scale as bodypaint_LV01" 	-command "boltSetShaderScales \"bodypaint_LV01\"" 		boltButtonMudScale;
				    		
			setParent ..;					
		//setParent ..;
	setParent ..;   
                 		                             
	showWindow boltMudPainterWindow;
	//display the window
	
}

global proc boltDoMud()
//sends values from gui to main proc 
{
	print "\nPainting Mud...";
			
	float $flatOp = 				`floatField -q -value boltMudBase`;	
	float $groundProximityOp = 		`floatField -q -value boltMudHeight`; 		
	float $normalBiasOp = 			`floatField -q -value boltMudNormal`;
	float $topNormalBiasOp = 		`floatField -q -value boltMudTopNormal`;	
	float $creviceOp = 				`floatField -q -value boltMudCrevice`;	
	float $wheelEmitOp = 			`floatField -q -value boltMudWheel`;
	float $interiorOp =				`floatField -q -value boltMudInterior`;
	int $exhaustMud = 				`checkBox -q -value boltCheckBoxExhaustMud`; 
	int $brakeMud =					0; //`checkBox -q -value boltCheckBoxBrakeMud`;   
	int $lightMud =					`checkBox -q -value boltCheckBoxLightMud`;
	int $wipeWindscreen = 			`checkBox -q -value boltCheckBoxWipeWindscreen`;
	int $delHistory = 				`checkBox -q -value boltCheckBoxDeleteHistoryMud`;
	float $wheelMudLevel = 			`floatField -q -value boltWheelMudLevel`;
	
	
	boltMudPainter $flatOp $groundProximityOp $normalBiasOp $creviceOp $wheelEmitOp $interiorOp $exhaustMud $brakeMud $lightMud $topNormalBiasOp $wipeWindscreen $delHistory $wheelMudLevel;

}

global proc float[] boltGetWorldSpaceVector(string $vtxFace)
//returns the world space vector of a vertex face
//won't work if there is a non-uniform scale on the object
{
	string $obj = `match "^[^\.]*" $vtxFace`;
	
	if (`nodeType $obj` != "transform")
	{
		string $parents[] = `listRelatives -parent $obj`;
		$obj = $parents[0];
	}
	//get the obj name
	
	float $vfNormal[] = `polyNormalPerVertex -q -xyz $vtxFace`;
	float $objMatrix[] = `xform -q -m $obj`;
	//get the object space normal and the object transform
	
	float $worldSpaceVector[] = pointMatrixMult($vfNormal, $objMatrix);
	//
	
	return $worldSpaceVector;
}











proc int GetNbMeshVerts(string $obj)
{
	if (`nodeType $obj` == "transform")
	{
		string $objs[] = `boltTransformsToShapes {$obj}`;
		$obj = $objs[0];
	}
	if (`objExists $obj`)
	{	
		int $vertCounts[] = `polyEvaluate -v $obj`;
		return $vertCounts[0];
	}
	return 0;
}

global proc float boltPaintDam.GetVertDistFromMesh(string $vert, string $occ)
{
	string $pmm1 = ($occ + "_PMM1");
	string $pmm2 = ($occ + "_PMM2");
	
	vector $inPos = `pointPosition -w $vert`;
	setAttr ($pmm1 + ".inPoint") ($inPos.x) ($inPos.y) ($inPos.z);
	vector $outPos = `getAttr ($pmm2 + ".output")`;

	return mag($outPos - $inPos);
}


global proc boltDoDamageUVs(float $crumpleFade, float $safetyFade, float $occFade)
//paints colours into the damage UVs, based on crumple and safety zones, and the above fall offs.
//now modified to paint into the green channel instead + delete old UVs
{
	int $debug = 0;
	
	if ($debug==1) confirmDialog -message "Getting object lists...";
	string $locs[] = boltShapesToTransforms(`ls -long -exactType "locator"`); 
	string $defs[] = boltShapesToTransforms(`ls -long -type "lattice"`);
	string $shad[] = boltShapesToTransforms(`ls -long -type "evoamboccvollocator"`);
	string $temp[]	  = `ls -long -type "transform" "*_TEMP"`;     
	string $RDcols[]  = `ls -long -type "transform" "RAGDOLL_*_COL"`;       
	string $cols[]    = `ls -long -type "transform" "*_COL"`; 
	string $cons[]    = `ls -long -type "aimConstraint"`;  
	$cols = `stringArrayRemove $RDcols $cols`;
	string $boostShapes[]    = `ls -long -type "transform" "BOOST_*"`; 
	string $refs[] = `ls -long "*:WHEEL*"`;
	//get misc lists
	
	string $crumpleZones[] = `ls -long -type "transform" "CRUMPLEZONE_*"`;
	string $safetyZones[] = `ls -long -type "transform" "SAFETYZONE_*"`;
	string $occluders[] = `ls -type "transform" "*_OCC"`;
	//get lists of damage safety/crumple zone boxes.
		
	string $noDamage[] = {};
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "DAMPER_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "CALIPER_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "HANDLE_BARS*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "STEERING*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "SPRING_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "WISHBONE_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "HUB_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "DRIVESHAFT_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "DISC_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "WHEEL_F*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "WHEEL_B*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "TIEROD_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "TRAILING_ARM_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "AXLE_*"`);
	$noDamage = stringArrayCatenate($noDamage,`ls -long -type "transform" "EXHAUST*"`);
	$noDamage = `stringArrayRemove $locs $noDamage`; 
	$noDamage = `stringArrayRemove $cons $noDamage`;      
   	//get list of objects with zero damage
   
   
   	
	string $objList[] = boltShapesToTransforms(`ls -long -geometry`);
	
	string $selected[] = `ls -sl -long`;
	if (size($selected)>0) 
	{
		$objList = $selected;
	}
	//if objs are selected, use those instead
	else
	{
		string $confirm = `confirmDialog -title "WARNING" 
			-message "No objects selected! Do you want to redo damage on all objects in scene?" 
			-button "Yes" -button "No" 
			-defaultButton "No" -cancelButton "No" -dismissString "No"`;
		if ($confirm == "No") $objList = {};
	}
	//warn user before damaging everything
	
	$objList = `stringArrayRemoveDuplicates $objList`;
	$objList = `stringArrayRemove $refs     $objList`;
	$objList = `stringArrayRemove $temp     $objList`;
	$objList = `stringArrayRemove $defs     $objList`;  
	$objList = `stringArrayRemove $RDcols   $objList`;
	$objList = `stringArrayRemove $cols     $objList`;
	$objList = `stringArrayRemove $locs     $objList`;
	$objList = `stringArrayRemove $shad     $objList`;
	$objList = `stringArrayRemove $crumpleZones     $objList`;
	$objList = `stringArrayRemove $safetyZones     $objList`;
	$objList = `stringArrayRemove $boostShapes     $objList`;
	
	
	string $newNoDamage[] = {};
	for ($obj in $noDamage)
	{
		if (`sFindItem $objList $obj`!=-1) $newNoDamage[size($newNoDamage)] = $obj;
		//get a list of the selected noDamage objects
	} 
	
	print $objList;
	//print $newNoDamage;
	
	$objList = `stringArrayRemove $noDamage $objList`;
	$noDamage = $newNoDamage;
	//work out list of damagable shapes
	
	//$objList = {"BONNET"};
	//$noDamage = {"WHEEL_FL"};
	//debug
	
	
	$allObjs = stringArrayCatenate($objList,$noDamage);
	//combined list of all objects
	
	for ($obj in $crumpleZones) showHidden $obj;
	for ($obj in $safetyZones) showHidden $obj;
	for ($obj in $occluders) showHidden $obj;
	//doesn't work unless these are visible for some reason?
	
	if ($debug==1) confirmDialog -message "Deleting Exisitng UV set...";	
	for ($obj in $allObjs)
	{
		//delete -ch $obj;
		string $UVSets[] = `polyUVSet -q -allUVSets $obj`;
		for ($set in $UVSets)
		{
			if ($set == "damageWeightUVs") polyUVSet -delete -uvSet "damageWeightUVs" $obj;
		}
	}
	//delete existing damageweight UVs
	
	//setup cpom nodes in occluders
	for ($occ in $occluders)
	{
		boltPaintDam.GetVertDistFromMeshSetup($occ);
	}
	
	
	
	
	undoInfo -state off;
	//turn off otherwise maya runs out of memory.
		
	for ($obj in $objList)
	{		
		print ("\nCalculating Damage For Object: " + $obj);
		
		//if ($debug==1) confirmDialog -message $obj;
		
		int $noVerts = GetNbMeshVerts($obj);
		for($k=0 ; $k < $noVerts; $k++)
		{
			string $vert = ($obj+".vtx["+$k+"]");
			//go through each vertex
		
			float $colour = 0.5;
			//set to grey
		
			for ($box in $crumpleZones)
			{
				float $dist = `boltDistanceFromBox $vert $box`;
				if ($dist < $crumpleFade)
				{
					float $tempCol = (($crumpleFade - $dist)/($crumpleFade*2))+0.5;
					if ($tempCol > $colour) $colour = $tempCol;
					//only change if brightening existing colour
				}
			}
			for ($box in $safetyZones)
			{
				float $dist = `boltDistanceFromBox $vert $box`;
				if ($dist < $safetyFade)
				{
					float $tempCol = $dist/($safetyFade*2);
					if ($tempCol < $colour) $colour = $tempCol;
					//only change if darkening existing colour
					
				}
			}
			//work out colour if in or close to crumple zone / safety zone
		
			//calculate occluder damage protection
			for ($occ in $occluders)
			{
				//is the vert near to the occluder?
				if (boltPaintDam.IsNearOcc($vert, $occ, $occFade))
				{
					float $dist = boltPaintDam.GetVertDistFromMesh($vert, $occ);
					
					if ($dist < $occFade)
					{
						float $tempCol = ($dist/$occFade*2); //gives nums from 0 to 0.5
						$tempCol = ($tempCol*2)-0.5; //scale and bias for more black area
						if ($tempCol < 0) $tempCol = 0; //clamp
						if ($tempCol < $colour) $colour = $tempCol; //only change if darkening existing colour
					}
				}
			}
			
			
			string $vfs[] = `polyListComponentConversion -fv -tvf $vert`;
			polyColorPerVertex -g $colour $vfs;
			//assign colour
			//conversion to vfs needed to avoid alpha being screwed up.
			
		}
		refresh -force;
	}
		
	for ($obj in $noDamage)
	{
		//if ($debug==1) confirmDialog -message $obj;
		float $colour = 0.0;
		polyColorPerVertex -g $colour $obj;
		print ($obj + " damage colours set to no damage\n");
		refresh -force;
	}


	undoInfo -state on;
	
	//delete cpom nodes in occluders
	for ($occ in $occluders)
	{
		boltPaintDam.GetVertDistFromMeshCleanup($occ);
	}
	
	for ($obj in $crumpleZones) hide $obj;
	for ($obj in $safetyZones) hide $obj;
	for ($obj in $occluders) hide $obj;
	//rehide these
	
	
		
	polyUVSet -currentUVSet -uvSet "map1" $allObjs;
	//set back to map1 UVs
	print "\nDAMAGE COLOURS DONE!";

}

global proc boltPaintDam.GetVertDistFromMeshSetup(string $occ)
//adds the necessary cpom nodes for the boltPaintDam.GetVertDistFromMesh 
{
	//get the mesh node
	string $occShapes[] = `listRelatives -children -type "mesh" $occ`;
	string $occShape = $occShapes[0];
	
	//ensure clean start
	boltPaintDam.GetVertDistFromMeshCleanup($occ);
	
	//create the cpom nodes
	string $cpomNode = ($occ + "_CPOM");
	string $pmm1 = ($occ + "_PMM1");
	string $pmm2 = ($occ + "_PMM2");
	createNode "closestPointOnMesh" -name $cpomNode;
	createNode "pointMatrixMult" -name $pmm1;
	createNode "pointMatrixMult" -name $pmm2;
		
	//make connections
	connectAttr -f ($occShape + ".worldInverseMatrix") ($pmm1 + ".inMatrix");
	connectAttr -f ($pmm1 + ".output") ($cpomNode + ".inPosition");
	connectAttr -f ($cpomNode + ".position") ($pmm2 + ".inPoint");
	connectAttr -f ($occShape + ".worldMatrix") ($pmm2 + ".inMatrix");
	connectAttr -f ($occShape + ".outMesh")($cpomNode + ".inMesh");
}

global proc boltPaintDam.GetVertDistFromMeshCleanup(string $occ)
//deletes the cpom nodes
{
	string $cpomNode = ($occ + "_CPOM");
	string $pmm1 = ($occ + "_PMM1");
	string $pmm2 = ($occ + "_PMM2");
	
	if (objExists($cpomNode)) delete $cpomNode;
	if (objExists($pmm1)) delete $pmm1;
	if (objExists($pmm2)) delete $pmm2;
	
}

global proc float boltPaintDam.GetVertDistFromMesh(string $vert, string $occ)
{
	string $pmm1 = ($occ + "_PMM1");
	string $pmm2 = ($occ + "_PMM2");
	
	vector $inPos = `pointPosition -w $vert`;
	setAttr ($pmm1 + ".inPoint") ($inPos.x) ($inPos.y) ($inPos.z);
	vector $outPos = `getAttr ($pmm2 + ".output")`;

	return mag($outPos - $inPos);
}

global proc int boltPaintDam.IsNearOcc(string $vert, string $occ, float $occFade)
//return 1 if $vert is within $occFade distance of $occ bounding box.
{
	vector $pos = `pointPosition -w $vert`;
	float $bb[] = `xform -q -worldSpace -boundingBox $occ`;
	//xmin ymin zmin xmax ymax zmax
	
	//tests ordered for best speed
	if ($pos.z < ($bb[2]-$occFade)) return 0;
	if ($pos.z > ($bb[5]+$occFade)) return 0;
	if ($pos.x < ($bb[0]-$occFade)) return 0;
	if ($pos.x > ($bb[3]+$occFade)) return 0;
	if ($pos.y < ($bb[1]-$occFade)) return 0;
	if ($pos.y > ($bb[4]+$occFade)) return 0;
	
	return 1;
}

global proc float boltDistanceFromBox(string $vert, string $box)
//returns the distance squared of a point from a box.
//(uses bounding box of box, so axis must be aligned correctly to the box)
{
	float $bnd[] = `xform -q -worldSpace -boundingBox $box`;
	float $pos[] = `pointPosition -w $vert`;
	float $dis[] = {};
	//stores x y z dist from box
	
	for ($i = 0; $i < 3; $i++) 
	{
		if (($pos[$i]>$bnd[$i]) && ($pos[$i]<$bnd[$i+3])) $dis[$i] = 0;
		//point is within bounds
		if ($pos[$i]<$bnd[$i]) $dis[$i] = $bnd[$i]-$pos[$i];
		//point is below bounds
		if ($pos[$i]>$bnd[$i+3]) $dis[$i] = $pos[$i]-$bnd[$i+3];
		//point is above bounds
	}
	//work out distance from the box in XYZ axis
	
	//print $bnd;
	//print $dis; 
	//print  "\n";
	
	float $distSquared = $dis[0]*$dis[0] + $dis[1]*$dis[1] + $dis[2]*$dis[2];
	
	return $distSquared;
}



global proc boltHealVertexAlpha()
//repairs vertex colours of selected verts, based on surroundings
{
	string $verts[] = `ls -sl`;
	for ($v in $verts)
	{
	    if (`gmatch $v "*.vtx\\[*"` == 0) continue; //skip if not a vert
	    
	    float $col = boltGetAverageVertexAlphaOfVert($v);
	    float $avgSurroundingColour = 0;
	    //if ($col <= 0.02)
	    {
	        //work out average surrounding colour
	        string $surroundingEdges[] = boltNorms.ToEdges({$v});
	        string $surroundingVerts[] = boltNorms.ToVerts($surroundingEdges);
	        $surroundingVerts = stringArrayRemove($verts,$surroundingVerts);
	        
	        float $colourCount = 0;
	        for ($sv in $surroundingVerts)
	        {
	            float $sCol = boltGetAverageVertexAlphaOfVert($sv);
	            $avgSurroundingColour += $sCol;
	            $colourCount += 1;
	        }
	        if ($colourCount > 0)
	        {
	           $avgSurroundingColour = $avgSurroundingColour / $colourCount;
	        }
	       
	    }
	    if ($avgSurroundingColour > 0)
	    {
	        polyColorPerVertex -e -a $avgSurroundingColour $v;
	    } 
	}
}


global proc boltHealDamageVector()
//repairs damage vectors colours of selected verts, based on surroundings
{
	string $verts[] = `ls -sl`;
	
	polyColorSet -currentColorSet -colorSet "damageVector_colorSet";
	
	for ($v in $verts)
	{
	    if (`gmatch $v "*.vtx\\[*"` == 0) continue; //skip if not a vert
	    
	    float $col[] = boltGetAverageVertexColourOfVert($v);
	    float $avgSurroundingColour[] = {0,0,0};
	    //if ($col <= 0.02)
	    {
	        //work out average surrounding colour
	        string $surroundingEdges[] = boltNorms.ToEdges({$v});
	        string $surroundingVerts[] = boltNorms.ToVerts($surroundingEdges);
	        $surroundingVerts = stringArrayRemove($verts,$surroundingVerts);
	        
	        float $colourCount = 0;
	        for ($sv in $surroundingVerts)
	        {
	            float $sCol[] = boltGetAverageVertexColourOfVert($sv);
	            $avgSurroundingColour[0] = $avgSurroundingColour[0] + $sCol[0];
	            $avgSurroundingColour[1] = $avgSurroundingColour[1] + $sCol[1];
	            $avgSurroundingColour[2] = $avgSurroundingColour[2] + $sCol[2];
	            $colourCount += 1;
	        }
	        if ($colourCount > 0)
	        {
	        	$avgSurroundingColour[0] = $avgSurroundingColour[0] / $colourCount;
	            $avgSurroundingColour[1] = $avgSurroundingColour[1] / $colourCount;
	            $avgSurroundingColour[2] = $avgSurroundingColour[2] / $colourCount;
	        }
	       
	    }
	    if ( ($avgSurroundingColour[0] + $avgSurroundingColour[1] +$avgSurroundingColour[2]) > 0.00001)
	    {
	        polyColorPerVertex -e -r $avgSurroundingColour[0] -g $avgSurroundingColour[1] -b $avgSurroundingColour[2] $v;
	    } 
	}
	polyColorSet -currentColorSet -colorSet "colorSet1";
}






global proc boltDamageVectorCopy()
//copies the average colour of verts to a global
{
	global float $gBoltDamageVectorColour[];
	$gBoltDamageVectorColour = {0,0,0};
	
	string $verts[] = `ls -sl`;
	
	polyColorSet -currentColorSet -colorSet "damageVector_colorSet";
	
	float $avgCol[] = {0,0,0};
	int $count = 0;
	for ($v in $verts)
	{
	    if (`gmatch $v "*.vtx\\[*"` == 0) continue; //skip if not a vert
	    
	    float $col[] = boltGetAverageVertexColourOfVert($v);
	    
	    $avgCol[0] = $avgCol[0] + $col[0];
	    $avgCol[1] = $avgCol[1] + $col[1];
	    $avgCol[2] = $avgCol[2] + $col[2];
	    
	    $count++;
	}
	if ($count > 0)
	{
		$avgCol[0] = $avgCol[0] / $count;
		$avgCol[1] = $avgCol[1] / $count;
		$avgCol[2] = $avgCol[2] / $count;
	}
	
	$gBoltDamageVectorColour = $avgCol;
	
	polyColorSet -currentColorSet -colorSet "colorSet1";
}

global proc boltDamageVectorPaste()
//pastes copied vert colour from global to selected verts
{
	global float $gBoltDamageVectorColour[];
		
	string $verts[] = `ls -sl`;
	
	polyColorSet -currentColorSet -colorSet "damageVector_colorSet";
	
	for ($v in $verts)
	{
		if (`gmatch $v "*.vtx\\[*"` == 0) continue; //skip if not a vert
		
		polyColorPerVertex -e -r $gBoltDamageVectorColour[0] -g $gBoltDamageVectorColour[1] -b $gBoltDamageVectorColour[2] $v;
	}
	
	polyColorSet -currentColorSet -colorSet "colorSet1";
}






global proc boltSmoothVertexAlpha()
//smooths vertex colours of selected verts, removing any hard edges
{
	string $verts[] = `ls -sl`;
	for ($v in $verts)
	{
	    if (`gmatch $v "*.vtx\\[*"` == 0) continue; //skip if not a vert
	    
	    float $col = boltGetAverageVertexAlphaOfVert($v);
	    polyColorPerVertex -e -a $col $v;
	     
	}
}




global proc float boltGetAverageVertexAlphaOfVert(string $v)
//returns the single average vertex colour of the given vert
{
    float $cols[] = `polyColorPerVertex -q -a $v`;
    float $count = 0;
    float $avg = 0;
    for ($c in $cols)
    {
       $avg += $c;
       $count += 1; 
    }
    return ($avg/$count);
}

global proc float[] boltGetAverageVertexColourOfVert(string $v)
//returns the single average vertex colour of the given vert
{
    float $rs[] = `polyColorPerVertex -q -r $v`;
    float $gs[] = `polyColorPerVertex -q -g $v`;
    float $bs[] = `polyColorPerVertex -q -b $v`;
    
    float $avgr = 0;
    float $avgg = 0;
    float $avgb = 0;
    
    for ($r in $rs) $avgr += $r;
    for ($g in $gs) $avgg += $g;
    for ($b in $bs) $avgb += $b;
	
	$s = size($rs);
	float $avg[] = {$avgr/$s , $avgg/$s, $avgb/$s};

    return $avg;
}




global proc boltFixLightShaderMirrorFlags()
{
	global string $gBoltWarnings;
	global string $gBoltWarningsLow;
	
	string $lightShaders[] = {"light_shader_standard.xml","light_shader_under_colour.xml","light_shader_standard_damage.xml"};
	string $shaders[] = `ls -type "ATGMaterial"`;
	
	for ($shader in $shaders)
	{
		string $xmlpath = boltGetShaderPreset($shader);
		string $xml = basename( $xmlpath, "" );
		
		for ($lightShader in $lightShaders)
		{
			//light shader found
			if ($xml == $lightShader)
			{
				
				string $sgs[] = getSGFromMaterial($shader);
				
				if (size($sgs)==0) continue;
				
				string $shadedPolys[] = `sets -q $sgs[0]`;
				$shadedPolys = boltNorms.ToFaces($shadedPolys);
				
				for ($poly in $shadedPolys)
				{
					//get light type - returns [index, glowtype, mirror, plusone, constType] 
					int $lightType[] = boltGetLightTypeSCV($poly);
					
					//check for gradient
					if ($lightType[0] == -1)
					{
						$msg = ("\nError - Could not fix mirroring on " + $poly + " - it has a gradient of light types across its vertex colours - Should be a constant value per polygon");
						print $msg;
					}
					else
					{
						//check mirroring
						int $mirroredUVs = (boltReturnUVWinding2(boltGetVertexOrder($poly)) == 1);
						if ($lightType[2] != $mirroredUVs)
						{
							//Light type format: {$index, $glowType, $mirror, $plusOne, $constType};
							$lightType[2] = $mirroredUVs;
							select -r $poly;
							
							//boltPaintLightType(int $glowType, int $constType, int $mirror, int $plusone)
							boltPaintLightType($lightType[1], $lightType[4], $lightType[2], $lightType[3]);
						}
					}
				}
			}
		}
	}
}






global proc boltPaintDam.GetClosestOnMeshSetup(string $obj)
//adds the necessary cpom node to $obj
{
	//get the mesh node
	string $shapes[] = `listRelatives -children -type "mesh" $obj`;
	string $shape = $shapes[0];
	
	string $cpomNode = ($obj + "_CPOM");
	
	//ensure clean start
	if (`objExists $cpomNode`) delete $cpomNode;
	
	//create the cpom node
	createNode "closestPointOnMesh" -name $cpomNode;
	connectAttr -f ($shape + ".outMesh") ( $cpomNode + ".inMesh");
	connectAttr -f ($obj + ".worldMatrix") ( $cpomNode + ".inputMatrix");
}

global proc boltPaintDam.GetClosestOnMeshCleanup(string $obj)
//adds the necessary cpom node to $obj
{
	//ensure clean start
	string $cpomNode = ($obj + "_CPOM");
	if (`objExists $cpomNode`) delete $cpomNode;
}


global proc int boltPaintDam.GetClosestOnMesh(string $obj, string $vert)
//deletes the cpom nodes
{
	string $cpomNode = ($obj + "_CPOM");
	vector $inPos = `pointPosition -w $vert`;
	
	setAttr ($cpomNode + ".inPositionX") ($inPos.x);
	setAttr ($cpomNode + ".inPositionY") ($inPos.y);
	setAttr ($cpomNode + ".inPositionZ") ($inPos.z);
	
	return getAttr ( $cpomNode + ".closestVertexIndex");
}
