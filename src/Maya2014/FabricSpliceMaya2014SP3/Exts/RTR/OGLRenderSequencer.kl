//
// Copyright 2010-2014 Fabric Software Inc. All rights reserved.
//

require Math;

const Integer DefineBinding = 0;
const Integer StoredBinding = 1;
const Integer FeedbackBinding = 2;
const Integer RequestBinding = 3;

const Integer FlagOpsBits_or = 1;
const Integer FlagOpsBits_and = 2;
const Integer FlagOpsBits_not = 4;

const Integer ImplicitGeometryPrimitive_screenPlane = 1;
const Integer ImplicitGeometryPrimitive_negZAxisUnitCone = 2;
const Integer ImplicitGeometryPrimitive_unitSphere = 3;
const Integer numImplicitGeometryPrimitives = 4;

const Integer ImplicitGeomType_none = 0;
const Integer ImplicitGeomType_viewportPlane = 1;
const Integer ImplicitGeomType_boundingVolume = 2;

struct PrimitiveData {
  //Source data ref
  Integer ownerType;//OwnerType_...
  RenderParams params;

  Size numInstances;
  Size firstInstanceIndex;
  Size primPerTypeIndex;
  Size lastParamsVersion;//Used in UpdateInstance
  Size lastParamsTopoVersion;//Used in UpdateInstance

  RenderParamVersionedKey localBVolVersionKey;//Versioned at instance level
  RenderParamVersionedKey transformVersionKey;//Versioned at instance level

  Boolean used;//false -> deleted
  Size renderDataGenerationCount;
  Size opNextPrimitiveDataIndex;//Linked list (from indices): next = 0
};

struct InstanceData {
  Size primIndex;
  Size primInstanceIndex;
  Size instancePerTypeIndex;
  RenderParamVersionedKey transformVersionKey;
  RenderParamVersionedKey localBVolVersionKey;

  Boolean used;//false -> deleted
  Size renderDataGenerationCount;
  Size primNextInstanceDataIndex;//Linked list (from indices): next = 0
};

struct CachedFlags {
  BitVector flags;
  UInt32 version;
};

inline CachedFlags.updateBit!( Size bitIndex, Boolean value ) {
  if( bitIndex < this.flags.size() ) {
    Boolean prevValue = this.flags.get(bitIndex);
    if( prevValue != value ) {
      this.flags.set(bitIndex, value);
      ++this.version;
    }
  } //Else: will be updated in updatePrimitivePerTypeFlagsCache
}

object RenderCaches : StatisticSourceWithAutoRegisterMember {
  Octree octreePerType[10];//10=numOwnerTypes
  Size gridTypesToUpdateBits;
  Boolean gridActive;
  Size gridNumCellUpdatesPerFrameBeforeDraw;
  Size gridCurrentFrameCellUpdateBudgetBeforeDraw;
  Size gridNumCellUpdatesPerFrameDuringDraw;

  OGLTextureCache oglTextureCache;

  CachedFlags primitiveFlagsPerType[10][String];//10=numOwnerTypes

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

function Size RenderCaches.getMemUsage() {
  //oglTextureCache + octreePerType are distinct statistic children
  Size mem;
  for( Size i = 0; i < 10; ++i ) {
    for( k, v in this.primitiveFlagsPerType[i] )
      mem += 4 + v.flags.memUsage();
  }
  return mem;
}

//Implementation of StatisticSource interface's 'getStatistics()'.
//We are mostly a container for statistic children
function StatisticRecord[] RenderCaches.getStatistics() {
  StatisticRecord stats[];
  stats.push( StatisticRecord( Statistic_Name, "RTRCaches" ) );
  stats.push( StatisticRecord( Statistic_Category, "RTR" ) );
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.getMemUsage() ) );
  return stats;
}

function RenderCaches() {
  this.oglTextureCache = OGLTextureCache();
  this.autoStats = StatisticsAutoRegisterMember(this);
  AddStatisticsChild(this.autoStats, this.oglTextureCache.autoStats);

  for( Size i = 0; i < this.octreePerType.size(); ++i ) {
    this.octreePerType[i] = Octree(_Oct_MAX_DEPTH, true, 1.0e-5);//Keep subcell childs: important since we are tuned for volume queries, not just raycasts
    AddStatisticsChild(this.autoStats, this.octreePerType[i].autoStats);
  }
}

struct ValueOrFunctionKeyDefinition {
  UInt32 functionID;//InvalidIndex if none
  String functionName;
  Boolean isValid;
  Boolean needsDebugContext;
  UInt32 bindingBits;
  UInt32 globalBindingBits;
  UInt32 parentBindingBits;
  UInt32 memberBindingBits;
  UInt32 initializingBindingBits;
  UInt32 isFlagBits;
  UInt32 transformBindingBits;//Optimization since transform is often used and is cached
  UInt32 localBoundingVolumeBindingBits;//Optimization since transform is often used and is cached
  RenderParamVersionedKey keys[];//Only static keys are synchronized, else on the name is set
  String paramNames[];
};

struct GroupFunctionKeys {
  ValueOrFunctionKeyDefinition flagKeys;
  ValueOrFunctionKeyDefinition conditionKeys;
  ValueOrFunctionKeyDefinition cullBoundingVolumeKeys;
  //TODO: add cull bounding volume, etc
};

struct ApplyFunctionKeys {
  ValueOrFunctionKeyDefinition conditionKeys;
  ValueOrFunctionKeyDefinition renderTargetWidthKeys[];
  ValueOrFunctionKeyDefinition renderTargetHeightKeys[];
  ValueOrFunctionKeyDefinition renderTargetDepthKeys[];
  ValueOrFunctionKeyDefinition renderTargetClearColorKeys[];
  ValueOrFunctionKeyDefinition renderTargetClearDepthKeys[];
  ValueOrFunctionKeyDefinition renderTargetSourceKeys[];
  ValueOrFunctionKeyDefinition refineRenderTargetClearColorKeys[];
  ValueOrFunctionKeyDefinition refineRenderTargetClearDepthKeys[];
  ValueOrFunctionKeyDefinition bindingKeys[];
  ValueOrFunctionKeyDefinition drawCallbackKeys[];
  ValueOrFunctionKeyDefinition updateIntervalKeys;
  ValueOrFunctionKeyDefinition cullFaceKeys;
  //TODO: add various params... + texture definition ones
};

struct PassFunctionKeys {
  GroupFunctionKeys groupKeys[];
  ApplyFunctionKeys applyKeys[];
};

struct SourceOpInfo {
  UInt32 firstPrimIndex;
  UInt32 numSourceSlices;
};

//RenderDataDefaultValues: mostly used as a node for statistics clarity
object RenderDataDefaultValues : StatisticSourceWithAutoRegisterMember {

  RenderParams screenPlaneImplicitGeomParams;
  RenderParams coneImplicitGeomParams;
  RenderParams sphereImplicitGeomParams;

  OGLTexture2D defaultTexture;
  OGLTexture2D randomTexture;

  OGLTexture2D noTexture;
  OGLBuffer noBuffer;

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

function StatisticRecord[] RenderDataDefaultValues.getStatistics() {
  StatisticRecord stats[];
  stats.push( StatisticRecord( Statistic_Name, "RenderDataDefaultValues" ) );
  stats.push( StatisticRecord( Statistic_Category, "RTR" ) );
  return stats;
}

struct RenderDataStruct {
  Boolean initialized;

  PrimitiveData primitives[];
  UInt32 primitivesListVersionPerType[10];//10=numOwnerTypes
  IndexPool primitivesIndexPool;

  InstanceData instances[];
  IndexPool instancesIndexPool;

  OGLRenderPass passes[];
  PassFunctionKeys passFunctionKeys[];

  RenderCaches renderCaches;

  RenderParams staticParams;
  RenderParamVersionedKey staticTrueKey;
  RenderParamVersionedKey staticFalseKey;

  Vec3 worldGeometryBBoxIncrement;
  OGLShaderLibrary shaderRenderParamLibrary;

  SourceOpInfo sourceOpInfos[];
  UInt32 dataLayoutGenerationCount;
  UInt32 generationCount;

  UInt32 instanceIndicesPerType[10][];//10=numOwnerTypes
  UInt32 primitiveIndicesPerType[10][];//10=numOwnerTypes
  IndexPool primitiveIndicesPerTypeIndexPool[10];//10=numOwnerTypes
  UInt32 globalTransformAndLocalBVolVersionPerType[10];//10=numOwnerTypes

  //primitiveNameToIndex: not all primitive types are registered there; not geometry instances...
  UInt32 primitiveNameToIndex[10][String];//10=numOwnerTypes

  RenderDataDefaultValues defaultValues;

  //Here we build 'constant' Strings (play safe: I'm not sure if KL constant Strings convert to non-const Strings without mem alloc)
  String materialParamString;
  String shaderParamString;
  String transformParamString;
  String viewTransformParamString;
  String invViewTransformParamString;
  String projectionParamString;
  String invProjectionParamString;
  String localBVolParamString;
  String widthParamString;
  String heightParamString;
  String depthParamString;
  String defaultParamString;
  String geometryElementTypeString;
  String instanceCountString;
  String indicesString;
  String adjustedImplicitGeometryString;
  String textureWidthPostfixString;
  String textureHeightPostfixString;

  RenderParams tempParams;
};

//Wrap the struct in an object: be able to reference, without the overhead of "null" checks in guarded
object RenderData : StatisticSourceWithAutoRegisterMember {
  RenderDataStruct data;

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

function RenderData() {
  this.autoStats = StatisticsAutoRegisterMember(this);
}

function Size RenderDataStruct.getMemUsage() {
  //Rough approximation, hopefully KL will add mem usage built-in routines
  Size primitiveDataSize = 9*4 + 4*2 + 6*4;
  Size instanceDataSize = 6*4 + 4*2;

  Size mem =  this.primitives.size()*primitiveDataSize + this.primitivesIndexPool.getMemUsage()
            + this.instances.size()*instanceDataSize + this.instancesIndexPool.getMemUsage()
            + 100;

  for( Size i = 0; i < 10; ++i ) {
    mem += this.instanceIndicesPerType[i].size()*4;
    mem += this.primitiveIndicesPerType[i].size()*4;
    mem += this.primitiveIndicesPerTypeIndexPool[i].getMemUsage();
    mem += this.primitiveNameToIndex[i].size()*24;
  }
  return mem;
}

//Implementation of StatisticSource interface's 'getStatistics()'.
function StatisticRecord[] RenderData.getStatistics() {
  StatisticRecord stats[];
  stats.push( StatisticRecord( Statistic_Name, "RenderData" ) );
  stats.push( StatisticRecord( Statistic_Category, "RTR" ) );
  stats.push( StatisticRecord( "GeometryInstancesCount", this.data.instancesIndexPool.getNumUsed() ) );
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.data.getMemUsage() ) );
  return stats;
}

inline LocalBoundingVolume RenderDataStruct.getWorldGeometryBBox()  {
  Vec3 min, max;
  Ref<RenderCaches> caches = this.renderCaches;//Trick KL "const"
  caches.octreePerType[OwnerType_geometryInstance].GetWorldBBox(min, max);
  LocalBoundingVolume bboxVol;
  bboxVol.bBoxInit(min - this.worldGeometryBBoxIncrement, max - this.worldGeometryBBoxIncrement);
  return bboxVol;
}

function OGLTexture2D buildDefaultTexture() {
  OGLTexture2D defaultTexture = OGLTexture2D();
  defaultTexture.glTextureType = GL_TEXTURE_2D;
  defaultTexture.glInternalFormat = GL_RGBA8;
  defaultTexture.glFormat = GL_RGBA;
  defaultTexture.glType = GL_UNSIGNED_BYTE;
  defaultTexture.textureMinFilter = GL_NEAREST;
  defaultTexture.textureMagFilter = GL_NEAREST;
  defaultTexture.wrapS = GL_CLAMP_TO_EDGE;
  defaultTexture.wrapT = GL_CLAMP_TO_EDGE;
  RGBA textureData[];
  textureData.resize(4);
  textureData[0] = RGBA(255,0,0,255);
  textureData[1] = RGBA(0,255,0,255);
  textureData[2] = RGBA(0,0,255,255);
  textureData[3] = RGBA(255,255,0,255);
  defaultTexture.configure( 2, 2, textureData.data() );
  defaultTexture.name = "defaultTexture";
  glBindTexture(GL_TEXTURE_2D, 0);
  return defaultTexture;
}

function OGLTexture2D buildRandomTexture() {
  OGLTexture2D randomTexture = OGLTexture2D();
  randomTexture.glTextureType = GL_TEXTURE_2D;
  randomTexture.glInternalFormat = GL_RGBA16;
  randomTexture.glFormat = GL_RGBA;
  randomTexture.glType = GL_UNSIGNED_SHORT;
  randomTexture.textureMinFilter = GL_NEAREST;
  randomTexture.textureMagFilter = GL_NEAREST;
  randomTexture.wrapS = GL_REPEAT;
  randomTexture.wrapT = GL_REPEAT;
  UInt16 textureData[];
  Size size = 256;

  Size randomOffset = 0;

  textureData.resize(size*size*4);

  for(Size i = 0; i < size; ++i ) {
    for(Size j = 0; j < size; ++j )
      textureData[(i*size+j)*4] = UInt16( mathRandomScalar(0, randomOffset++)*65535.9999 );
    randomOffset += 13;//Random number generators hate powers of 2
  }

  for(Size i = 0; i < size; ++i ) {
    for(Size j = 0; j < size; ++j )
      textureData[(i*size+j)*4+1] = UInt16( mathRandomScalar(0, randomOffset++)*65535.9999 );
    randomOffset += 13;//Random number generators hate powers of 2
  }

  for(Size i = 0; i < size; ++i ) {
    for(Size j = 0; j < size; ++j )
      textureData[(i*size+j)*4+2] = UInt16( mathRandomScalar(0, randomOffset++)*65535.9999 );
    randomOffset += 13;//Random number generators hate powers of 2
  }

  for(Size i = 0; i < size; ++i ) {
    for(Size j = 0; j < size; ++j )
      textureData[(i*size+j)*4+3] = UInt16( mathRandomScalar(0, randomOffset++)*65535.9999 );
    randomOffset += 13;//Random number generators hate powers of 2
  }

  randomTexture.configure( size, size, textureData.data() );
  randomTexture.name = "randomTexture";
  glBindTexture(GL_TEXTURE_2D, 0);
  return randomTexture;
}

function RenderParams buildScreenPlaneImplicitGeom( Ref<StatisticSource> parent ) {
  Mat44 identityMat;

  RenderParams params;
  params.ensureLayerExists(0);
  RenderParamValues paramValues = params.layers[0].params;

  paramValues.ownerName = "screenPlane";
  paramValues.ownerType = OwnerType_implicitGeometry;
  RenderValueKey key = paramValues.setAsMat44("transform", 1, TransformSpace_viewProjection);
  paramValues.set(key, identityMat);
  key = paramValues.setAsInteger("geometryElementType");
  paramValues.set(key, Integer(GL_TRIANGLES));

  OGLBuffer buffer;
  key = paramValues.setAsOGLBuffer("positions", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 3;
  buffer.bufferType = GL_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_FLOAT;

  Vec3 p[4];
  p[0] = Vec3(-1.0, -1.0, -1.0);
  p[1] = Vec3(1.0, -1.0, -1.0);
  p[2] = Vec3(1.0, 1.0, -1.0);
  p[3] = Vec3(-1.0, 1.0, -1.0);
  buffer.genBuffer( p.data(), p.dataSize(), 4 );

  key = paramValues.setAsOGLBuffer("uvs0", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 2;
  buffer.bufferType = GL_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_FLOAT;

  Vec2 t[4];
  t[0] = Vec2(0.0, 0.0);
  t[1] = Vec2(1.0, 0.0);
  t[2] = Vec2(1.0, 1.0);
  t[3] = Vec2(0.0, 1.0);

  buffer.genBuffer( t.data(), t.dataSize(), 4 );

  key = paramValues.setAsOGLBuffer("indices", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 1;
  buffer.bufferType = GL_ELEMENT_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_UNSIGNED_INT;

  Integer idx[6];
  idx[0] = 0; idx[1] = 1; idx[2] = 2; idx[3] = 0; idx[4] = 2; idx[5] = 3;
  buffer.genBuffer( idx.data(), idx.dataSize(), 6 );

  return params;
}

function RenderParams buildConeImplicitGeom( Ref<StatisticSource> parent ) {
  Mat44 identityMat;

  RenderParams params;
  params.ensureLayerExists(0);
  RenderParamValues paramValues = params.layers[0].params;

  paramValues.ownerName = "boundingCone";
  paramValues.ownerType = OwnerType_implicitGeometry;
  RenderValueKey key = paramValues.setAsMat44("transform", 1, ImplicitGeometryPrimitive_negZAxisUnitCone);
  paramValues.set(key, identityMat);
  key = paramValues.setAsInteger("geometryElementType");
  paramValues.set(key, Integer(GL_TRIANGLES));

  OGLBuffer buffer;
  key = paramValues.setAsOGLBuffer("positions", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 3;
  buffer.bufferType = GL_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_FLOAT;

  //Note: make it a bit bigger than 1 unit to make sure it englobes properly a cylinder
  Vec3 p[9];
  //0.766: exact coord for bounding octagon would be 0.4142135; make it a bit bigger
  p[0] = Vec3(0.0, 0.0, 0.001);
  p[1] = Vec3(-0.415, 1.001, -1.001);
  p[2] = Vec3(-1.001, 0.415, -1.001);
  p[3] = Vec3(-1.001, -0.415, -1.001);
  p[4] = Vec3(-0.415, -1.001, -1.001);
  p[5] = Vec3(0.415, -1.001, -1.001);
  p[6] = Vec3(1.001, -0.415, -1.001);
  p[7] = Vec3(1.001, 0.415, -1.001);
  p[8] = Vec3(0.415, 1.001, -1.001);
  buffer.genBuffer( p.data(), p.dataSize(), 9 );

  key = paramValues.setAsOGLBuffer("indices", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 1;
  buffer.bufferType = GL_ELEMENT_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_UNSIGNED_INT;

  Integer idx[42];
  idx[0] = 0; idx[1] = 1; idx[2] = 2;
  idx[3] = 0; idx[4] = 2; idx[5] = 3;
  idx[6] = 0; idx[7] = 3; idx[8] = 4;
  idx[9] = 0; idx[10] = 4; idx[11] = 5;
  idx[12] = 0; idx[13] = 5; idx[14] = 6;
  idx[15] = 0; idx[16] = 6; idx[17] = 7;
  idx[18] = 0; idx[19] = 7; idx[20] = 8;
  idx[21] = 0; idx[22] = 8; idx[23] = 1;

  idx[24] = 1; idx[25] = 8; idx[26] = 7;
  idx[27] = 1; idx[28] = 7; idx[29] = 6;
  idx[30] = 1; idx[31] = 6; idx[32] = 5;
  idx[33] = 1; idx[34] = 5; idx[35] = 4;
  idx[36] = 1; idx[37] = 4; idx[38] = 3;
  idx[39] = 1; idx[40] = 3; idx[41] = 2;

  buffer.genBuffer( idx.data(), idx.dataSize(), 42 );

  return params;
}

function RenderParams buildSphereImplicitGeom( Ref<StatisticSource> parent ) {
  //Build a 20 face isocahedron.
  Mat44 identityMat;

  RenderParams params;
  params.ensureLayerExists(0);
  RenderParamValues paramValues = params.layers[0].params;

  paramValues.ownerName = "boundingSphere";
  paramValues.ownerType = OwnerType_implicitGeometry;
  RenderValueKey key = paramValues.setAsMat44("transform", 1, ImplicitGeometryPrimitive_negZAxisUnitCone);
  paramValues.set(key, identityMat);
  key = paramValues.setAsInteger("geometryElementType");
  paramValues.set(key, Integer(GL_TRIANGLES));

  OGLBuffer buffer;
  key = paramValues.setAsOGLBuffer("positions", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 3;
  buffer.bufferType = GL_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_FLOAT;

  //Note: make it a bit bigger than 1 unit to make sure it englobes properly a cylinder
  Vec3 p[12];
  //In theory this isocahedron can inscribe a unit sphere (based on info on wiki) + added about 1% to compensate for numerical precision errors
  p[0] = Vec3(0, -0.665, 1.075);
  p[1] = Vec3(1.075, 0, 0.665);
  p[2] = Vec3(1.075, 0, -0.665);
  p[3] = Vec3(-1.075, 0, -0.665);
  p[4] = Vec3(-1.075, 0, 0.665);
  p[5] = Vec3(-0.665, 1.075, 0);
  p[6] = Vec3(0.665, 1.075, 0);
  p[7] = Vec3(0.665, -1.075, 0);
  p[8] = Vec3(-0.665, -1.075, 0);
  p[9] = Vec3(0, -0.665, -1.075);
  p[10] = Vec3(0, 0.665, -1.075);
  p[11] = Vec3(0, 0.665, 1.075);

  buffer.genBuffer( p.data(), p.dataSize(), 12 );

  key = paramValues.setAsOGLBuffer("indices", buffer);
  AddStatisticsChild(parent, buffer.autoStats);

  buffer.numBufferElementComponents = 1;
  buffer.bufferType = GL_ELEMENT_ARRAY_BUFFER;
  buffer.bufferUsage = GL_STATIC_DRAW;
  buffer.bufferElementComponentType = GL_UNSIGNED_INT;

  Integer idx[60];
  idx[0] = 1; idx[1] = 2; idx[2] = 6;
  idx[3] = 1; idx[4] = 7; idx[5] = 2;
  idx[6] = 3; idx[7] = 4; idx[8] = 5;
  idx[9] = 4; idx[10] = 3; idx[11] = 8;
  idx[12] = 6; idx[13] = 5; idx[14] = 11;
  idx[15] = 5; idx[16] = 6; idx[17] = 10;
  idx[18] = 9; idx[19] = 10; idx[20] = 2;
  idx[21] = 10; idx[22] = 9; idx[23] = 3;
  idx[24] = 7; idx[25] = 8; idx[26] = 9;
  idx[27] = 8; idx[28] = 7; idx[29] = 0;
  idx[30] = 11; idx[31] = 0; idx[32] = 1;
  idx[33] = 0; idx[34] = 11; idx[35] = 4;
  idx[36] = 6; idx[37] = 2; idx[38] = 10;
  idx[39] = 1; idx[40] = 6; idx[41] = 11;
  idx[42] = 3; idx[43] = 5; idx[44] = 10;
  idx[45] = 5; idx[46] = 4; idx[47] = 11;
  idx[48] = 2; idx[49] = 7; idx[50] = 9;
  idx[51] = 7; idx[52] = 1; idx[53] = 0;
  idx[54] = 3; idx[55] = 9; idx[56] = 8;
  idx[57] = 4; idx[58] = 8; idx[59] = 0;

  buffer.genBuffer( idx.data(), idx.dataSize(), 60 );

  return params;
}

function RenderDataDefaultValues( Ref<StatisticSource> parent, Integer dummy ) {// dummy: work around a KL compiler bug (wouldn't call this constructor)
  this.autoStats = StatisticsAutoRegisterMember(this);
  AddStatisticsChild(parent, this.autoStats);

  this.defaultTexture = buildDefaultTexture();
  AddStatisticsChild(this.autoStats, this.defaultTexture.autoStats);

  this.randomTexture = buildRandomTexture();
  AddStatisticsChild(this.autoStats, this.randomTexture.autoStats);

  this.noTexture = OGLTexture2D();
  this.noTexture.name = "noTexture";
  this.noTexture.glTextureType=GL_TEXTURE_2D;

  this.noBuffer = OGLBuffer();
  this.noBuffer.numBufferElementComponents = 1;
  this.noBuffer.bufferType = GL_ELEMENT_ARRAY_BUFFER;
  this.noBuffer.bufferUsage = GL_STATIC_DRAW;
  this.noBuffer.bufferElementComponentType = GL_UNSIGNED_BYTE;

  this.screenPlaneImplicitGeomParams = buildScreenPlaneImplicitGeom(this.autoStats);
  this.coneImplicitGeomParams = buildConeImplicitGeom(this.autoStats);
  this.sphereImplicitGeomParams = buildSphereImplicitGeom(this.autoStats);
}

//updateOpPrimList: allocates new entries if operator's slice count increases, cleans older entries if slice count decreased
function RenderDataStruct.updatePrimInstanceIndices!( Size primIndex, Size newCount, io Boolean hasUninitializedInstances ) {
  hasUninitializedInstances = false;

  Size index = this.primitives[primIndex].firstInstanceIndex;
  Size prevCount = this.primitives[primIndex].numInstances;

  if( newCount != prevCount ) {
    this.primitives[primIndex].numInstances = newCount;
    UInt32 nbToSkip = newCount < prevCount ? newCount : prevCount;
    UInt32 prevIndex = 0;
    for( Size i = 0; i < nbToSkip; ++i ) {
      prevIndex = index;
      index = this.instances[index].primNextInstanceDataIndex;
    }

    Integer ownerType = this.primitives[primIndex].ownerType;

    if( newCount > prevCount ) {
      //Allocate
      hasUninitializedInstances = true;
      for( Size i = prevCount; i < newCount; ++i ) {

        if( this.instancesIndexPool.getFreeIndex( index ) )
          this.instances.resize( this.instancesIndexPool.getIndexEnd() );
        if( prevIndex )//Build linked list
          this.instances[prevIndex].primNextInstanceDataIndex = index;
        else
          this.primitives[primIndex].firstInstanceIndex = index;
        this.instances[index].used = true;
        this.instances[index].renderDataGenerationCount = this.generationCount;

        this.instances[index].primIndex = primIndex;
        this.instances[index].primInstanceIndex = i;

        if( ownerType ) {
          this.instances[index].instancePerTypeIndex = this.instanceIndicesPerType[ownerType].size();
          this.instanceIndicesPerType[ownerType].push( index );
        }
        prevIndex = index;
        index = this.instances[index].primNextInstanceDataIndex;
      }
    } else {
      //Cleanup
      for( Size i = newCount; i < prevCount; ++i ) {
        this.instancesIndexPool.unusedIndex( index );
        this.instances[index].used = false;

        if( prevIndex )//Dismantle linked list
          this.instances[prevIndex].primNextInstanceDataIndex = 0;
        else
          this.primitives[primIndex].firstInstanceIndex = 0;

        prevIndex = index;
        index = this.instances[index].primNextInstanceDataIndex;

        if( ownerType ) {
          //Clean perType index
          Size indicesCount = this.instanceIndicesPerType[ownerType].size();
          Size instancePerTypeIndex = this.instances[prevIndex].instancePerTypeIndex;
          if( instancePerTypeIndex+1 < indicesCount ) {
            //Recompact: replace with the last one
            Size otherPrimIndex = this.instanceIndicesPerType[ownerType][indicesCount-1];
            this.instanceIndicesPerType[ownerType][instancePerTypeIndex] = otherPrimIndex;
            this.instances[otherPrimIndex].instancePerTypeIndex = instancePerTypeIndex;
          }
          this.instanceIndicesPerType[ownerType].resize( indicesCount-1 );
          //Clean Octree. Note: this is safe even if the instance was not added to the grid.
          this.renderCaches.octreePerType[ownerType].removeObject(prevIndex);
          this.primitivesListVersionPerType[ownerType]++;
        }
        this.instances[prevIndex] = InstanceData();
      }
    }
  }
}

function RenderDataStruct.initPrimTypeAndNameMap!( Size primIndex, RenderParamValues mainOwnerParams ) {
  //Set perType index
  Integer ownerType = mainOwnerParams.ownerType;
  this.primitives[primIndex].ownerType = ownerType;

  if( this.primitiveIndicesPerTypeIndexPool[ownerType].getFreeIndex( this.primitives[primIndex].primPerTypeIndex ) )
    this.primitiveIndicesPerType[ownerType].resize( this.primitiveIndicesPerTypeIndexPool[ownerType].getIndexEnd() );
  this.primitiveIndicesPerType[ownerType][this.primitives[primIndex].primPerTypeIndex] = primIndex;
  ++this.primitivesListVersionPerType[ownerType];

  //Set name map
  if( ownerType == OwnerType_material || ownerType == OwnerType_viewport || ownerType == OwnerType_camera ) {
    String ownerName = mainOwnerParams.ownerName;
    if( ownerType == OwnerType_material && this.primitiveNameToIndex[OwnerType_material].has( ownerName ) )
      report("Warning: materialPreset registered twice: " + ownerName );
    this.primitiveNameToIndex[ownerType][ ownerName ] = primIndex;
  }
}

//updateOpPrimList: allocates new entries if operator's slice count increases, cleans older entries if slice count decreased
function RenderDataStruct.updateOpPrimCountAndType!( Integer opIndex, Size newSliceCount, io Size firstPrimIndex) {
  firstPrimIndex = 0;

  if( this.sourceOpInfos.size() <= opIndex )
    this.sourceOpInfos.resize( opIndex + 1 );

  Size index = this.sourceOpInfos[opIndex].firstPrimIndex;
  Size prevSliceCount = this.sourceOpInfos[opIndex].numSourceSlices;
  if( newSliceCount != prevSliceCount ) {
    this.sourceOpInfos[opIndex].numSourceSlices = newSliceCount;
    UInt32 nbToSkip = newSliceCount < prevSliceCount ? newSliceCount : prevSliceCount;
    UInt32 prevIndex = 0;
    for( Size i = 0; i < nbToSkip; ++i ) {
      prevIndex = index;
      index = this.primitives[index].opNextPrimitiveDataIndex;
    }

    if( newSliceCount > prevSliceCount ) {
      //Allocate
      for( Size i = prevSliceCount; i < newSliceCount; ++i ) {

        if( this.primitivesIndexPool.getFreeIndex( index ) )
          this.primitives.resize( this.primitivesIndexPool.getIndexEnd() );

        if( prevIndex )//Build linked list
          this.primitives[prevIndex].opNextPrimitiveDataIndex = index;
        else
          this.sourceOpInfos[opIndex].firstPrimIndex = index;
        this.primitives[index].used = true;
        this.primitives[index].renderDataGenerationCount = this.generationCount;

        prevIndex = index;
        index = this.primitives[index].opNextPrimitiveDataIndex;
      }
    } else {
      //Cleanup
      for( Size i = newSliceCount; i < prevSliceCount; ++i ) {
        this.primitivesIndexPool.unusedIndex( index );
        this.primitives[index].used = false;

        if( prevIndex )//Dismantle linked list
          this.primitives[prevIndex].opNextPrimitiveDataIndex = 0;
        else
          this.sourceOpInfos[opIndex].firstPrimIndex = 0;

        prevIndex = index;
        index = this.primitives[index].opNextPrimitiveDataIndex;

        Integer ownerType = this.primitives[prevIndex].ownerType;
        if( ownerType ) {
          //Clean perType index
          this.primitiveIndicesPerTypeIndexPool[ownerType].unusedIndex( this.primitives[prevIndex].primPerTypeIndex );
          this.primitiveIndicesPerType[ownerType][this.primitives[prevIndex].primPerTypeIndex] = InvalidIndex;

          //Clean name map
          if( ownerType == OwnerType_material || ownerType == OwnerType_viewport || ownerType == OwnerType_camera ) {
            Size numLayers = this.primitives[prevIndex].params.getNumLayers();
            if(numLayers)
              this.primitiveNameToIndex[ownerType].delete(this.primitives[prevIndex].params.layers[numLayers-1].params.ownerName);
          }
        }

        //Cleanup associated instances
        Boolean dummy;
        this.updatePrimInstanceIndices( prevIndex, 0, dummy );
        this.primitives[prevIndex] = PrimitiveData();
      }
    }
    firstPrimIndex = this.sourceOpInfos[opIndex].firstPrimIndex;
  }
  else
    firstPrimIndex = index;
}

function RenderDataStruct.initPrimitive!( Size primIndex, RenderParams params ) {
  if( params.getNumLayers() ) {
    Size lastLayer = params.getNumLayers()-1;
    this.initPrimTypeAndNameMap( primIndex, params.layers[lastLayer].params );

    Integer ownerType = this.primitives[primIndex].ownerType;

    RenderParamKey transformKey = params.getKey( this.transformParamString );
    if( transformKey.isValid() ) {
      this.primitives[ primIndex ].transformVersionKey.key = transformKey;
      //Don't call 'initialize'; we want the key to be initially dirty
    }

    RenderParamKey localBVolKey = params.getKey( this.localBVolParamString );
    if( localBVolKey.isValid() ) {
      this.primitives[ primIndex ].localBVolVersionKey.key = localBVolKey;
      //Don't call 'initialize'; we want the key to be initially dirty
    }
  }
}

function RenderDataStruct.updatePrimitive!( Size primIndex, RenderParams params ) {
  Size numInstances = 1;
  Boolean validTransformKey = this.primitives[ primIndex ].transformVersionKey.isValid();
  Boolean validLocalBVolKey = this.primitives[ primIndex ].localBVolVersionKey.isValid();
  if( validTransformKey ) {
    //Check if numInstances changed
    this.primitives[ primIndex ].transformVersionKey.synchronize( params, this.transformParamString );
    //Note that key's 'dirty' state is set only for individual elements, not for count change
    numInstances = params.getElementCount(this.primitives[ primIndex ].transformVersionKey.key);
  }

  Boolean hasUninitializedInstances;
  this.updatePrimInstanceIndices( primIndex, numInstances, hasUninitializedInstances );

  Boolean primHasChanged = this.primitives[primIndex].renderDataGenerationCount == this.generationCount;
  if( primHasChanged || hasUninitializedInstances ) {
    Size instanceIndex = this.primitives[primIndex].firstInstanceIndex;
    Size offset = 0;
    while( instanceIndex ) {
      if( primHasChanged )
        this.instances[instanceIndex].renderDataGenerationCount = this.generationCount;
      if( this.instances[instanceIndex].renderDataGenerationCount == this.generationCount ) {
        if( validTransformKey ) {
          this.instances[instanceIndex].transformVersionKey.paramVersions = Versions();//Reset versions
          this.instances[instanceIndex].transformVersionKey.key = this.primitives[ primIndex ].transformVersionKey.key;
          this.instances[instanceIndex].transformVersionKey.elementIndex = offset;
        }
        if( validLocalBVolKey ) {
          this.instances[instanceIndex].localBVolVersionKey.paramVersions = Versions();//Reset versions
          this.instances[instanceIndex].localBVolVersionKey.key = this.primitives[ primIndex ].localBVolVersionKey.key;
          Boolean perElement = params.getLayer(this.instances[instanceIndex].localBVolVersionKey.key.layerIndex).isPerElement( this.instances[instanceIndex].localBVolVersionKey.key.valueKey );
          this.instances[instanceIndex].localBVolVersionKey.elementIndex = perElement ? offset : 0;
        }
      }
      instanceIndex = this.instances[instanceIndex].primNextInstanceDataIndex;
      ++offset;
    }
  }
  Boolean paramsChanged = synchronizeVersion( params.versions.value, this.primitives[ primIndex ].lastParamsVersion );
  Boolean paramsTopoChanged = synchronizeVersion( params.versions.topo, this.primitives[ primIndex ].lastParamsTopoVersion );

  this.primitives[ primIndex ].params = params;
  if( this.renderCaches.gridActive && primIndex >= numImplicitGeometryPrimitives && paramsChanged ) {
    if( this.primitives[ primIndex ].localBVolVersionKey.isValid() ) {
      //Update hierarchical grid info
      //Optimization idea: detect if an object is static or not, and have 2 grids: one for static objects, and one for dynamic objects.
      Integer ownerType = this.primitives[ primIndex ].ownerType;
      Size instanceIndex = this.primitives[primIndex].firstInstanceIndex;
      Size j = 0;
      while( instanceIndex ) {
        if( this.instances[ instanceIndex ].transformVersionKey.isValid() ) {
          Boolean transfoDirty = this.instances[ instanceIndex ].transformVersionKey.synchronize_explicitElementIndex( params, this.transformParamString );
          Boolean bVolDirty = this.instances[ instanceIndex ].localBVolVersionKey.synchronize_explicitElementIndex( params, this.localBVolParamString );
          if( transfoDirty || bVolDirty ) {
            ++this.globalTransformAndLocalBVolVersionPerType[ownerType];

            LocalBoundingVolume localBVol;
            params.get( this.instances[ instanceIndex ].localBVolVersionKey, localBVol );

            Mat44 transform;
            if( params.get( this.instances[ instanceIndex ].transformVersionKey.key ).type == Mat44RenderParam )//Not per instance matrix
              params.get( this.instances[ instanceIndex ].transformVersionKey, transform );
            this.renderCaches.octreePerType[ ownerType ].updateObjectVolume( instanceIndex, transform, localBVol );
          }
        }
        instanceIndex = this.instances[ instanceIndex ].primNextInstanceDataIndex;
        ++j;
      }
    }
  }
  if( paramsTopoChanged ) {
    //Update flags cache
    for( flag in this.renderCaches.primitiveFlagsPerType[ this.primitives[ primIndex ].ownerType ] ) {
      //NOTE: KL should allow modifying 'value' in 'for( k, v in d )' construct, but for some reason it doesn't...
      RenderParamKey flagKey = this.primitives[ primIndex ].params.getKey( flag );
      this.renderCaches.primitiveFlagsPerType[ this.primitives[ primIndex ].ownerType ][flag].updateBit( this.primitives[ primIndex ].primPerTypeIndex, flagKey.isValid() );
    }
  }
}

function RenderDataStruct.init!( Ref<StatisticSource> parent, UInt32 dataLayoutGenerationCount, Vec3 worldGeometryBBoxIncrement ) {
  ++this.generationCount;
  Boolean initialize = !this.initialized;
  Boolean reinitialize = synchronizeVersion( dataLayoutGenerationCount, this.dataLayoutGenerationCount ) && !initialize;

  if( initialize || reinitialize ) {

    RenderDataDefaultValues defaultValues = this.defaultValues;
    this = RenderDataStruct();

    if( !defaultValues )
      defaultValues = RenderDataDefaultValues( parent, 0 );
    this.defaultValues = defaultValues;

    this.initialized = true;
    this.dataLayoutGenerationCount = dataLayoutGenerationCount;

    //Created reserved entries (0 = null)
    UInt32 dummy;
    this.primitives.resize(numImplicitGeometryPrimitives);
    this.primitivesIndexPool.reset();
    this.primitivesIndexPool.getFreeIndex( dummy );
    while(dummy < numImplicitGeometryPrimitives)
      this.primitivesIndexPool.getFreeIndex( dummy );

    this.instances.resize(1);
    this.instancesIndexPool.reset();
    this.instancesIndexPool.getFreeIndex( dummy );

    this.passes.resize(1);
    this.passFunctionKeys.resize(1);

    this.renderCaches = RenderCaches();
    AddStatisticsChild(parent, this.renderCaches.autoStats);

    this.renderCaches.gridActive = true;
    this.renderCaches.gridNumCellUpdatesPerFrameBeforeDraw = 0;
    this.renderCaches.gridNumCellUpdatesPerFrameDuringDraw = 10000;

    this.materialParamString = "oglMaterial";
    this.shaderParamString = "oglShader";
    this.transformParamString = "transform";
    this.viewTransformParamString = "viewTransform";
    this.invViewTransformParamString = "invViewTransform";
    this.projectionParamString = "projection";
    this.invProjectionParamString = "invProjection";
    this.localBVolParamString = "localBVol";
    this.widthParamString = "width";
    this.heightParamString = "height";
    this.depthParamString = "depth";
    this.defaultParamString = "default";
    this.geometryElementTypeString = "geometryElementType";
    this.instanceCountString = "instanceCount";
    this.indicesString = "indices";
    this.adjustedImplicitGeometryString = "adjustedImplicitGeometry";

    this.primitives[ImplicitGeometryPrimitive_screenPlane].used = true;
    this.initPrimitive( ImplicitGeometryPrimitive_screenPlane, this.defaultValues.screenPlaneImplicitGeomParams );
    this.updatePrimitive( ImplicitGeometryPrimitive_screenPlane, this.defaultValues.screenPlaneImplicitGeomParams );

    this.primitives[ImplicitGeometryPrimitive_negZAxisUnitCone].used = true;
    this.initPrimitive( ImplicitGeometryPrimitive_negZAxisUnitCone, this.defaultValues.coneImplicitGeomParams );
    this.updatePrimitive( ImplicitGeometryPrimitive_negZAxisUnitCone, this.defaultValues.coneImplicitGeomParams );

    this.primitives[ImplicitGeometryPrimitive_unitSphere].used = true;
    this.initPrimitive( ImplicitGeometryPrimitive_unitSphere, this.defaultValues.sphereImplicitGeomParams );
    this.updatePrimitive( ImplicitGeometryPrimitive_unitSphere, this.defaultValues.sphereImplicitGeomParams );

    this.staticParams.ensureLayerExists(1);
    this.staticParams.layers[0].params.ownerName = "RenderDataGlobals";
    this.staticParams.layers[1].params.ownerName = "RenderDataGlobals";

    this.staticTrueKey.key.valueKey = this.staticParams.layers[1].params.setAsBoolean("staticTrue");
    this.staticTrueKey.key.layerIndex = 1;
    this.staticParams.set( this.staticTrueKey.key, true );

    this.staticFalseKey.key.valueKey = this.staticParams.layers[1].params.setAsBoolean("staticFalse");
    this.staticFalseKey.key.layerIndex = 1;
    this.staticParams.set( this.staticFalseKey.key, false );

    RenderValueKey textureKey = this.staticParams.layers[1].params.setAsOGLTexture2D("defaultTexture");
    this.staticParams.layers[1].params.set( textureKey, this.defaultValues.defaultTexture );

    textureKey = this.staticParams.layers[1].params.setAsOGLTexture2D("randomTexture");
    this.staticParams.layers[1].params.set( textureKey, this.defaultValues.randomTexture );

    textureKey = this.staticParams.layers[1].params.setAsOGLTexture2D("noTexture");
    this.staticParams.layers[1].params.set( textureKey, this.defaultValues.noTexture );

    textureKey = this.staticParams.layers[1].params.setAsOGLBuffer("noAttribute");
    this.staticParams.layers[1].params.set( textureKey, this.defaultValues.noBuffer );
  }
  this.worldGeometryBBoxIncrement = worldGeometryBBoxIncrement;
}

function RenderData.init!( UInt32 dataLayoutGenerationCount, Vec3 worldGeometryBBoxIncrement ) {
  this.data.init( this.autoStats, dataLayoutGenerationCount, worldGeometryBBoxIncrement );
}

function RenderDataStruct.updateShaderLibrary!(OGLShaderLibrary shaderLibrary) {

  Boolean incVersion = this.shaderRenderParamLibrary == null || this.shaderRenderParamLibrary.version != shaderLibrary.version;
  if( incVersion ) {
    this.shaderRenderParamLibrary = shaderLibrary;
    RenderValueKey shaderLibKey = this.staticParams.layers[1].params.getOrCreateKeyFromName("shaderLibrary");
    this.staticParams.layers[1].params.set( shaderLibKey, this.shaderRenderParamLibrary );
    this.staticParams.layers[1].params.incrementValueVersion( shaderLibKey );
  }
}

function String RenderDataStruct.getPrimitiveName?( Size primIndex ) {
  Size numLayer = this.primitives[primIndex].params.getNumLayers();
  String desc;
  if( primIndex == 0 )
    desc = "Viewport";
  else if( this.primitives[primIndex].used == false )
    desc = "(unused)";
  else {
    RenderParamKey nameKey = this.primitives[primIndex].params.getKey( "name" );
    if( nameKey.isValid() )
      this.primitives[primIndex].params.get(nameKey, desc);
    else if(numLayer)
      desc = this.primitives[primIndex].params.layers[numLayer-1].params.ownerName;
    else
      desc = "(undefined)";
  }
  return desc;
}

function String RenderDataStruct.getPrimitiveDesc?( Size index, Boolean reportType, Boolean reportParamLayers ) {
  String desc = this.getPrimitiveName(index);
  Boolean multiInstance = this.primitives[index].numInstances > 1;
  if(reportType || reportParamLayers || multiInstance) {
    desc += " (";
    if(multiInstance)
      desc += ' numInst='+this.primitives[index].numInstances;
    if(reportType)
      desc += ' type='+ownerTypeToString( this.primitives[index].ownerType );
    if(reportParamLayers)
      desc += ' paramLayers='+this.primitives[index].params.getLayersDesc();
    desc += " )";
  }
  return desc;
}

function String RenderDataStruct.getPrimitiveDesc?( Size index ) {
  return this.getPrimitiveDesc( index, true, true );
}

function String RenderDataStruct.getInstanceName?( Size index ) {
  Size primIndex = this.instances[index].primIndex;
  String desc = this.getPrimitiveName(primIndex);
  if(this.primitives[primIndex].numInstances > 1)
    desc += '['+this.instances[index].primInstanceIndex+']';
  return desc;
}

function String RenderDataStruct.getInstanceDesc?( Size index, Boolean reportType, Boolean reportIndex, Boolean reportParamLayers ) {
  Size primIndex = this.instances[index].primIndex;
  String desc = this.getInstanceName(index);
  if(reportType || reportIndex || reportParamLayers) {
    desc += " (";
    if(reportType)
      desc += ' type='+ownerTypeToString( this.primitives[primIndex].ownerType );
    if(reportIndex)
      desc += ' index=[Prim:'+primIndex+',Inst:'+index+']';
    if(reportParamLayers)
      desc += ' paramLayers='+this.primitives[primIndex].params.getLayersDesc();
    desc += " )";
  }
  return desc;
}

function String RenderDataStruct.getInstanceDesc?( Size index ) {
  return this.getInstanceDesc( index, true, false, true );
}

function String RenderDataStruct.getInstancesDesc?( String indent, Boolean reportIndices, Boolean reportParams, Boolean reportParamVersions, String typeFilters[] ) {
  Size numFilters = typeFilters.size();
  Boolean hasFilter = numFilters > 0;

  Integer ownerTypeFilters[];
  ownerTypeFilters.resize(numFilters);
  for( Size i = 0; i < numFilters; ++i ) {
    ownerTypeFilters[i] = stringToOwnerType(typeFilters[i]);
    if( ownerTypeFilters[i] == OwnerType_none )
      report("RenderDataStruct.reportInstances: error: filter "+typeFilters[i]+" not supported; supported are: camera, geometryInstance, light, material" );
  }
  String desc;
  for( Size i = 1; i < this.instances.size(); ++i ) {
    if( this.instances[i].used ) {
      Size primIndex = this.instances[i].primIndex;
      if(hasFilter) {
        Boolean keep = false;
        Integer ownerType = this.primitives[primIndex].ownerType;
        for( Size j = 0; j < numFilters; ++j ) {
          if(ownerType == ownerTypeFilters[j]) {
            keep = true;
            break;
          }
        }
        if(!keep)
          continue;
      }
      desc += indent; 
      if( reportIndices )
        desc += i+": ";
      desc += this.getInstanceDesc( i, true, reportIndices, !reportParams )+"\n";
      if( reportParams )
        desc += this.primitives[primIndex].params.getDesc(indent + "  ", true, reportParamVersions, this.instances[i].primInstanceIndex);
    }
  }
  return desc;
}

function String RenderDataStruct.getInstancesDesc?( String indent, Boolean reportIndices, Boolean reportParams, Boolean reportParamVersions ) {
  String typeFilters[];
  return this.getInstancesDesc( indent, reportIndices, reportParams, reportParamVersions, typeFilters );
}


function String RenderDataStruct.getPassesDesc?( String indent ) {
  String desc = indent + "Passes: count=" + (this.passes.size()-1) + ":\n";
  for( Size i = 1; i < this.passes.size(); ++i )
    desc += indent + "  " + i + ": " + this.passes[i].name + "\n";
  return desc;
}

function RenderCaches.reportGrids?( Boolean detailed ) {
  if( this.gridActive ) {
    for( Size i = 0; i < numOwnerTypes; ++i ) {
      if( this.octreePerType[i].getObjectCount() > 0 ) {
        report( "Hierarchical grid for " + ownerTypeToString(i) + ": " );
        this.octreePerType[i].data.report( false );
      }
    }
  }
}

function RenderDataStruct.updateMaterialPresets!( io Integer opIndex, RenderParamValues matParamValueRef<> ) {
  Size primIndex;
  this.updateOpPrimCountAndType( opIndex, matParamValueRef.size(), primIndex );

  Size i = 0;
  while( primIndex ) {

    // check if there is a valid matParamRefValue
    if( matParamValueRef[i] == null ) {
      primIndex = this.primitives[primIndex].opNextPrimitiveDataIndex;
      ++i;
      continue;      
    }

    if( this.primitives[primIndex].renderDataGenerationCount == this.generationCount ) {
      //initialize
      this.initPrimTypeAndNameMap( primIndex, matParamValueRef[i] );
      Boolean dummy;
      this.updatePrimInstanceIndices( primIndex, 1, dummy );
    }

    this.primitives[primIndex].params.setLayer(0, matParamValueRef[i]);
    primIndex = this.primitives[primIndex].opNextPrimitiveDataIndex;
    ++i;
  }
  ++opIndex;
}

function RenderDataStruct.initFunctionStaticKeyBinding!( Size paramIndex, BindingRenderParam binding, io ValueOrFunctionKeyDefinition keyDefinition ) {
  if( binding.scope == BindingRenderParam_initializing ) {
    setBit( keyDefinition.initializingBindingBits, paramIndex );
    setBit( keyDefinition.memberBindingBits, paramIndex );
  } else if( binding.scope == BindingRenderParam_memberScope )
    setBit( keyDefinition.memberBindingBits, paramIndex );
  else if( binding.scope == BindingRenderParam_parentScope )
    setBit( keyDefinition.parentBindingBits, paramIndex );
  else if( binding.scope == BindingRenderParam_globalScope )
    setBit( keyDefinition.globalBindingBits, paramIndex );
  else
    setBit( keyDefinition.bindingBits, paramIndex );
  if( binding.name == this.transformParamString )
    setBit( keyDefinition.transformBindingBits, paramIndex );
  else if( binding.name == this.localBVolParamString )
    setBit( keyDefinition.localBoundingVolumeBindingBits, paramIndex );
  keyDefinition.paramNames[paramIndex] = binding.name;
}

function RenderDataStruct.initFunctionKeys!( OGLRenderValueOrFunction valueOrFunction, io ValueOrFunctionKeyDefinition keyDefinition ) {
  keyDefinition.isValid = true;
  if( !valueOrFunction.functionName ) {
    keyDefinition.functionID = InvalidIndex;
    if( valueOrFunction.valueOrFunctionArgs.size() == 0 )
      keyDefinition.isValid = false;
  }
  else {
    keyDefinition.functionID = valueOrFunction.functionID;
    keyDefinition.functionName = valueOrFunction.functionName;
    keyDefinition.needsDebugContext = valueOrFunction.functionNeedsDebugContext;
  }

  keyDefinition.keys.resize( valueOrFunction.valueOrFunctionArgs.size() );
  keyDefinition.paramNames.resize( valueOrFunction.valueOrFunctionArgs.size() );

  for( Size i = 0; i < valueOrFunction.valueOrFunctionArgs.size(); ++i ) {
    if( valueOrFunction.argIsRenderFlag[i] )
      setBit( keyDefinition.isFlagBits, i );

    if( valueOrFunction.valueOrFunctionArgs[i].type == BindingRenderParam ) {
      this.initFunctionStaticKeyBinding( i, valueOrFunction.valueOrFunctionArgs[i], keyDefinition );
    } else {
      keyDefinition.paramNames[i] = "RenderFunctionStaticArg" + this.staticParams.layers[0].params.size();
      keyDefinition.keys[i].key.valueKey = this.staticParams.layers[0].params.setFromSimpleRenderParam(keyDefinition.paramNames[i], valueOrFunction.valueOrFunctionArgs[i], TransformSpace_none);
      keyDefinition.keys[i].key.layerIndex = 0;
    }
  }
}

inline RenderDataStruct.initFlagKeys!( BindingRenderParam flags[], io ValueOrFunctionKeyDefinition keyDefinition ) {
  keyDefinition.isValid = flags.size() > 0;
  keyDefinition.functionID = InvalidIndex;

  keyDefinition.keys.resize( flags.size() );
  keyDefinition.paramNames.resize( flags.size() );

  for( Size i = 0; i < flags.size(); ++i ) {
    setBit( keyDefinition.isFlagBits, i );
    this.initFunctionStaticKeyBinding( i, flags[i], keyDefinition );
  }
}

function RenderDataStruct.updatePasses!( io Integer opIndex, OGLRenderPasses passes ) {
  Boolean init = this.sourceOpInfos.size() <= opIndex;
  if( init ) {
    Size index = this.passes.size();
    this.sourceOpInfos.resize( opIndex+1 );
    this.sourceOpInfos[opIndex].firstPrimIndex = this.passes.size();
    this.sourceOpInfos[opIndex].numSourceSlices = 1;

    for( Size i = 0; i < passes.passes.size(); ++i ) {
      if( this.primitiveNameToIndex[OwnerType_pass].has( passes.passes[i].name ) )
        report("Warning: pass registered twice: " + passes.passes[i].name );

      this.primitiveNameToIndex[OwnerType_pass][ passes.passes[i].name ] = this.passes.size();
      this.passes.push( passes.passes[i] );

      //Set function static keys
      PassFunctionKeys functionKeys;
      functionKeys.groupKeys.resize( passes.passes[i].groups.size() );
      for( Size j = 0; j < passes.passes[i].groups.size(); ++j ) {
        this.initFunctionKeys( passes.passes[i].groups[j].condition, functionKeys.groupKeys[j].conditionKeys );
        this.initFlagKeys( passes.passes[i].groups[j].flags, functionKeys.groupKeys[j].flagKeys );
        this.initFunctionKeys( passes.passes[i].groups[j].cullBoundingVolume, functionKeys.groupKeys[j].cullBoundingVolumeKeys );
      }
      
      functionKeys.applyKeys.resize( passes.passes[i].applyOps.size() );
      for( Size j = 0; j < passes.passes[i].applyOps.size(); ++j ) {
        functionKeys.applyKeys[j].bindingKeys.resize( passes.passes[i].applyOps[j].bindingSources.size() );

        for( Size k = 0; k < functionKeys.applyKeys[j].bindingKeys.size(); ++k )
          this.initFunctionKeys( passes.passes[i].applyOps[j].bindingSources[k], functionKeys.applyKeys[j].bindingKeys[k] );

        functionKeys.applyKeys[j].drawCallbackKeys.resize( passes.passes[i].applyOps[j].drawCallbacks.size() );
        for( Size k = 0; k < functionKeys.applyKeys[j].drawCallbackKeys.size(); ++k )
          this.initFunctionKeys( passes.passes[i].applyOps[j].drawCallbacks[k], functionKeys.applyKeys[j].drawCallbackKeys[k] );

        this.initFunctionKeys( passes.passes[i].applyOps[j].condition, functionKeys.applyKeys[j].conditionKeys );
        this.initFunctionKeys( passes.passes[i].applyOps[j].updateInterval, functionKeys.applyKeys[j].updateIntervalKeys );
        this.initFunctionKeys( passes.passes[i].applyOps[j].cullFace, functionKeys.applyKeys[j].cullFaceKeys );

        functionKeys.applyKeys[j].renderTargetWidthKeys.resize( passes.passes[i].applyOps[j].renderTargets.size() );
        functionKeys.applyKeys[j].renderTargetHeightKeys.resize( passes.passes[i].applyOps[j].renderTargets.size() );
        functionKeys.applyKeys[j].renderTargetDepthKeys.resize( passes.passes[i].applyOps[j].renderTargets.size() );
        functionKeys.applyKeys[j].renderTargetClearColorKeys.resize( passes.passes[i].applyOps[j].renderTargets.size() );
        functionKeys.applyKeys[j].renderTargetClearDepthKeys.resize( passes.passes[i].applyOps[j].renderTargets.size() );
        functionKeys.applyKeys[j].renderTargetSourceKeys.resize( passes.passes[i].applyOps[j].renderTargets.size() );

        for( Size k = 0; k < functionKeys.applyKeys[j].renderTargetWidthKeys.size(); ++k ) {
          this.initFunctionKeys( passes.passes[i].applyOps[j].renderTargets[k].widthFunction, functionKeys.applyKeys[j].renderTargetWidthKeys[k] );
          this.initFunctionKeys( passes.passes[i].applyOps[j].renderTargets[k].heightFunction, functionKeys.applyKeys[j].renderTargetHeightKeys[k] );
          this.initFunctionKeys( passes.passes[i].applyOps[j].renderTargets[k].depthFunction, functionKeys.applyKeys[j].renderTargetDepthKeys[k] );
          this.initFunctionKeys( passes.passes[i].applyOps[j].renderTargets[k].clearColor, functionKeys.applyKeys[j].renderTargetClearColorKeys[k] );
          this.initFunctionKeys( passes.passes[i].applyOps[j].renderTargets[k].clearDepth, functionKeys.applyKeys[j].renderTargetClearDepthKeys[k] );
          this.initFunctionKeys( passes.passes[i].applyOps[j].renderTargets[k].source, functionKeys.applyKeys[j].renderTargetSourceKeys[k] );
        }

        functionKeys.applyKeys[j].refineRenderTargetClearColorKeys.resize( passes.passes[i].applyOps[j].refineRenderTargets.size() );
        functionKeys.applyKeys[j].refineRenderTargetClearDepthKeys.resize( passes.passes[i].applyOps[j].refineRenderTargets.size() );

        for( Size k = 0; k < functionKeys.applyKeys[j].refineRenderTargetClearColorKeys.size(); ++k ) {
          this.initFunctionKeys( passes.passes[i].applyOps[j].refineRenderTargets[k].clearColor, functionKeys.applyKeys[j].refineRenderTargetClearColorKeys[k] );
          this.initFunctionKeys( passes.passes[i].applyOps[j].refineRenderTargets[k].clearDepth, functionKeys.applyKeys[j].refineRenderTargetClearDepthKeys[k] );
        }

      }
      
      this.passFunctionKeys.push( functionKeys );
    }
  }
  ++opIndex;
}

function RenderDataStruct.updateInstances!( io Integer opIndex, RenderParams renderParams<> ) {
  Size primIndex;
  this.updateOpPrimCountAndType( opIndex, renderParams.size(), primIndex );
  Size i = 0;
  while( primIndex ) {
    if( renderParams[i].layoutOrderVersion != this.primitives[primIndex].params.layoutOrderVersion )
      this.primitives[primIndex].renderDataGenerationCount = this.generationCount;

    if( this.primitives[primIndex].renderDataGenerationCount == this.generationCount )
      this.initPrimitive( primIndex, renderParams[i] );

    this.updatePrimitive( primIndex, renderParams[i] );
    primIndex = this.primitives[primIndex].opNextPrimitiveDataIndex;
    ++i;
  }
  ++opIndex;
}

function RenderDataStruct.updateInstances!( io Integer opIndex, RenderParamValues renderParamValues<> ) {
  Size primIndex;
  this.updateOpPrimCountAndType( opIndex, renderParamValues.size(), primIndex );
  Size i = 0;
  while( primIndex ) {
    this.tempParams.setLayer_noVersionChange( 0, renderParamValues[i], 0 );

    if( this.primitives[primIndex].renderDataGenerationCount == this.generationCount )
      this.initPrimitive( primIndex, this.tempParams );

    this.updatePrimitive( primIndex, this.tempParams );
    primIndex = this.primitives[primIndex].opNextPrimitiveDataIndex;
    ++i;
  }
  ++opIndex;
}

struct PackedMemberValueOrFunctionVersionedKeys {
  Size numBindingsPerMember;
  Boolean memberBindingsAreOnlyTransfoOrLocalBVol;
  Boolean ignoreMemberBindings;//Used by a 'flags' related optimization
  Size numParentBindings;
  Size numMembers;
  RenderParamVersionedKey packedMemberBindings[];
  ValueOrFunctionKeyDefinition sharedKeys;//avoid mallocs + holds static keys' definition
  Size passParamsGenerationCount;

  Ref<_RTRUserCallbackFunctions> functionCaller;
};

function Size PackedMemberValueOrFunctionVersionedKeys.getMemUsage() {
  return 4*5*this.packedMemberBindings.size() + 16*4 + 11*4;//Approximation
}

struct InstanceStoredTextureData {
  RenderValueKey key;
  OGLTexture2D textureContainer;

  Ref<OGLTexture2D> textureTypeReference;
  Boolean recycleInPool;
  Boolean setFromSource;
  String name;
};

object InstanceStoredData {
  InstanceStoredTextureData textureData[];
  Integer depthBufferIndex;
  Integer depthAttachmentType;

  Size index;
  Size poolIndex;

  RenderParamValues params;

  Ref<Object> ownerApplyObj;//Cannot reference 'ApplyData' directly (KL limitation; undeclared struct)
  Size ownerApplyMemberIndex;

  LocalL16UInt32Array passOrderStack;
  Size sequencePassOrder;
  //TODO: support stored group indices...
};

function Size InstanceStoredData.getMemUsage() {
  //very approximative; hopefully KL will add a built-in getMemUsage()
  Size instanceStoredTextureDataSize = 8*4 + 24;
  Size mem = this.textureData.size()*instanceStoredTextureDataSize + 8*4;
  if( this.params )
    mem += this.params.getMemUsage_withoutParamValues();
  return mem;
}


function InstanceStoredData.reset!() {
  this.params.reset();
  this.textureData.resize(0);
  this.passOrderStack.resize(0);
  this.depthBufferIndex = 0;
  this.depthAttachmentType = 0;

  Ref<Object> ownerApplyObj = null;
  this.ownerApplyObj = ownerApplyObj;
  this.ownerApplyMemberIndex = 0;
}

struct InstanceStoredDatas {
  Ref<InstanceStoredData> data[];
  Size instanceIndex;

  RenderParamValues feedbackParams;
  Size feedbackParamsCreationGenerationCount;

  Versions initialVersions;//until we have a better system for identifying values uniquely
  UInt32 layoutOrderVersion;
};

function Size InstanceStoredDatas.getMemUsage() {
  //very approximative; hopefully KL will add a built-in getMemUsage()
  Size mem = 8*4;
  if( this.feedbackParams )
    mem += this.feedbackParams.getMemUsage_withoutParamValues();
  for( Size i = 0; i < this.data.size(); ++i )
    mem += this.data[i].getMemUsage();
  return mem;
}

struct InstanceLayersCache{
  UInt32 lastInstanceStoredDataTopoVersion;

  //NOTE: we set the layer as "owned", but this should not be required!!! There is a bug somewhere, maybe in the Core,
  //that causes a crash when we refer a dead RenderParamValues, even if it is not used...??? I checked by marking that layer as 'deleted'
  //and nothing seems to use it.
  RenderParamValues layers[];
};

function Size InstanceLayersCache.getMemUsage() {
  return 12+this.layers.size()*8;
}

inline InstanceLayersCache.update!( RenderSequenceDataStruct sequenceData, Size instanceIndex, Boolean sameParent, LocalL16UInt32Array passOrderStack, Size sequencePassOrder, Ref<InstanceStoredData> toSkip ) {
  Size indexToSkip = toSkip ? toSkip.index : InvalidIndex;
  if( synchronizeVersion( sequenceData.instancesStoredData[instanceIndex].layoutOrderVersion, this.lastInstanceStoredDataTopoVersion ) ) {
    Size next = 0;
    Size numInstanceLayers = sequenceData.instancesStoredData[instanceIndex].data.size();
    for( Size k = 0; k < numInstanceLayers; ++k ) {
      if( k != indexToSkip ) {
        if( (!sameParent && passOrderPrecedes( sequenceData.instancesStoredData[instanceIndex].data[k].passOrderStack, sequenceData.instancesStoredData[instanceIndex].data[k].sequencePassOrder, passOrderStack, sequencePassOrder ) )
          || (sameParent && passOrderPrecedesWithCommonAncestor( sequenceData.instancesStoredData[instanceIndex].data[k].passOrderStack, sequenceData.instancesStoredData[instanceIndex].data[k].sequencePassOrder, passOrderStack, sequencePassOrder ) ) ) {
          if( next == this.layers.size() )
            this.layers.resize(next+1);
          this.layers[next++] = sequenceData.instancesStoredData[instanceIndex].data[k].params;
        }
      }
    }
    this.layers.resize(next);
  }
}

struct GroupUpdateCachedMemberData {
  Boolean initialized;
  Boolean conditionInitialized;

  Size instanceIndex;
  Size sourceGroupIndex;

  InstanceLayersCache instanceLayersCache;

  Boolean cachedConditionValue;
  UInt32 cachedFlagBits;
  Boolean cachedFlagsResultValue;

  Boolean keep;
};

struct GroupMemberData {
  Size instanceIndex;
  Size sourceGroupIndex;
};

struct GroupData {
  Ref<Object> sequencePassDataObj;
  Size sourcePassGroupIndex;

  Size sequencePassOrder;

  Ref<Object> sourceGroupDataObj;//0 if none
  Ref<Object> complementGroupDataObj;//0 if none
  Boolean subGroup;

  //TODO: add excludeGroup indices
  Size unionGroupDataGenerationCount;
  Size sourceGroupDataGenerationCount;

  //Source pass group data reference (read only):
  Integer types[];

  InstanceLayersCache ownerInstanceLayers;
  RenderParams parentParamsWithOwnerInstanceLayers;
  RenderParams tempSharedParams;//avoid mallocs

  BindingRenderParam flags[];
  UInt8 flagOpsBits[];
  UInt32 flagMemberBits;
  UInt32 nonMemberFlagBits;
  Boolean globalFlagResult;
  PackedMemberValueOrFunctionVersionedKeys flagValueKeys;

  LocalL4UInt32Array globalTransformAndLocalBVolVersionPerType;
  LocalL4UInt32Array instanceListVersionPerType;
  LocalL4UInt32Array flagsVersionPerType;

  Boolean bVolCull;
  Boolean bVolCullWithLocalBVol;
  RenderParamVersionedKey transformKey;
  RenderParamVersionedKey localBVolKey;
  PackedMemberValueOrFunctionVersionedKeys bVolCullFunctionKeys;
  LocalBoundingVolume bVolCullFunctionResult;

  UInt32 memberInstances[];
  Size memberSourceGroupMapping[];
  UInt32 prevMembersNewIndex[];

  Boolean hasCondition;
  Boolean conditionInitialized;
  Boolean globalConditionResult;
  PackedMemberValueOrFunctionVersionedKeys conditionFunctionKeys;
  GroupUpdateCachedMemberData groupUpdateCachedMemberData[];

  UInt32 memberTypeFlags;//Bit is set if there is some members of a given type

  Size numFlags;
  Boolean perMemberFlagCheck;
  Boolean perMemberFlagEval;
  Boolean perMemberCondition;

  Size lastRenderDataGenerationCount;
  Size generationCount;

  UInt64 profileStart;
  UInt64 profileEnd;
};

function Size GroupData.getMemUsage() {
  //very approximative; hopefully KL will add a built-in getMemUsage()
  Size mem = 30*4//bool, int, size, pointers
        + this.types.size()*4 
        + this.ownerInstanceLayers.getMemUsage() 
        + this.parentParamsWithOwnerInstanceLayers.getMemUsage_withoutRenderParamValues()
        + this.flagOpsBits.size()
        + this.flagValueKeys.getMemUsage()
        + this.globalTransformAndLocalBVolVersionPerType.getMemUsage()
        + this.instanceListVersionPerType.getMemUsage()
        + this.flagsVersionPerType.getMemUsage()
        + 4*5*2 //versioned keys
        + this.bVolCullFunctionKeys.getMemUsage()
        + 11*4 //local bvol
        + this.memberInstances.size()*4
        + this.memberSourceGroupMapping.size()*4
        + this.prevMembersNewIndex.size()*4
        + this.conditionFunctionKeys.getMemUsage();
  for( Size i = 0; i < this.groupUpdateCachedMemberData.size(); ++i )
    mem += 6*4 + this.groupUpdateCachedMemberData[i].instanceLayersCache.getMemUsage();
  return mem;
}

object GroupDataObj : StatisticSourceWithAutoRegisterMember {
  GroupData data;
  Size poolIndex;

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

function StatisticRecord[] GroupDataObj.getStatistics() {
  StatisticRecord stats[];
  Ref<SequencePassDataObj> passData = this.data.sequencePassDataObj;
  Ref<RenderSequenceData> sequenceData = passData.data.sequenceDataObj;
  stats.push( StatisticRecord( Statistic_Name, this.data.getName( sequenceData.data ) ) );
  stats.push( StatisticRecord( Statistic_Category, "RTR" ) );
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.data.getMemUsage() ) );
  return stats;
}

struct ShaderUniformValueData {
  Object transformedValue;
  ParamDataGenerator generator;
  Size alternateNameIndex;
};

struct TargetKeys {
  RenderValueKey key;
  UInt8 instanceStored;
};

const Integer AttachmentType_colorTexture = 0;
const Integer AttachmentType_colorRenderBuffer = 1;
const Integer AttachmentType_depthTexture = 2;
const Integer AttachmentType_depthRenderBuffer = 3;
const Integer AttachmentType_depthStencilRenderBuffer = 4;
const Integer AttachmentType_depthCubeTexture = 5;
const Integer AttachmentType_depthTextureArray = 6;
const Integer AttachmentType_depth3DTexture = 7;

const UInt8 Member_needViewFlag = 1;
const UInt8 Member_needProjFlag = 2;
const UInt8 Member_needPrimTransfoFlag = 4;

struct TextureClearValues {
  Boolean hasClearColor;
  Color color;
  Boolean hasClearDepth;
  Scalar depth;
};

struct ApplyMemberData {
  Boolean initialized;
  Ref<Object> sequenceApplyDataObj;//Should be Ref<ApplyDataObj> but circular type references don't compile
  Size instanceIndex;
  Size primIndex;
  UInt32 groupVersion;

  Boolean noDraw;
  UInt32 uniqueIndex;

  Integer memberSpecificUpdateInterval;
  Integer memberSpecificCullFace;

  Ref<Object> memberSubPassObj;//Should be set if no shader

  Ref<OGLShaderRenderParam> shaderParams;
  UInt32 shaderParamsValueVersion;
  Ref<OGLShaderProgram> shader;
  Boolean instancedShader;
  Ref<OGLShaderProgram> shaderVariation;
  String shaderVariationName_defines;
  String shaderVariationName_genericParams;
  String shaderVariationName;
  LocalL16UInt8Array shaderVariationGenericTypes;
  UInt32 useDefaultTexture;

  Integer geometryElementType;
  Integer drawInstanceCount;
  Size materialVariantIndex;
  Ref<OGLMaterial> lastMaterial;

  RenderParamVersionedKey sourceShaderParamKeys[];//Uniforms then Attributes then Textures
  ShaderUniformValueData shaderUniformValues[];//Filled only if space is not 'model' or 'none'
  RenderParamVersionedKey primTransformKey;
  RenderParamVersionedKey indicesParamKey;
  RenderParamVersionedKey shaderParamKey;
  RenderParamVersionedKey instanceCountParamKey;

  Ref<InstanceStoredData> instanceStoredData;
  Ref<InstanceStoredData> renderTargetInstanceStoredData;
  RenderValueKey framebufferKey;

  RenderParamValues bindingValues;//mostly render target related transforms
  TargetKeys bindingTargetKeys[];

  TextureClearValues renderTargetClearValues[];
  TextureClearValues refineRenderTargetClearValues[];

  RenderParams allParams;
  InstanceLayersCache instanceLayersCache;
  Size firstMemberLayerForBindings;
  UInt64 usedShaderParamLayerBits;
  UInt64 usedTransfoLayerBits;
  UInt32 lastAllParamsLayoutVersion;

  Boolean skipBecauseOfUpdateInterval;

  Integer sourceMaterialPrimitive;
  DebugContext debugContext;

  Size generationCount;
};

function Size ApplyMemberData.getMemUsage() {
  //very approximative; hopefully KL will add a built-in getMemUsage()
  return  4*48 //size, bool, pointers
            + this.shaderVariationGenericTypes.size()
            + 4*5* ( 4 + this.sourceShaderParamKeys.size() ) //versioned keys
            + 4*5* this.shaderUniformValues.size() //todo: take param values into account
            + 8* this.bindingTargetKeys.size()
            + 7*4* ( this.renderTargetClearValues.size() + this.refineRenderTargetClearValues.size() )
            + this.allParams.getMemUsage_withoutRenderParamValues()
            + this.instanceLayersCache.getMemUsage();
}

struct ClearTextureFunctions {
  PackedMemberValueOrFunctionVersionedKeys clearColorFunctionBindings;
  PackedMemberValueOrFunctionVersionedKeys clearDepthFunctionBindings;
  Boolean hasClearColor;
  Boolean hasClearDepth;
};

struct ClearTextureFunctions {
  PackedMemberValueOrFunctionVersionedKeys clearColorFunctionBindings;
  PackedMemberValueOrFunctionVersionedKeys clearDepthFunctionBindings;
  Boolean hasClearColor;
  Boolean hasClearDepth;
};

function Size ClearTextureFunctions.getMemUsage() {
  return 4 + this.clearColorFunctionBindings.getMemUsage() + this.clearDepthFunctionBindings.getMemUsage();
}

struct DynamicTextureFunctions {
  PackedMemberValueOrFunctionVersionedKeys widthFunctionBindings;
  PackedMemberValueOrFunctionVersionedKeys heightFunctionBindings;
  PackedMemberValueOrFunctionVersionedKeys depthFunctionBindings;
  PackedMemberValueOrFunctionVersionedKeys sourceFunctionBindings;

  ClearTextureFunctions clearFunctions;
};

function Size DynamicTextureFunctions.getMemUsage() {
  return this.widthFunctionBindings.getMemUsage()
    + this.heightFunctionBindings.getMemUsage() 
    + this.depthFunctionBindings.getMemUsage() 
    + this.sourceFunctionBindings.getMemUsage() 
    + this.clearFunctions.getMemUsage();
}

struct RefineTextureTargetInfo {
  Integer subIndex;
  Integer colorAttachIndex;
  Boolean isDepth;

  ClearTextureFunctions clearFunctions;
};

function Size RefineTextureTargetInfo.getMemUsage() {
  return 3*4 + this.clearFunctions.getMemUsage();
}

struct ApplyData {
  Ref<Object> selfObj; //ApplyDataObj
  Ref<Object> sequencePassDataObj;

  Ref<GroupDataObj> group;//Owner instance only if 0
  Boolean inheritedGroup;//if groupIndex == 0
  Boolean inheritedSubGroup;
  Size memberSourceGroupMapping[];
  Ref<Object> applySubPassObj;//If not per member

  Boolean membersDoSomething;
  Size groupGenerationCount;

  Size sourcePassApplyIndex;

  Boolean isElse;
  Boolean transformSpace;
  Boolean shaderDraw;

  Size sequencePassOrder;

  Boolean hasClearDepth;
  Boolean hasDynamicClearDepth;

  Boolean hasClearColor;
  Boolean hasDynamicClearColor;

  Boolean disablesDepthWrites;
  Integer depthFunc;
  Boolean hasPolygonOffset;
  Scalar polygonOffsetFactor;
  Scalar polygonOffsetUnits;
  Boolean hasBlend;
  Integer blendModeSfactor;
  Integer blendModeDfactor;

  Integer ownedFramebufferID;

  Size applySourcePassIndex;
  Boolean perMemberPass;
  ApplyMemberData applyMembersData[];

  PackedMemberValueOrFunctionVersionedKeys memberFunctionBindings[];
  String bindingTargetNames[];
  Integer bindingTargetSpaces[];
  Boolean hasBindingTargetSpaces;
  Boolean hasDynamicBindings;
  Boolean hasPerMemberFunctionBindings;
  Boolean hasStoredBindings;
  Boolean hasFeedbackBindings;
  Boolean hasRequestBindings;
  UInt32 requestID;

  RefineTextureTargetInfo refineTextureTargetInfos[];

  PackedMemberValueOrFunctionVersionedKeys memberDrawCallbackFunctions[];
  Boolean isPreDrawCallback[];
  Boolean hasDynamicDrawCallbackArgs;
  Boolean hasPerMemberDrawCallbackArgs;
  Boolean hasPreDrawCallback;
  Boolean hasPostDrawCallback;

  //TODO: optimize texture size changes...
  Boolean hasDynamicSizedTextureTarget;
  Boolean hasSharedRenderTargets;
  DynamicTextureFunctions dynamicTextureFunctions[];

  Boolean hasDynamicUpdateInterval;
  Boolean hasPerMemberUpdateInterval;
  PackedMemberValueOrFunctionVersionedKeys memberUpdateIntervalFunctionBindings;
  Integer defaultUpdateInterval;

  Boolean inheritsCullFace;
  Boolean hasDynamicCullFace;
  Boolean hasPerMemberCullFace;
  Boolean parentHasDynamicCullFace;
  PackedMemberValueOrFunctionVersionedKeys memberCullFaceFunctionBindings;
  Integer defaultCullFace;

  Integer implicitGeometry;

  Boolean hasFlags;
  Boolean flagsOpsResult;
  UInt32 flagBits;
  UInt32 flagLastParamsTopoVersion;

  Boolean hasCondition;
  PackedMemberValueOrFunctionVersionedKeys conditionFunctionKeys;
  Boolean conditionResult;
  Boolean disabled;

  InstanceLayersCache ownerInstanceLayers;
  RenderParams parentParamsWithOwnerInstanceLayers;

  RenderParamValues passValues;
  RenderParamVersionedKey transformKey;
  RenderParamKey viewTransformKey;
  RenderParamKey invViewTransformKey;
  RenderParamVersionedKey projectionKey;
  RenderValueKey invProjectionKey;
  Boolean projectionChanged;
  Boolean viewTransfoChanged;

  Size generationCount;

  UInt64 profileStart;
  UInt64 profileEnd;
  Boolean needsDebugContext;
  Boolean membersNeedDebugContext;
  DebugContext debugContext;
};

function Size ApplyData.getMemUsage() {
  //very approximative; hopefully KL will add a built-in getMemUsage()
  Size mem = 74*4 //size, pointers, bool
        + this.memberSourceGroupMapping.size()
        + 8* this.bindingTargetNames.size()
        + 4* this.bindingTargetSpaces.size()
        + this.isPreDrawCallback.size()
        + this.memberUpdateIntervalFunctionBindings.getMemUsage()
        + this.memberCullFaceFunctionBindings.getMemUsage()
        + this.conditionFunctionKeys.getMemUsage()
        + this.ownerInstanceLayers.getMemUsage()
        + this.parentParamsWithOwnerInstanceLayers.getMemUsage_withoutRenderParamValues()
        + 2*4*5; // versioned keys

  if( this.passValues )
    mem += this.passValues.getMemUsage_withoutParamValues();

  for( Size i = 0; i < this.applyMembersData.size(); ++i )
    mem += this.applyMembersData[i].getMemUsage();

  for( Size i = 0; i < this.memberFunctionBindings.size(); ++i )
    mem += this.memberFunctionBindings[i].getMemUsage();

  for( Size i = 0; i < this.refineTextureTargetInfos.size(); ++i )
    mem += this.refineTextureTargetInfos[i].getMemUsage();

  for( Size i = 0; i < this.memberDrawCallbackFunctions.size(); ++i )
    mem += this.memberDrawCallbackFunctions[i].getMemUsage();

  for( Size i = 0; i < this.dynamicTextureFunctions.size(); ++i )
    mem += this.dynamicTextureFunctions[i].getMemUsage();

  return mem;
}


//We wrap the ApplyData in an Object so itself remains a struct,
//which avoids the numerous "is obj null" checks in functions
//while running unguarded (the struct is passed in)
object ApplyDataObj : StatisticSourceWithAutoRegisterMember {
  ApplyData data;
  Size poolIndex;

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

function StatisticRecord[] ApplyDataObj.getStatistics() {
  StatisticRecord stats[];
  Ref<SequencePassDataObj> passData = this.data.sequencePassDataObj;
  Ref<RenderSequenceData> sequenceData = passData.data.sequenceDataObj;
  stats.push( StatisticRecord( Statistic_Name, this.data.getName( sequenceData.data ) ) );
  stats.push( StatisticRecord( Statistic_Category, "RTR" ) );
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.data.getMemUsage() ) );
  return stats;
}

struct InstanceStoredDataInfo {
  Ref<ApplyDataObj> sequenceApplyData;//0: viewport render target
  Size memberIndex;
};

struct SequencePassData {
  Boolean initialized;
  Ref<Object> parentSequencePassObj;
  Ref<Object> sequenceDataObj;

  Ref<ApplyDataObj> parentSequenceApplyOp;
  Size parentApplyOpMemberIndex;
  Size sourcePassIndex;
  LocalL16UInt32Array passOrderStack;

  Size ownerInstanceIndex;
  Size ownerPrimIndex;
  Versions lastOwnerPrimVersion;

  Size numParamLayers;

  Ref<GroupDataObj> privatePerMemberPassGroup;
  Ref<GroupDataObj> groupDatas[];
  Ref<ApplyDataObj> applyDatas[];

  Size generationCount;

  UInt64 profileStart;
  UInt64 profileEnd;
};

//We wrap the SequencePassData in an Object so itself remains a struct,
//which avoids the numerous "is obj null" checks in functions
//while running unguarded (the struct is passed in)
object SequencePassDataObj {
  SequencePassData data;
  Size poolIndex;
};

struct ApplyOpSequenceElement {
  Ref<ApplyDataObj> applyData;
  Boolean onlyPostDrawCallbacks;
};

struct RenderSequenceDataStruct {

  RenderData renderData;

  //Aliases from renderData (simplicity + performance)
  PrimitiveData renderDataPrimitives[];
  InstanceData renderDataInstances[];
  OGLRenderPass renderDataPasses[];
  PassFunctionKeys renderDataPassFunctionKeys[];

  String startPassName;
  Size startPassIndex;

  Size prevInstanceCount;
  Size generationCount;
  Size renderDataLayoutGenerationCount;

  _RTRUserCallbackFunctions functionCaller;

  Size globalParamsLayerStart;
  Size globalParamsLayerEnd;

  RenderParamKey viewportWidthKey;
  RenderParamKey viewportHeightKey;
  
  // RenderValueKey viewportBackgroundColorKey;
  UInt32 targetDrawBuffer;

  GroupDataObj groupsData[];
  IndexPool groupsDataIndexPool;

  InstanceStoredData instanceStoredDataPool[];
  IndexPool instanceStoredDataIndexPool;

  ApplyDataObj applyOpsData[];
  IndexPool applyOpsDataIndexPool;

  UInt32 nextApplyMemberDataUniqueIndex;

  SequencePassDataObj passesData[];
  IndexPool passesDataIndexPool;

  InstanceStoredDatas instancesStoredData[];

  ApplyOpSequenceElement applyOpsSequence[];
  OGLTexture2D texturesToAllocate[];
  OGLTexture2D texturesToRelease[];
  Integer framebuffersToRelease[];

  RenderParams initialParams;

  Boolean wrongGLVersion;
  Boolean pureGL32;

  UInt32 nextRequestID;

  //Reused temporary data (reused to avoid mem allocs).
  //User must clean its bits/values after usage.
  BitVector tempInstanceBits1;
  BitVector tempInstanceBits2;
  BitVector tempInstanceBits3;
  UInt32 tempInstanceValues[];//Default = InvalidIndex
  IndexSet tempIndexSet;
  BitVector tempBitArrayRefs[];
  UInt32 tempSizeOneIntegerArray[];//Avoid allocating constantly for gl calls

  Boolean enableProfiling;
  Boolean enableStatistics;

  Ref<StatisticSource> selfStats;
  Ref<Object> selfObj;
};

object RenderSequenceData : StatisticSourceWithAutoRegisterMember {
  RenderSequenceDataStruct data;

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

function Size RenderSequenceDataStruct.getMemUsage() {
  //very approximative; hopefully KL will add a built-in getMemUsage()
  Size mem = 54*4 //int, bool, pointers
          + 8*this.groupsData.size()
          + this.groupsDataIndexPool.getMemUsage()
          + 8*this.instanceStoredDataPool.size()
          + this.instanceStoredDataIndexPool.getMemUsage()
          + 8*this.applyOpsData.size()
          + this.applyOpsDataIndexPool.getMemUsage()
          + 8*this.passesData.size()
          + this.passesDataIndexPool.getMemUsage()
          + 3*4* this.applyOpsSequence.size()
          + 8* this.texturesToAllocate.size()
          + 8* this.texturesToRelease.size()
          + 4* this.framebuffersToRelease.size()
          + this.initialParams.getMemUsage_withoutRenderParamValues()
          + this.tempInstanceBits1.getMemUsage()
          + this.tempInstanceBits2.getMemUsage()
          + this.tempInstanceBits3.getMemUsage()
          + 4* this.tempInstanceValues.size()
          + this.tempIndexSet.getMemUsage();

  for( Size i = 0; i < this.instancesStoredData.size(); ++i )
    mem += this.instancesStoredData[i].getMemUsage();

  for( Size i = 0; i < this.tempBitArrayRefs.size(); ++i )
    mem += this.tempBitArrayRefs[i].getMemUsage();

  return mem;
}

function RenderSequenceDataStruct() {
  this.targetDrawBuffer = GL_FRONT;
}

function StatisticRecord[] RenderSequenceData.getStatistics() {
  StatisticRecord stats[];
  stats.push( StatisticRecord( Statistic_Name, "RenderSequence" ) );
  stats.push( StatisticRecord( Statistic_Category, "RTR" ) );
  stats.push( StatisticRecord( Statistic_MemoryUsage, this.data.getMemUsage() ) );
  return stats;
}

inline GroupDataObj.initStats!( RenderSequenceDataStruct sequenceData ) {
  if( sequenceData.enableStatistics ) {
    if( !this.autoStats )
      this.autoStats = StatisticsAutoRegisterMember(this);
    else
      this.autoStats.postCloneRefresh(this);
    Ref<SequencePassDataObj> parentPass = this.data.sequencePassDataObj;
    if( parentPass.data.parentSequenceApplyOp ) {
      Ref<ApplyDataObj> applyData = parentPass.data.parentSequenceApplyOp;
      AddStatisticsChild(applyData.autoStats, this.autoStats);
    } else {
      Ref<RenderSequenceData> sequenceDataObj = sequenceData.selfObj;
      AddStatisticsChild(sequenceDataObj.autoStats, this.autoStats);
    }
  }
}

inline ApplyDataObj.initStats!( RenderSequenceDataStruct sequenceData ) {
  if( sequenceData.enableStatistics ) {
    if( !this.autoStats )
      this.autoStats = StatisticsAutoRegisterMember(this);
    else
      this.autoStats.postCloneRefresh(this);
    Ref<SequencePassDataObj> parentPass = this.data.sequencePassDataObj;
    if( parentPass.data.parentSequenceApplyOp ) {
      Ref<ApplyDataObj> applyData = parentPass.data.parentSequenceApplyOp;
      AddStatisticsChild(applyData.autoStats, this.autoStats);
    } else {
      Ref<RenderSequenceData> sequenceDataObj = sequenceData.selfObj;
      AddStatisticsChild(sequenceDataObj.autoStats, this.autoStats);
    }
  }
}

object GroupDataObj : StatisticSourceWithAutoRegisterMember {
  GroupData data;
  Size poolIndex;

  //Statistics
  StatisticsAutoRegisterMember autoStats;
};

inline Boolean PackedMemberValueOrFunctionVersionedKeys.isValid() {
  return this.sharedKeys.isValid;
}

inline Boolean PackedMemberValueOrFunctionVersionedKeys.isDynamic() {
  return this.numBindingsPerMember != 0 || this.sharedKeys.parentBindingBits != 0 || this.sharedKeys.globalBindingBits != 0;
}

inline Boolean PackedMemberValueOrFunctionVersionedKeys.hasMemberBindings() {
  return this.numBindingsPerMember != 0;
}

inline Boolean PackedMemberValueOrFunctionVersionedKeys.hasFunctionCall() {
  return this.sharedKeys.functionID != InvalidIndex;
}

function PackedMemberValueOrFunctionVersionedKeys.initialize!( ValueOrFunctionKeyDefinition originalKeys, Ref<_RTRUserCallbackFunctions> functionCaller, Boolean ignoreMemberBindings ) {
  this.functionCaller = functionCaller;
  this.sharedKeys = originalKeys;
  this.ignoreMemberBindings = ignoreMemberBindings;

  if(this.sharedKeys.memberBindingBits != 0 || this.sharedKeys.bindingBits != 0)
    this.sharedKeys.keys = originalKeys.keys.clone();

  Size numKeys = this.sharedKeys.keys.size();
  this.memberBindingsAreOnlyTransfoOrLocalBVol = true;
  for( Size i = 0; i < numKeys; ++i ) {
    if( getBit( this.sharedKeys.memberBindingBits, i ) ) {
      if( !ignoreMemberBindings ) {
        ++this.numBindingsPerMember;
        if( !getBit( this.sharedKeys.transformBindingBits, i ) && !getBit( this.sharedKeys.localBoundingVolumeBindingBits, i ) )
          this.memberBindingsAreOnlyTransfoOrLocalBVol = false;
      }
    } else if( getBit( this.sharedKeys.bindingBits, i ) ) {
      ++this.numBindingsPerMember;
      this.memberBindingsAreOnlyTransfoOrLocalBVol = false;//Might come from passes too
    }
    else if( getBit( this.sharedKeys.parentBindingBits, i ) || getBit( this.sharedKeys.globalBindingBits, i ) )
      ++this.numParentBindings;
  }
}

inline PackedMemberValueOrFunctionVersionedKeys.initialize!( ValueOrFunctionKeyDefinition originalKeys, Ref<_RTRUserCallbackFunctions> functionCaller ) {
  this.initialize( originalKeys, functionCaller, false );
}

inline PackedMemberValueOrFunctionVersionedKeys.resize!( Size numMembers ) {
  this.numMembers = numMembers;
  this.packedMemberBindings.resize( numMembers * this.numBindingsPerMember );
}

inline PackedMemberValueOrFunctionVersionedKeys.moveMember!( UInt32 oldIndex, UInt32 newIndex ) {
  for( Size i = 0; i < this.numBindingsPerMember; ++i )
    this.packedMemberBindings[ newIndex*this.numBindingsPerMember + i ] = this.packedMemberBindings[ oldIndex*this.numBindingsPerMember + i ];
}

inline PackedMemberValueOrFunctionVersionedKeys.resetMember!( UInt32 index ) {
  RenderParamVersionedKey defaultKey;
  for( Size i = 0; i < this.numBindingsPerMember; ++i )
    this.packedMemberBindings[ index*this.numBindingsPerMember + i ] = defaultKey;
}

//synchronizePassParams: returns 'true' if something changed
inline PackedMemberValueOrFunctionVersionedKeys.synchronizePassParams!( RenderSequenceDataStruct sequenceData, RenderParams parentParams, Boolean initialize ) {
  if( !this.isDynamic() || this.numParentBindings == 0 ) {
    if(initialize)
      this.passParamsGenerationCount = sequenceData.generationCount;
    return;
  }
  Boolean somethingChanged = initialize;

  Size numKeys = this.sharedKeys.keys.size();
  for( Size i = 0; i < numKeys; ++i ) {
    Boolean parentBinding = getBit( this.sharedKeys.parentBindingBits, i );
    Boolean globalBinding = getBit( this.sharedKeys.globalBindingBits, i );
    if( parentBinding || globalBinding ) {
      if( this.sharedKeys.keys[i].synchronize( parentParams, this.sharedKeys.paramNames[i], sequenceData.globalParamsLayerStart, parentBinding ? parentParams.getNumLayers() : sequenceData.globalParamsLayerEnd ) )
        somethingChanged = true;

      if( initialize && !this.sharedKeys.keys[i].isValid() && !getBit( this.sharedKeys.isFlagBits, i ) )
        throw( (parentBinding ? "parent" : "global")+" source parameter not found: "+ this.sharedKeys.paramNames[i] +" in params "+parentParams.getLayersDesc()+(this.sharedKeys.functionName ? (" for function "+this.sharedKeys.functionName) : "" ) );
    }
  }
  if( somethingChanged )
    this.passParamsGenerationCount = sequenceData.generationCount;
}

//synchronizeMemberParams: returns 'true' if something changed. Note: if nothing changed, this.sharedKeys.keys won't be set properly to call the function, unless forceSetKeys == true
inline Boolean PackedMemberValueOrFunctionVersionedKeys.synchronizeMemberParams!( RenderSequenceDataStruct sequenceData, Size memberIndex, RenderParams allParams, UInt32 firstMemberLayer, UInt32 lastMemberLayer, Boolean initialize ) {
  if( this.numBindingsPerMember == 0 )
    return false;

  Boolean somethingChanged = false;
  Size offset = memberIndex * this.numBindingsPerMember;
  Size currBindingIndex;
  Size numKeys = this.sharedKeys.keys.size();
  for( Size i = 0; i < numKeys; ++i ) {

    if( getBit( this.sharedKeys.initializingBindingBits, i ) ) {
      RenderValueKey prev = this.packedMemberBindings[offset+currBindingIndex].key.valueKey;
      this.packedMemberBindings[offset+currBindingIndex] = initialize ? sequenceData.renderData.data.staticTrueKey : sequenceData.renderData.data.staticFalseKey;
      if( prev.index != this.packedMemberBindings[offset+currBindingIndex].key.valueKey.index )
        somethingChanged = true;

      ++currBindingIndex;
    } else {
      Boolean memberBinding = !this.ignoreMemberBindings && getBit( this.sharedKeys.memberBindingBits, i );
      Boolean noBinding = getBit( this.sharedKeys.bindingBits, i );
      if( memberBinding || noBinding ) {
        if( this.packedMemberBindings[offset+currBindingIndex].synchronize( allParams, this.sharedKeys.paramNames[i], memberBinding ? firstMemberLayer : sequenceData.globalParamsLayerStart, lastMemberLayer ) )
          somethingChanged = true;
        if( !this.packedMemberBindings[offset+currBindingIndex].isValid() && !getBit( this.sharedKeys.isFlagBits, i ) )
          throw( (memberBinding ? "member" : "")+" source parameter not found: "+ this.sharedKeys.paramNames[i] +" in params "+allParams.getLayersDesc()+(this.sharedKeys.functionName ? (" for function "+this.sharedKeys.functionName) : "" ) );

        ++currBindingIndex;
      }
    }
  }

  return somethingChanged;
}

inline PackedMemberValueOrFunctionVersionedKeys.prepareCallArgs?( Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, io LocalL16RenderParamVersionedKeyArray keys ) {
  Size offset = memberIndex * this.numBindingsPerMember;
  Size currBindingIndex;

  //Copy keys + add layer offset
  Size numKeys = this.sharedKeys.keys.size();
  keys.resize(numKeys);

  for( Size i = 0; i < numKeys; ++i ) {
    if( ( !this.ignoreMemberBindings && getBit( this.sharedKeys.memberBindingBits, i ) ) || getBit( this.sharedKeys.bindingBits, i ) ) {
      RenderParamVersionedKey key = this.packedMemberBindings[offset+currBindingIndex];
      keys.set( i, key );
      ++currBindingIndex;
    } else
      keys.set( i, this.sharedKeys.keys[i] );
  }
}

//getKeyIfSimpleBinding: returns an invalid key if not a simple binding
inline RenderParamVersionedKey PackedMemberValueOrFunctionVersionedKeys.getKeyIfSimpleBinding?( Size memberPrimLayerDelta, Size memberIndex ) {
  RenderParamVersionedKey key;//Invalid by default
  if( this.sharedKeys.functionID == InvalidIndex ) {
    if( this.numBindingsPerMember ) {
      Size offset = memberIndex * this.numBindingsPerMember;
      key = this.packedMemberBindings[offset];
    } else
      key = this.sharedKeys.keys[0];
  }
  return key;
}

inline PackedMemberValueOrFunctionVersionedKeys.callVoidFunction?( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext ) {
  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  this.functionCaller.callOGLRenderPassUservoidFunction( this.sharedKeys.functionID, allParams, debugContext, keys, initialize );
}

//Note: call[...] should only be called after .synchronizePassParams + .synchronizeMemberParams have been previously called, and only if they returned 'somethingChanged'
inline Boolean PackedMemberValueOrFunctionVersionedKeys.callBooleanFunction?( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext ) {
  RenderParamVersionedKey simpleBindingKey = this.getKeyIfSimpleBinding( memberPrimLayerDelta, memberIndex );
  if( simpleBindingKey.isValid() ) {
    Boolean result;
    allParams.get( simpleBindingKey.key, result, simpleBindingKey.elementIndex );
    return result;
  }

  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  return this.functionCaller.callOGLRenderPassUserBooleanFunction( this.sharedKeys.functionID, allParams, debugContext, keys, initialize );
}

inline Color PackedMemberValueOrFunctionVersionedKeys.callColorFunction?( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext ) {
  RenderParamVersionedKey simpleBindingKey = this.getKeyIfSimpleBinding( memberPrimLayerDelta, memberIndex );
  if( simpleBindingKey.isValid() ) {
    Color result;
    allParams.get( simpleBindingKey.key, result, simpleBindingKey.elementIndex );
    return result;
  }

  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  return this.functionCaller.callOGLRenderPassUserColorFunction( this.sharedKeys.functionID, allParams, debugContext, keys, initialize );
}

inline Scalar PackedMemberValueOrFunctionVersionedKeys.callScalarFunction?( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext ) {
  RenderParamVersionedKey simpleBindingKey = this.getKeyIfSimpleBinding( memberPrimLayerDelta, memberIndex );
  if( simpleBindingKey.isValid() ) {
    Scalar result;
    allParams.get( simpleBindingKey.key, result, simpleBindingKey.elementIndex );
    return result;
  }

  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  return this.functionCaller.callOGLRenderPassUserScalarFunction( this.sharedKeys.functionID, allParams, debugContext, keys, initialize );
}

inline Integer PackedMemberValueOrFunctionVersionedKeys.callIntegerFunction?( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext ) {
  RenderParamVersionedKey simpleBindingKey = this.getKeyIfSimpleBinding( memberPrimLayerDelta, memberIndex );
  if( simpleBindingKey.isValid() ) {
    Integer result;
    allParams.get( simpleBindingKey.key, result, simpleBindingKey.elementIndex );
    return result;
  }

  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  return this.functionCaller.callOGLRenderPassUserIntegerFunction( this.sharedKeys.functionID, allParams, debugContext, keys, initialize );
}

inline LocalBoundingVolume PackedMemberValueOrFunctionVersionedKeys.callLocalBoundingVolumeFunction?( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext ) {
  RenderParamVersionedKey simpleBindingKey = this.getKeyIfSimpleBinding( memberPrimLayerDelta, memberIndex );
  if( simpleBindingKey.isValid() ) {
    LocalBoundingVolume result;
    allParams.get( simpleBindingKey.key, result, simpleBindingKey.elementIndex );
    return result;
  }

  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  return this.functionCaller.callOGLRenderPassUserLocalBoundingVolumeFunction( this.sharedKeys.functionID, allParams, debugContext, keys, initialize );
}

inline Boolean PackedMemberValueOrFunctionVersionedKeys.callFunction( Boolean initialize, Size memberIndex, Size memberPrimLayerDelta, RenderParams allParams, DebugContext debugContext, io RenderParamValues targetValues, RenderValueKey targetKey ) {
  LocalL16RenderParamVersionedKeyArray keys;
  this.prepareCallArgs( memberIndex, memberPrimLayerDelta, allParams, keys );
  return this.functionCaller.callOGLRenderPassUserFunction( this.sharedKeys.functionID, allParams, debugContext, keys, targetValues, targetKey, initialize );
}

function Boolean PackedMemberValueOrFunctionVersionedKeys.updateMemberParamsAndStoreResult!( RenderSequenceDataStruct sequenceData, Size memberIndex, RenderParams allParams, DebugContext debugContext, UInt32 firstMemberAndPrimLayer, UInt32 lastMemberAndPrimLayer, io RenderParamValues storedValues, String bindingTargetName, io RenderValueKey targetKey, Boolean initialize ) {
  Boolean somethingChanged = this.synchronizeMemberParams( sequenceData, memberIndex, allParams, firstMemberAndPrimLayer, lastMemberAndPrimLayer, initialize );
  if( this.passParamsGenerationCount == sequenceData.generationCount || initialize )
    somethingChanged = true;

  RenderParamVersionedKey simpleBindingKey = this.getKeyIfSimpleBinding( firstMemberAndPrimLayer, memberIndex );
  if( initialize )
    targetKey = storedValues.getOrCreateKeyFromName( bindingTargetName );

  if( simpleBindingKey.isValid() ) {
    if( somethingChanged && targetKey.isValid() ) {
      storedValues.setFrom(allParams.layers[ simpleBindingKey.key.layerIndex ].params, simpleBindingKey.key.valueKey, allParams.layers[ simpleBindingKey.key.layerIndex ].elementIndex, targetKey);
    }
  } else {
    if( this.sharedKeys.functionID == InvalidIndex ) {
      //Constant value: just copy over from source, which is expected to be 1st static key
      if( initialize ) {
        RenderParamKey sourceKey = this.sharedKeys.keys[0].key;
        storedValues.setFrom(allParams.layers[ sourceKey.layerIndex ].params, sourceKey.valueKey, allParams.layers[ simpleBindingKey.key.layerIndex ].elementIndex, targetKey);
      }
    } else if( somethingChanged ) {
      //Call the function
      if( !this.callFunction( initialize, memberIndex, firstMemberAndPrimLayer, allParams, debugContext, storedValues, targetKey ) )
        somethingChanged = false;
    }
  }
  if( somethingChanged )
    storedValues.versions.incValue();

  return somethingChanged;
}


inline BitVector RenderDataStruct.updatePrimitivePerTypeFlagsCache!( String flag, Integer primitiveType, UInt32 primIndices[], io CachedFlags flags, io UInt32 flagsVersion ) {
  Size prevSize = flags.flags.size();
  Size size = primIndices.size();
  //report("Flags update begin: type="+ownerTypeToString(primitiveType)+" flag="+flag);//DEBUGPRINT
  if( prevSize != size ) {
    flags.flags.resize( size );
    ++flags.version;
    for( Size i = prevSize; i < size; ++i ) {
      Size primIndex = primIndices[i];
      if( primIndex != InvalidIndex ) {
        RenderParamKey flagKey = this.primitives[primIndex].params.getKey( flag );
        if( flagKey.isValid() ) {
          flags.flags.set(i);
          //report("Flags update: found "+this.getPrimitiveDesc(primIndex));//DEBUGPRINT
        }
      }
    }
  }
  flagsVersion = flags.version;
  return flags.flags;
}

inline BitVector RenderDataStruct.getPrimitivePerTypeFlagsRef!( String flag, Integer primitiveType, io UInt32 flagsVersion ) {
  return this.updatePrimitivePerTypeFlagsCache( flag, primitiveType, this.primitiveIndicesPerType[primitiveType], this.renderCaches.primitiveFlagsPerType[primitiveType][flag], flagsVersion );
}

function InstanceStoredDatas.updateInitialVersions!() {

  if( this.feedbackParams ) {
    if(this.feedbackParams.versions.value + 1 > this.initialVersions.value)
      this.initialVersions.value = this.feedbackParams.versions.value + 1;
    if(this.feedbackParams.versions.topo + 1 > this.initialVersions.topo)
      this.initialVersions.topo = this.feedbackParams.versions.topo + 1;
  }
  for( Size i = 0; i < this.data.size(); ++i ) {
    //Take the maximum: we want that new values can't have same version as older ones for this instance.
    if(this.data[i].params.versions.value + 1 > this.initialVersions.value)
      this.initialVersions.value = this.data[i].params.versions.value + 1;
    if(this.data[i].params.versions.topo + 1 > this.initialVersions.topo)
      this.initialVersions.topo = this.data[i].params.versions.topo + 1;
  }
  ++this.layoutOrderVersion;
}

function Ref<InstanceStoredData> InstanceStoredDatas.allocate!( io RenderSequenceDataStruct sequenceData ) {
  this.updateInitialVersions();

  Size poolIndex;
  Ref<InstanceStoredData> instDataRef = null;

  if( sequenceData.instanceStoredDataIndexPool.getFreeIndex( poolIndex ) ) {
    InstanceStoredData instData = InstanceStoredData();
    instData.poolIndex = poolIndex;
    instData.params = RenderParamValues();
    sequenceData.instanceStoredDataPool.push(instData);
    instDataRef = instData;
  } else
    instDataRef = sequenceData.instanceStoredDataPool[poolIndex];

  instDataRef.index = this.data.size();
  instDataRef.params.versions = this.initialVersions;
  instDataRef.params.ownerType = OwnerType_pass;
  instDataRef.params.ownerName = "inst"+this.instanceIndex+"."+instDataRef.index;

  this.data.push( instDataRef );
  return instDataRef;
}

inline RenderSequenceDataStruct.getViewportSize?( io Integer width, io Integer height ) {
  if( this.viewportWidthKey.isValid() )
    this.initialParams.get( this.viewportWidthKey, width );
  else
    width = 1;
  if( this.viewportWidthKey.isValid() )
    this.initialParams.get( this.viewportHeightKey, height );
  else
    height = 1;
}

function Boolean passOrderPrecedes( LocalL16UInt32Array first, Size firstPassOrder, LocalL16UInt32Array second, Size secondPassOrder ) {
  Size firstDepth = first.size();
  Size secondDepth = second.size();
  Size currLevel = 0;
  while( true ) {
    if( firstDepth < secondDepth && currLevel > firstDepth )
      return true;

    if( secondDepth < firstDepth && currLevel > secondDepth )
      return false;

    Size firstOrder = currLevel == firstDepth ? firstPassOrder : first.get(currLevel);
    Size secondOrder = currLevel == secondDepth ? secondPassOrder : second.get(currLevel);
    if( firstOrder < secondOrder )
      return true;
    if( firstOrder > secondOrder )
      return false;

    if( currLevel == firstDepth && currLevel == secondDepth )
      return false;

    ++currLevel;
  }
  return false;
}

function Boolean passOrderPrecedesWithCommonAncestor( LocalL16UInt32Array first, Size firstPassOrder, LocalL16UInt32Array second, Size secondPassOrder ) {
  Size firstDepth = first.size();
  Size secondDepth = second.size();
  if( firstDepth < secondDepth )
    return false;

  for( Size i = 0; i < secondDepth; ++i ) {
    if( first.get(i) != second.get(i) )
      return false;
  }
  Size firstBrother = (firstDepth == secondDepth) ? firstPassOrder : first.get(secondDepth);
  return firstBrother < secondPassOrder;
}

function String ApplyMemberData.getName?( RenderSequenceDataStruct sequenceData ) {
  Ref<ApplyDataObj> sequenceApplyData = this.sequenceApplyDataObj;
  return sequenceApplyData.data.getName(sequenceData) + ".member:"+sequenceData.renderData.data.getInstanceName(this.instanceIndex);
}

operator ConvertMat33Space( Index index, Mat33 sourceMat33[], Mat44 sourceMat44[], 
  Integer shaderSpace, Integer paramSpace, Integer usageHint, 
  Mat44 view, Mat44 projection, io Mat33 resultMat33[]) {

  Mat33 value;
  if( sourceMat33 )
    value = sourceMat33[index];
  else if( sourceMat44 ) {
    Mat44 sourceValue = sourceMat44[index];
    value = sourceValue.upperLeft().transpose();
  }
  
  if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_view )
    value = view.upperLeft() * value;
  else if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_viewProjection )
    value = projection.upperLeft() * (view.upperLeft() * value);

  if( usageHint == OGLShaderProgramUsageHint_normalTransform )
    value = value.inverse_safe().transpose();

  resultMat33[index] = value;
}

operator ConvertMat44Space( Index index, Mat44 sourceMat44[], 
  Integer shaderSpace, Integer paramSpace, Integer usageHint, 
  Mat44 view, Mat44 projection, io Mat44 resultMat44[]) {

  Mat44 value = sourceMat44[index];

  if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_view )
    value = view * value;
  else if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_viewProjection ) {
    value = projection * view * value;
    //report("Model: "+model+"\nView "+ view + "\nProj " + projection + "\nResult " + value);//DEBUGPRINT
  } else
    report("Warning: Unsupported Mat44 space transform from " + TransformSpaceToString(paramSpace) + " to  " + TransformSpaceToString(shaderSpace));

  resultMat44[index] = value;
}

function ApplyMemberData.updateShaderParams!( RenderSequenceDataStruct sequenceData, ApplyData applyData, Boolean viewTransfoChanged ) {

  Boolean somethingChanged = false;

  Size numDefines, numUniforms, numAttributes, numTextures, numOutputFragments;

  if( this.shaderParamKey.synchronize( this.allParams, sequenceData.renderData.data.shaderParamString ) ) {
    somethingChanged = true;
    this.allParams.get(this.shaderParamKey.key, this.shaderParams);
  }

  if( !this.shaderParamKey.isValid() )
    return;

  //Check if any shader param defaults have changed; in such case just mark as dirty (even if it might not be since overriden)
  if( synchronizeVersion( this.shaderParams.shaderDefaults.versions.value, this.shaderParamsValueVersion ) )
    somethingChanged = true;

  this.usedShaderParamLayerBits = 0;
  setBit( this.usedShaderParamLayerBits, this.shaderParamKey.key.layerIndex );

  Ref<OGLShaderProgram> shader = this.shaderParams.shader;
  numDefines = shader.defines.size();
  numUniforms = shader.uniforms.size();
  numAttributes = shader.attributes.size();
  numTextures = shader.textures.size();
  numOutputFragments = shader.outputFragments.size();

  if( shader !== this.shader ) {
    this.shader = shader;
    this.shaderVariation = null;
    this.shaderVariationName = '';
    this.shaderVariationName_defines = '';
    this.instancedShader = shader.instanced;

    this.shaderVariationGenericTypes.resize(0);
    Size totalParamCount = numDefines + numUniforms + numAttributes + numTextures + numOutputFragments;
    this.sourceShaderParamKeys.resize(0);//reset
    this.sourceShaderParamKeys.resize(totalParamCount);
    this.shaderUniformValues.resize(0);//reset
    this.shaderUniformValues.resize( numUniforms );
    somethingChanged = true;
  }
  Boolean definesChanged = somethingChanged;

  Boolean transformChanged = this.primTransformKey.synchronize( this.allParams, sequenceData.renderData.data.transformParamString );
  Mat44 model;
  Boolean modelInitialized = false;
  Mat44 view;
  Boolean modelViewInitialized = false;
  Mat44 projection;
  Boolean modelViewProjectionInitialized = false;
  UInt8 requiredTransfoFlags;

  Size offset = numDefines + numUniforms;
  for( Size i = 0; i < numAttributes; ++i ) {
    Size keyIndex = i + offset;
    Boolean initialize = !this.sourceShaderParamKeys[keyIndex].isValid();
    Boolean changed = this.sourceShaderParamKeys[keyIndex].synchronize( this.allParams, this.shader.attributes[i].name );
    if( !this.sourceShaderParamKeys[keyIndex].isValid() ) {
      if( this.shaderParams.shaderDefaults.get(RenderValueKey(keyIndex)) == null )
        throw( "Error: shader " + this.shader.name + ": attribute " + this.shader.attributes[i].name + " not found among parameters of instance " + this.getName( sequenceData ) );
    } else {
      if( initialize && !this.allParams.layers[this.sourceShaderParamKeys[keyIndex].key.layerIndex].params.isOGLBuffer(this.sourceShaderParamKeys[keyIndex].key.valueKey) )//TODO: validate numComponents
        throw( "Error: shader " + this.shader.name + ": attribute " + this.shader.attributes[i].name + " of instance " + this.getName( sequenceData ) + " is not an OpenGL attribute: " );
      if( changed )
        somethingChanged = true;
    }
    setBit( this.usedShaderParamLayerBits, this.sourceShaderParamKeys[keyIndex].key.layerIndex );
    //TODO: validate num components when 1st time initializing
  }

  offset = numDefines;

  Size genericParameterOffset;
  Boolean genericParamTypesChanged;

  for( Size i = 0; i < numUniforms; ++i ) {
    Size keyIndex = i + offset;

    Boolean initialize = !this.sourceShaderParamKeys[keyIndex].isValid();
    Boolean changed = initialize;

    RenderParamKey key;
    Boolean hasAlternateNames = Boolean(this.shader.uniforms[i].alternateNames);
    if( hasAlternateNames ) {
      Size prevIndex = this.shaderUniformValues[i].alternateNameIndex;
      changed |= this.sourceShaderParamKeys[keyIndex].synchronize( this.allParams, prevIndex == 0 ? this.shader.uniforms[i].name : this.shader.uniforms[i].alternateNames[prevIndex-1] );
      key = this.sourceShaderParamKeys[keyIndex].key;
      if( !key.isValid() ) {
        //Search among all names
        Size nameCount = this.shader.uniforms[i].alternateNames.size() + 1;
        for( Size j = 0; j < nameCount; ++j ) {
          if( j == prevIndex )
            continue;
          this.sourceShaderParamKeys[keyIndex] = RenderParamVersionedKey();//Needs to be reset if param name changed
          changed |= this.sourceShaderParamKeys[keyIndex].synchronize( this.allParams, j == 0 ? this.shader.uniforms[i].name : this.shader.uniforms[i].alternateNames[j-1] );
          key = this.sourceShaderParamKeys[keyIndex].key;
          if( key.isValid() ) {
            this.shaderUniformValues[i].alternateNameIndex = j;
            break;
          }
        }
      }
    } else {
      changed |= this.sourceShaderParamKeys[keyIndex].synchronize( this.allParams, this.shader.uniforms[i].name );
      key = this.sourceShaderParamKeys[keyIndex].key;
    }
    Boolean validKey = key.isValid();
    Boolean validParam = true;
    if( !validKey && this.shaderParams.shaderDefaults.get(RenderValueKey(keyIndex)) == null ) {
      validParam = false;
      if( !this.shader.uniforms[i].optional )
        throw( "Error: shader " + this.shader.name + ": uniform " + this.shader.uniforms[i].name + " not found among parameters of instance " + this.getName( sequenceData ) + " layers: " + this.allParams.getDesc() );
    }
    if( this.shader.hasGenericParameters && this.shader.uniforms[i].sourceType < 0 ) {
      if( changed && validParam ) {
        //Figure out the actual type
        Integer sourceType = OGLShaderProgram_uniformSource_uniform;
        Type paramType;
        Integer paramFlags;

        if(validKey) {
          paramType = this.allParams.layers[key.layerIndex].params.getType(key.valueKey);
          paramFlags = this.allParams.layers[key.layerIndex].params.getFlags(key.valueKey);
        } else {
          paramType = this.shaderParams.shaderDefaults.getType(RenderValueKey(keyIndex));
          paramFlags = this.shaderParams.shaderDefaults.getFlags(RenderValueKey(keyIndex));
        }

        if( paramType == OGLTexture2D ) {
          if( paramFlags & RenderParamFlag_OGLPackedInstances ) {
            sourceType = OGLShaderProgram_uniformSource_instancesTexture;
            this.instancedShader = true;
          } else {
            sourceType = OGLShaderProgram_uniformSource_texture;
            if( initialize && !this.sourceShaderParamKeys[this.shader.uniforms[i].genericTextureUVsAttributeIndex + numDefines + numUniforms].isValid() ) {
              throw( "Error: shader " + this.shader.name + ": generic texture param " + this.shader.uniforms[i].name + ": UVs parameter not found: "+this.shader.attributes[this.shader.uniforms[i].genericTextureUVsAttributeIndex].name );
            }
          }
        } else if( paramType == OGLBuffer ) {
          if( paramFlags & RenderParamFlag_OGLPackedInstances ) {
            sourceType = OGLShaderProgram_uniformSource_instancesAttribute;
            this.instancedShader = true;
          } else
            sourceType = OGLShaderProgram_uniformSource_attribute;
        }
        if( initialize ) {
          this.shaderVariationGenericTypes.push(UInt8(sourceType));
          genericParamTypesChanged = true;
        } else if( this.shaderVariationGenericTypes.get(genericParameterOffset) != UInt8(sourceType) ) {
          this.shaderVariationGenericTypes.set(genericParameterOffset, UInt8(sourceType));
          genericParamTypesChanged = true;
        }
      }
      ++genericParameterOffset;
    }

    if( validKey ) {
      if( changed )
        somethingChanged = true;

      setBit( this.usedShaderParamLayerBits, key.layerIndex );
      Integer glType = this.shader.uniforms[i].originalGlType;

      if( initialize ) {
        //Do some validation...
        //TODO: fix this once we have object inheritance in KL
        Type paramType = this.allParams.layers[key.layerIndex].params.getType(key.valueKey);
        if( paramType == OGLTexture2D || paramType == OGLBuffer ) {
          if( this.shader.uniforms[i].sourceType == OGLShaderProgram_uniformSource_uniform )
            throw( "Error: shader " + this.shader.name + ": generic uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader="+paramType+", param=" + paramType );
        } else if( glType == GL_INT || glType == GL_BOOL ) {
          if( paramType != IntegerRenderParam && paramType != BooleanRenderParam )
            throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader="+(glType == GL_BOOL ? "Boolean" : "Integer")+", param=" + paramType );
        } else if( glType == GL_FLOAT_VEC2 ) {
          if( paramType != Vec2RenderParam )
            throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader=Vec2, param=" + paramType );
        } else if( glType == GL_FLOAT_VEC3 ) {
          if( paramType != Vec3RenderParam )
            throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader=Vec3, param=" + paramType );
        } else if( glType == GL_FLOAT_VEC4 ) {
          if( paramType != Vec4RenderParam && paramType != ColorRenderParam )
            throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader=Vec4, param=" + paramType );
        } else if( glType == GL_FLOAT_MAT3 ) {
          if( paramType != Mat33RenderParam && paramType != Mat44RenderParam )
            throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader=Mat33, param=" + paramType );
        } else if( glType == GL_FLOAT_MAT4 ) {
          if( paramType != Mat44RenderParam )
            throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": type mismatch: shader=Mat44, param=" + paramType );
        }

        Size shaderCount= this.shader.uniforms[i].count;
        Size paramCount = 1;//TODO: support arrays properly
        if( shaderCount != paramCount )
          throw( "Error: shader " + this.shader.name + ": uniform " + this.shader.uniforms[i].name + ": count mismatch: shader=" + shaderCount + " params=" + paramCount );
      }
      if( changed || viewTransfoChanged || transformChanged ) {
        Integer shaderSpace = this.shader.uniforms[i].space;
        Integer paramSpace = this.allParams.getSpace( key );
        Boolean spaceChange = shaderSpace != TransformSpace_none && paramSpace != TransformSpace_none && shaderSpace != paramSpace;
        Integer usageHint = this.shader.uniforms[i].usageHint;
        if( spaceChange || (changed && usageHint != OGLShaderProgramUsageHint_none) ) {
          somethingChanged = true;

          if( (shaderSpace == TransformSpace_view || shaderSpace == TransformSpace_viewProjection) && !modelViewInitialized ) {
            modelViewInitialized = true;
            if( !applyData.invViewTransformKey.isValid() )
              throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": requires conversion but no parent pass with 'transformSpace': " + this.getName( sequenceData ) );

            this.allParams.get( applyData.invViewTransformKey, view );
            requiredTransfoFlags |= Member_needViewFlag;
          }

          if( (shaderSpace == TransformSpace_viewProjection) && !modelViewProjectionInitialized ) {
            modelViewProjectionInitialized = true;
            if( !applyData.projectionKey.isValid() )
              throw( "Error: shader " + this.shader.name + ": uniform param " + this.shader.uniforms[i].name + ": requires conversion but no parent pass with 'transformSpace': " + this.getName( sequenceData ) );
            this.allParams.get( applyData.projectionKey.key, projection );
            requiredTransfoFlags |= Member_needProjFlag;
          }

          if(this.allParams.getCategory(key) == RenderParamCategory_math) {
            if( !modelInitialized ) {
              modelInitialized = true;
              this.allParams.get( this.primTransformKey, model );
              requiredTransfoFlags |= Member_needPrimTransfoFlag;
            }

            //Todo: support arrays (count > 1)
            if( glType == GL_FLOAT_VEC3 ) {
              Vec3 value;
              this.allParams.get( key, value, this.sourceShaderParamKeys[keyIndex].elementIndex );

              if( usageHint == OGLShaderProgramUsageHint_none ) {
                //point
                if( paramSpace == TransformSpace_model && shaderSpace == TransformSpace_world )
                  value = model * value;
                else if ( paramSpace == TransformSpace_model && shaderSpace == TransformSpace_view )
                  value = view * (model * value);
                else if ( paramSpace == TransformSpace_model && shaderSpace == TransformSpace_viewProjection )
                  value = projection * (view * (model * value));
                else if (spaceChange)
                  report("Warning: Unsupported Vec3 space transform: "+TransformSpaceToString(paramSpace));
                Vec3RenderParam param = null;
                if(this.shaderUniformValues[i].transformedValue.type != Vec3RenderParam) {
                  param = Vec3RenderParam();
                  this.shaderUniformValues[i].transformedValue = param;
                } else
                  param = this.shaderUniformValues[i].transformedValue;
                if( param.set( value ) )
                  somethingChanged = true;
              } else {
                //normal or vector
                if( paramSpace == TransformSpace_model && shaderSpace == TransformSpace_world )
                  value = model.upperLeft() * value;
                else if ( paramSpace == TransformSpace_model && shaderSpace == TransformSpace_view )
                  value = view.upperLeft() * (model.upperLeft() * value);
                else if ( paramSpace == TransformSpace_model && shaderSpace == TransformSpace_viewProjection )
                  value = projection.upperLeft() * (view.upperLeft() * (model.upperLeft() * value));//Hum, not sure about this one...
                else if (spaceChange)
                  report("Warning: Unsupported Vec3 space transform: "+TransformSpaceToString(paramSpace));
                if( usageHint == OGLShaderProgramUsageHint_normalizedVector )
                  value.setUnit();
                Vec3RenderParam param = null;
                if(this.shaderUniformValues[i].transformedValue.type != Vec3RenderParam) {
                  param = Vec3RenderParam();
                  this.shaderUniformValues[i].transformedValue = param;
                } else
                  param = this.shaderUniformValues[i].transformedValue;
                if( param.set( value ) )
                  somethingChanged = true;
              }
            //TODO: vec4
            } else if( glType == GL_FLOAT_MAT3 ) {
              Mat33 value;
              if( this.allParams.layers[key.layerIndex].params.getType(key.valueKey) == Mat44RenderParam ) {
                //Convert...
                Mat44 value44;
                this.allParams.get( key, value44, this.sourceShaderParamKeys[keyIndex].elementIndex );
                value = value44.upperLeft();
              }
              else
                this.allParams.get( key, value, this.sourceShaderParamKeys[keyIndex].elementIndex );

              if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_view )
                value = view.upperLeft() * value;
              else if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_viewProjection )
                value = view.upperLeft() * (projection.upperLeft() * value);
              else if (spaceChange)
                report("Warning: Unsupported Mat33 space transform: "+TransformSpaceToString(paramSpace));

              if( usageHint == OGLShaderProgramUsageHint_normalTransform )
                value = value.inverse_safe().transpose();

              Mat33RenderParam param = null;
              if(this.shaderUniformValues[i].transformedValue.type != Mat33RenderParam) {
                param = Mat33RenderParam();
                this.shaderUniformValues[i].transformedValue = param;
              } else
                param = this.shaderUniformValues[i].transformedValue;
              if( param.set( value ) )
                somethingChanged = true;
            } else if( glType == GL_FLOAT_MAT4 ) {
              Mat44 value;
              this.allParams.get( key, value, this.sourceShaderParamKeys[keyIndex].elementIndex );

              if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_view )
                value = view * value;
              else if ( paramSpace == TransformSpace_world && shaderSpace == TransformSpace_viewProjection ) {
                value = projection * view * value;
                //report("Model: "+model+"\nView "+ view + "\nProj " + projection + "\nResult " + value);//DEBUGPRINT
              } else if (    paramSpace == TransformSpace_viewProjection && shaderSpace == TransformSpace_view 
                        && this.shader.uniforms[i].name == sequenceData.renderData.data.transformParamString ) {
                value = view * model;
              } else if (    paramSpace == TransformSpace_viewProjection && shaderSpace == TransformSpace_world 
                        && this.shader.uniforms[i].name == sequenceData.renderData.data.transformParamString ) {
                value = model;
              } else if (spaceChange)
                report("Warning: Unsupported Mat44 space transform from " + TransformSpaceToString(paramSpace) + " to  " + TransformSpaceToString(shaderSpace));

              Mat44RenderParam param = null;
              if(this.shaderUniformValues[i].transformedValue.type != Mat44RenderParam) {
                param = Mat44RenderParam();
                this.shaderUniformValues[i].transformedValue = param;
              } else
                param = this.shaderUniformValues[i].transformedValue;
              if( param.set( value ) )
                somethingChanged = true;
            }
          } else {
            // Generic per instance parameter
            Ref<RTRParamGenerator> generator = this.allParams.getParamGenerator(key);
            if( generator ) {
              //Implement matrix conversion
              Boolean asTexture;
              Ref<RTRAttributeWrapper> sourceAttributeWrapper = null;

              if( generator.type == OGLTexture2DFromAttributeGenerator ) {
                asTexture = true;
                Ref<OGLTexture2DFromAttributeGenerator> texGenerator = generator;
                sourceAttributeWrapper = texGenerator.sourceAttributeWrapper;
              } else if( generator.type == OGLBufferFromAttributeGenerator ) {
                Ref<OGLBufferFromAttributeGenerator> buffGenerator = generator;
                sourceAttributeWrapper = buffGenerator.sourceAttributeWrapper;
              }

              Ref<RTRAttributeWrapper> resultAttributeWrapper = null;
              if( this.shaderUniformValues[i].generator ) {
                if( this.shaderUniformValues[i].generator.generator.type == OGLTexture2DFromAttributeGenerator ) {
                  Ref<OGLTexture2DFromAttributeGenerator> texGenerator = this.shaderUniformValues[i].generator.generator;
                  resultAttributeWrapper = texGenerator.sourceAttributeWrapper;
                } else if( this.shaderUniformValues[i].generator.generator.type == OGLBufferFromAttributeGenerator ) {
                  Ref<OGLBufferFromAttributeGenerator> buffGenerator = this.shaderUniformValues[i].generator.generator;
                  resultAttributeWrapper = buffGenerator.sourceAttributeWrapper;
                }
              }

              Mat44 sourceMat44[];
              Mat33 sourceMat33[];
              Size count;

              if( sourceAttributeWrapper.type == Mat44_RTRAttributeWrapper ) {
                Ref<Mat44_RTRAttributeWrapper> mat44Wrapper = sourceAttributeWrapper;
                sourceMat44 = mat44Wrapper.a.values;
                count = sourceMat44.size();
              }
              if( glType == GL_FLOAT_MAT3 ) {
                if( sourceAttributeWrapper.type == Mat33_RTRAttributeWrapper ) {
                  Ref<Mat33_RTRAttributeWrapper> mat33Wrapper = sourceAttributeWrapper;
                  sourceMat33 = mat33Wrapper.a.values;
                  count = sourceMat33.size();
                }

                Mat33Attribute resultAttribute = null;
                if( resultAttributeWrapper ) {
                  Ref<Mat33_RTRAttributeWrapper> mat33Wrapper = resultAttributeWrapper;
                  resultAttribute = mat33Wrapper.a;
                } else
                  resultAttribute = Mat33Attribute();

                resultAttribute.resize(count);
                Mat33 resultMat33[] = resultAttribute.values;
                if( count > 200 )
                  ConvertMat33Space<<<count>>>( sourceMat33, sourceMat44, shaderSpace, paramSpace, usageHint, view, projection, resultMat33 );
                else {
                  for( Size j = 0; j < count; ++j )
                    ConvertMat33Space( j, sourceMat33, sourceMat44, shaderSpace, paramSpace, usageHint, view, projection, resultMat33 );
                }
                BuildInstanceOGLGenerator( asTexture, resultAttribute, this.shaderUniformValues[i].generator, this.shaderUniformValues[i].transformedValue );

              } else if( glType == GL_FLOAT_MAT4 ) {

                Mat44Attribute resultAttribute = null;
                if( resultAttributeWrapper ) {
                  Ref<Mat44_RTRAttributeWrapper> mat44Wrapper = resultAttributeWrapper;
                  resultAttribute = mat44Wrapper.a;
                } else
                  resultAttribute = Mat44Attribute();

                resultAttribute.resize(count);
                Mat44 resultMat44[] = resultAttribute.values;
                if( count > 200 )
                  ConvertMat44Space<<<count>>>( sourceMat44, shaderSpace, paramSpace, usageHint, view, projection, resultMat44 );
                else {
                  for( Size j = 0; j < count; ++j )
                    ConvertMat44Space( j, sourceMat44, shaderSpace, paramSpace, usageHint, view, projection, resultMat44 );
                }
                BuildInstanceOGLGenerator( asTexture, resultAttribute, this.shaderUniformValues[i].generator, this.shaderUniformValues[i].transformedValue );
              }
              this.shaderUniformValues[i].generator.dirty = true;
            }
          }
        }
      }
    }
  }

  if( transformChanged || viewTransfoChanged )//Else, we may not have computed all the transfo flags...
    this.usedTransfoLayerBits = 0;

  if(requiredTransfoFlags) {
    if(requiredTransfoFlags & Member_needPrimTransfoFlag)
      setBit( this.usedTransfoLayerBits, this.primTransformKey.key.layerIndex );
    if(requiredTransfoFlags & Member_needProjFlag)
      setBit( this.usedTransfoLayerBits, applyData.projectionKey.key.layerIndex );
    if(requiredTransfoFlags & Member_needViewFlag)
      setBit( this.usedTransfoLayerBits, applyData.invViewTransformKey.layerIndex );
  }
  this.usedShaderParamLayerBits |= this.usedTransfoLayerBits;

  if( numDefines != 0 || this.shader.hasGenericParameters ) {

    if( genericParamTypesChanged ) {
      //Build a concatenated version.
      //Minimize String allocation: take advantage of local String KL optimization.
      this.shaderVariationName_genericParams = '';
      for( Size i = 0; i < genericParameterOffset; ++i ) {
        Integer sourceType = this.shaderVariationGenericTypes.get(i);
        if( sourceType == OGLShaderProgram_uniformSource_instancesTexture )
          this.shaderVariationName_genericParams += '1';
        else if( sourceType == OGLShaderProgram_uniformSource_instancesAttribute )
          this.shaderVariationName_genericParams += '2';
        else if( sourceType == OGLShaderProgram_uniformSource_attribute )
          this.shaderVariationName_genericParams += '3';
        else if( sourceType == OGLShaderProgram_uniformSource_texture )
          this.shaderVariationName_genericParams += '4';
        else
          this.shaderVariationName_genericParams += '0';
      }
    }

    for( Size i = 0; i < numDefines; ++i ) {
      Boolean isFlag = this.shader.defines[i].glType == OGLShaderProgram_glType_flag;
      definesChanged = this.sourceShaderParamKeys[i].synchronize( this.allParams, this.shader.defines[i].name ) || definesChanged;
      if( !this.sourceShaderParamKeys[i].isValid() && !isFlag ) {
        if( this.shaderParams.shaderDefaults.get(RenderValueKey(i)) == null )
          throw( "Error: shader " + this.shader.name + ": define " + this.shader.defines[i].name + " not found among parameters of instance " + this.getName( sequenceData ) + " layers: " + this.allParams.getLayersDesc() );
      } else
        setBit( this.usedShaderParamLayerBits, this.sourceShaderParamKeys[i].key.layerIndex );
    }
    if( definesChanged ) {
      //Update shader variation string
      String shaderVariationName;
      for( Size i = 0; i < numDefines; ++i ) {
        shaderVariationName += '_';
        Boolean isFlag = this.shader.defines[i].glType == OGLShaderProgram_glType_flag;
        if( isFlag ) {
          Boolean flagValue = this.sourceShaderParamKeys[i].isValid();
          if( !flagValue )
            flagValue = Boolean(this.shaderParams.shaderDefaults.get(RenderValueKey(i)));
          shaderVariationName += flagValue ? 'd' : 'u';
        } else {
          Ref<Object> value = null;
          Size elementIndex;
          if( this.sourceShaderParamKeys[i].isValid() ) {
            value = this.allParams.get( this.sourceShaderParamKeys[i].key );
            elementIndex = this.sourceShaderParamKeys[i].elementIndex;
          } else
            value = this.shaderParams.shaderDefaults.get(RenderValueKey(i));

          Type paramType = value.type;
          if( paramType == IntegerRenderParam ) {
            Ref<IntegerRenderParam> param = value;
            Integer intValue;
            param.get(intValue, elementIndex);
            shaderVariationName += intValue;
          } else if( paramType == BooleanRenderParam ) {
            Ref<BooleanRenderParam> param = value;
            shaderVariationName += param.value;
          } else if( paramType == ScalarRenderParam ) {
            Ref<ScalarRenderParam> param = value;
            shaderVariationName += param.value;
          } else if( paramType == Vec2RenderParam ) {
            Ref<Vec2RenderParam> param = value;
            shaderVariationName += '('+param.value.x+','+param.value.y+')';
          } else if( paramType == Vec3RenderParam ) {
            Ref<Vec3RenderParam> param = value;
            shaderVariationName += '('+param.value.x+','+param.value.y+','+param.value.z+')';
          } else if( paramType == Vec4RenderParam ) {
            Ref<Vec4RenderParam> param = value;
            shaderVariationName += '('+param.value.x+','+param.value.y+','+param.value.z+','+param.value.t+')';
          } else if( paramType == ColorRenderParam ) {
            Ref<ColorRenderParam> param = value;
            shaderVariationName += '('+param.value.r+','+param.value.g+','+param.value.b+','+param.value.a+')';
          } else
            throw( "Error: shader " + this.shader.name + ": define " + this.shader.defines[i].name + " parameter has an unsupported type: " + paramType );
        }
      }
      definesChanged = shaderVariationName != this.shaderVariationName_defines;
      if( definesChanged )
        this.shaderVariationName_defines = shaderVariationName;
    }
    if( genericParamTypesChanged || definesChanged ) {
      if( genericParameterOffset && numDefines ) {//Being very careful about memory allocs..
        this.shaderVariationName = this.shaderVariationName_genericParams + this.shaderVariationName_defines;
      } else if( genericParameterOffset )
        this.shaderVariationName = this.shaderVariationName_genericParams;
      else
        this.shaderVariationName = this.shaderVariationName_defines;
      this.shaderVariation = this.shaderParams.shaderPreprocessorVariants.get( this.shaderVariationName, null );
      somethingChanged = true;
    }
  }
  else
    this.shaderVariation = shader;

  offset = numDefines + numUniforms + numAttributes;
  for( Size i = 0; i < numTextures; ++i ) {
    Size keyIndex = i + offset;
    Boolean initialize = !this.sourceShaderParamKeys[keyIndex].isValid();
    Boolean changed = this.sourceShaderParamKeys[keyIndex].synchronize( this.allParams, this.shader.textures[i].name );
    //test for explicit material flags that could shadow textures; exceptionally, specific textures may be set at the preset level...
    if( !this.sourceShaderParamKeys[keyIndex].isValid() || this.allParams.layers[this.sourceShaderParamKeys[keyIndex].key.layerIndex].params.isExplicitFlag(this.sourceShaderParamKeys[keyIndex].key.valueKey) ) {
      setBit( this.useDefaultTexture, i );
      if( this.shaderParams.shaderDefaults.get(RenderValueKey(keyIndex)) == null )
        throw( "Error: shader " + this.shader.name + ": texture " + this.shader.textures[i].name + " not found among parameters of instance " + this.getName( sequenceData ) );
    } else {
      clearBit( this.useDefaultTexture, i );
      if( initialize && !this.allParams.layers[this.sourceShaderParamKeys[keyIndex].key.layerIndex].params.isOGLTexture2D(this.sourceShaderParamKeys[keyIndex].key.valueKey) )//TODO: validate numComponents
        throw( "Error: shader " + this.shader.name + ": texture " + this.shader.textures[i].name + " of instance " + this.getName( sequenceData ) + " is not an OpenGL texture ");
      if( changed )
        somethingChanged = true;
    }
    setBit( this.usedShaderParamLayerBits, this.sourceShaderParamKeys[keyIndex].key.layerIndex );
    //TODO: validate num components when 1st time initializing
  }

  offset += numTextures;
  Boolean firstFragment = true;
  for( Size i = 0; i < numOutputFragments; ++i ) {
    Size keyIndex = i + offset;
    Boolean initialize = !this.sourceShaderParamKeys[keyIndex].isValid();
    Boolean changed = this.sourceShaderParamKeys[keyIndex].synchronize( this.allParams, this.shader.outputFragments[i].name );
    if( !this.sourceShaderParamKeys[keyIndex].isValid() ) {
      if( !this.shader.outputFragments[i].optional && !firstFragment ) {//firstFragment: Support potential 'default' attachment. Maybe we should ensure there's at least 1 color attachment...
        throw( "Error: shader " + this.shader.name + ": outputFragments " + this.shader.outputFragments[i].name + " not found among parameters of instance " + this.getName( sequenceData ) );
      }
    } else {

      if( initialize && !this.allParams.layers[this.sourceShaderParamKeys[keyIndex].key.layerIndex].params.isOGLTexture2D(this.sourceShaderParamKeys[keyIndex].key.valueKey) )//TODO: validate numComponents
        throw( "Error: shader " + this.shader.name + ": outputFragments " + this.shader.outputFragments[i].name + " of instance " + this.getName( sequenceData ) + " is not an OpenGL outputFragment " );
      if( changed )
        somethingChanged = true;
    }
    firstFragment = false;
    setBit( this.usedShaderParamLayerBits, this.sourceShaderParamKeys[keyIndex].key.layerIndex );
    //TODO: validate num components when 1st time initializing
  }
  if( this.indicesParamKey.synchronize( this.allParams, sequenceData.renderData.data.indicesString ) )
    somethingChanged = true;
  if( this.indicesParamKey.isValid() )
    setBit( this.usedShaderParamLayerBits, this.indicesParamKey.key.layerIndex );

  RenderParamVersionedKey instanceCountParamKey;

  if( this.instancedShader ) {//TODO: make that a condition of having instanced generic params variation
    if( this.instanceCountParamKey.synchronize( this.allParams, sequenceData.renderData.data.instanceCountString ) ) {
      somethingChanged = true;
      this.allParams.get( this.instanceCountParamKey, this.drawInstanceCount );
    } else if( !this.instanceCountParamKey.isValid() )
      throw( "Error: member " + this.getName( sequenceData ) + " defines no 'instanceCount' parameter for instanced shader " + this.shader.name );
    setBit( this.usedShaderParamLayerBits, this.instanceCountParamKey.key.layerIndex );
  }

  if( somethingChanged )
    this.generationCount = sequenceData.generationCount;
}

function String RenderSequenceDataStruct.getInstanceName?( Size index ) {
  //Cover the 'viewport' special case
  if( index==0 )
    return this.initialParams.layers[this.initialParams.getNumLayers()-1].params.ownerName;
  else
    return this.renderData.data.getInstanceName(index);
}

function String RenderSequenceDataStruct.getInstanceDesc?( Size index, Boolean reportType, Boolean reportIndex, Boolean reportParamLayers ) {
  //Cover the 'viewport' special case
  if( index == 0 ) {
    String desc = this.getInstanceName(index);
    if(reportType || reportIndex || reportParamLayers) {
      desc += " (";
      if(reportType)
        desc += ' type=viewport ';
      if(reportIndex)
        desc += ' index=[Prim:0,Inst:0]';
      if(reportParamLayers)
        desc += ' paramLayers='+this.initialParams.getLayersDesc();
      desc += " )";
    }
    return desc;
  } else
    return this.renderData.data.getInstanceDesc(index, reportType, reportIndex, reportParamLayers);
}

function String RenderSequenceDataStruct.getInstancesDesc?( String indent, Boolean reportIndices, Boolean reportParams, Boolean reportParamVersions, String typeFilters[] ) {
  String desc;
  //Cover the 'viewport' special case
  Boolean descViewport = typeFilters.size() == 0;
  if( typeFilters.size() ) {
    for( Size i = 0; i < typeFilters.size(); ++i ) {
      if( typeFilters[i] == "viewport" ) {
        descViewport = true;
        break;
      }
    }
  }
  if( descViewport ) {
    desc += indent; 
    if( reportIndices )
      desc += "0: ";
    desc += this.getInstanceDesc( 0, true, reportIndices, !reportParams )+"\n";
    if( reportParams )
      desc += this.initialParams.layers[this.initialParams.getNumLayers()-1].params.getDesc(indent + "  ", true, reportParamVersions, 0);
  }
  return desc + this.renderData.data.getInstancesDesc( indent, reportIndices, reportParams, reportParamVersions, typeFilters );
}

function String GroupData.getName( RenderSequenceDataStruct sequenceData ) {
  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Size sourcePassIndex = sequencePass.data.sourcePassIndex;
  return this.sourcePassGroupIndex == InvalidIndex ? (sequenceData.renderDataPasses[sourcePassIndex].name+"_OwnerGroup") : sequenceData.renderDataPasses[sourcePassIndex].groups[this.sourcePassGroupIndex].debugName;
}

function String GroupData.getDesc( RenderSequenceDataStruct sequenceData, String indent, Boolean reportMemberIndices, Boolean reportMemberNames, Boolean reportMemberParamLayers ) {
  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Size sourcePassIndex = sequencePass.data.sourcePassIndex;
  String groupName = this.sourcePassGroupIndex == InvalidIndex ? (sequenceData.renderDataPasses[sourcePassIndex].name+"_OwnerGroup") : sequenceData.renderDataPasses[sourcePassIndex].groups[this.sourcePassGroupIndex].debugName;
  Size numMembers = this.memberInstances.size();

  String desc = indent + "group " + groupName + " ownerPass=" + sequenceData.renderDataPasses[sourcePassIndex].name + " count=" + numMembers;
  if( reportMemberNames || reportMemberParamLayers ) {
    desc += "  members:\n";
    for( Size j = 0; j < numMembers; ++j )
      desc += indent + "  " + j + ": " + sequenceData.getInstanceDesc( this.memberInstances[j], true, reportMemberIndices, reportMemberParamLayers ) + "\n";
  } else if( reportMemberIndices ) {
    desc += " members=[";
    for( Size j = 0; j < numMembers; ++j ) {
      if(j)
        desc += ", ";
      desc += this.memberInstances[j];
    }
    desc += "] ";
  }
  return desc;
}

function String ApplyData.getName( RenderSequenceDataStruct sequenceData ) {
  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Size sourcePassIndex = sequencePass.data.sourcePassIndex;
  return sequenceData.renderDataPasses[sourcePassIndex].applyOps[this.sourcePassApplyIndex].passDebugName;
}

function String ApplyData.getDesc( RenderSequenceDataStruct sequenceData, String indent, Boolean reportGroupMemberIndices, Boolean reportGroupMemberNames, Boolean reportGroupMemberParamLayers ) {
  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Size sourcePassIndex = sequencePass.data.sourcePassIndex;
  String groupName = '';
  Size numMembers = 0;
  if( Boolean( this.group ) && this.group.data.sourcePassGroupIndex != InvalidIndex ) {
    Integer sourcePassGroupIndex = this.group.data.sourcePassGroupIndex;
    Ref<SequencePassDataObj> groupsSequencePass = this.group.data.sequencePassDataObj;
    Size sourceGroupPass = groupsSequencePass.data.sourcePassIndex;
    groupName = sequenceData.renderDataPasses[sourceGroupPass].groups[sourcePassGroupIndex].debugName;
    numMembers = this.group.data.memberInstances.size();
  } else {
    numMembers = 1;
    if(reportGroupMemberIndices || reportGroupMemberNames || reportGroupMemberParamLayers) {
      Size instanceIndex = sequencePass.data.ownerInstanceIndex;
      if( reportGroupMemberNames || reportGroupMemberParamLayers )
        groupName = sequenceData.getInstanceDesc( instanceIndex, true, reportGroupMemberIndices, reportGroupMemberParamLayers );
      else
        groupName = '['+instanceIndex+']';
    }
  }
  String desc = this.getName( sequenceData );
  if( Boolean(this.group) && (reportGroupMemberIndices || reportGroupMemberNames || reportGroupMemberParamLayers) )
    desc += '\n'+this.group.data.getDesc( sequenceData, "  "+indent, reportGroupMemberIndices, reportGroupMemberNames, reportGroupMemberParamLayers );
  else
    desc += " group=" + groupName + " count=" + numMembers + "\n";
  return desc;
}

inline Boolean evalFlagCondition( UInt32 flagBits, UInt8 flagOpsBits[] ) {
  Boolean flag = true;
  Size nbFlags = flagOpsBits.size();
  for( Size i = 0; i < nbFlags; ++i ) {
    if( flag && (flagOpsBits[i] & FlagOpsBits_or) != 0 )
      return true;//Found positive answer

    flag = getBit( flagBits, i );
    if( flagOpsBits[i] & FlagOpsBits_not )
      flag = !flag;

    if( !flag ) {
      //Skip all consecutive 'and'
      while( (i+1) < nbFlags && (flagOpsBits[i+1] & FlagOpsBits_and) != 0 )
        ++i;
    }
  }
  return flag;
}

function GroupData.init!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData ) {

  this.types = sequenceData.renderDataPasses[sequencePassData.sourcePassIndex].groups[this.sourcePassGroupIndex].types;
  Ref<GroupDataObj> sourceGroupData = this.sourceGroupDataObj;

  Size numTypes = sequenceData.renderDataPasses[sequencePassData.sourcePassIndex].groups[this.sourcePassGroupIndex].types.size();
  if( numTypes == 0 ) {
    if(sourceGroupData) {
      this.types = sourceGroupData.data.types;
      numTypes = this.types.size();
    }
    if( numTypes == 0 )
      numTypes = numOwnerTypes;
  }

  this.globalTransformAndLocalBVolVersionPerType.resize(numTypes);
  this.instanceListVersionPerType.resize(numTypes);

  this.flags = sequenceData.renderDataPasses[sequencePassData.sourcePassIndex].groups[this.sourcePassGroupIndex].flags;
  Size numFlags = this.flags.size();
  if( numFlags ) {
    this.flagOpsBits = sequenceData.renderDataPasses[sequencePassData.sourcePassIndex].groups[this.sourcePassGroupIndex].flagOpsBits;
    this.flagValueKeys.initialize( sequenceData.renderDataPassFunctionKeys[sequencePassData.sourcePassIndex].groupKeys[this.sourcePassGroupIndex].flagKeys, sequenceData.functionCaller, true );
    Size flagMemberBits = this.flagValueKeys.sharedKeys.memberBindingBits;
    this.flagMemberBits = flagMemberBits;
    Size numMemberFlags = 0;
    for( Size j = 0; j < numFlags; ++j ) {
      if( getBit( flagMemberBits, j ) )
        ++numMemberFlags;
    }
    this.flagsVersionPerType.resize(numTypes * numMemberFlags);
  }

  this.bVolCull = sequenceData.renderDataPassFunctionKeys[sequencePassData.sourcePassIndex].groupKeys[this.sourcePassGroupIndex].cullBoundingVolumeKeys.isValid;
  if( this.bVolCull ) {
    Size ownerPrimInstanceIndex = sequenceData.renderDataInstances[ sequencePassData.ownerInstanceIndex ].primInstanceIndex;
    this.transformKey.elementIndex = ownerPrimInstanceIndex;

    this.bVolCullFunctionKeys.initialize( sequenceData.renderDataPassFunctionKeys[sequencePassData.sourcePassIndex].groupKeys[this.sourcePassGroupIndex].cullBoundingVolumeKeys, sequenceData.functionCaller );
    if( this.bVolCullFunctionKeys.numBindingsPerMember ) {
      throw("Error: cullBoundingVolume can only bind to parameters with 'parent.' or 'global.' scopes");
    } else {
      if(   this.bVolCullFunctionKeys.isDynamic() 
        && !this.bVolCullFunctionKeys.hasFunctionCall() 
        &&  sequenceData.renderDataPassFunctionKeys[sequencePassData.sourcePassIndex].groupKeys[this.sourcePassGroupIndex].cullBoundingVolumeKeys.localBoundingVolumeBindingBits == 1 )
          this.bVolCullWithLocalBVol = true;
    }
  }

  this.hasCondition = sequenceData.renderDataPassFunctionKeys[sequencePassData.sourcePassIndex].groupKeys[this.sourcePassGroupIndex].conditionKeys.isValid;

  if( this.hasCondition )
    this.conditionFunctionKeys.initialize( sequenceData.renderDataPassFunctionKeys[sequencePassData.sourcePassIndex].groupKeys[this.sourcePassGroupIndex].conditionKeys, sequenceData.functionCaller );
}

inline Boolean GroupData.updateFlags( io Size flags, io GroupUpdateCachedMemberData cacheMemberData, Size cacheMemberIndex, Boolean initialize ) {
  //Build flag bits: merge from non-member params, member flag cache and other bindings
  Size bindingOffset = 0;
  for( Size k = 0; k < this.numFlags; ++k ) {
    if( getBit( this.flagValueKeys.sharedKeys.bindingBits, k ) )
      setBit( flags, k, this.flagValueKeys.packedMemberBindings[cacheMemberIndex*this.flagValueKeys.numBindingsPerMember + bindingOffset++].isValid() );
  }

  if( initialize || flags != cacheMemberData.cachedFlagBits ) {
    cacheMemberData.cachedFlagsResultValue = evalFlagCondition( flags, this.flagOpsBits );
    cacheMemberData.cachedFlagBits = flags;
  }

  return cacheMemberData.cachedFlagsResultValue;
}

function String RenderSequenceDataStruct.getInstanceDataCreatorName( Size instanceIndex, RenderParamValues paramValues ) {
  if( instanceIndex == 0 )
    return String();

  if( this.instancesStoredData[instanceIndex].feedbackParams === paramValues )
    return this.renderData.data.getInstanceName(instanceIndex)+'.feedbackParams';

  Size primIndex = this.renderDataInstances[instanceIndex].primIndex;
  for( Size i = 0; i < this.renderDataPrimitives[primIndex].params.getNumLayers(); ++i ) {
    if( paramValues === this.renderDataPrimitives[primIndex].params.layers[i].params ) {
      String instName = this.renderData.data.getInstanceName(instanceIndex);
      if( instName != paramValues.ownerName )
        return this.renderData.data.getInstanceName(instanceIndex)+'.sceneParams.'+paramValues.ownerName;
      else
        return paramValues.ownerName;
    }
  }

  for( Size i = 0; i < this.instancesStoredData[instanceIndex].data.size(); ++i ) {
    if( this.instancesStoredData[instanceIndex].data[i].params === paramValues ) {
      //Find the source pass name
      Ref<ApplyDataObj> applyData = this.instancesStoredData[instanceIndex].data[i].ownerApplyObj;
      Size memberIndex = this.instancesStoredData[instanceIndex].data[i].ownerApplyMemberIndex;
      return applyData.data.applyMembersData[ memberIndex ].getName(this);
    }
  }
  return String();
}

function ApplyData.fillDebugContext?( RenderSequenceDataStruct sequenceData, Size memberIndex, Size ownedLayersEnd, io DebugContext dc ) {
  if( ownedLayersEnd == 0)
    return;

  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Ref<ApplyDataObj> parentApplyData = sequencePass.data.parentSequenceApplyOp;

  Size inheritedGroupMemberIndex;
  if( this.inheritedGroup ) {
    if( this.inheritedSubGroup && this.memberSourceGroupMapping.size() != 0 ) //Not sure why this can be == 0; to debug )
      inheritedGroupMemberIndex = this.memberSourceGroupMapping[memberIndex];
    else
      inheritedGroupMemberIndex = memberIndex;
  } else if( parentApplyData )
    inheritedGroupMemberIndex = sequencePass.data.parentApplyOpMemberIndex;

  String selfName = this.getName(sequenceData);

  Size ownedLayersBegin = 3;
  if( parentApplyData )
    ownedLayersBegin = parentApplyData.data.applyMembersData[inheritedGroupMemberIndex].allParams.getNumLayers();

  for( Size i = ownedLayersBegin; i < ownedLayersEnd && i < dc.params.getNumLayers(); ++i ) {
    dc.paramPass[i] = selfName;
    dc.paramCreator[i] = sequenceData.getInstanceDataCreatorName(sequencePass.data.ownerInstanceIndex, dc.params.layers[i].params);
    if( !dc.paramCreator[i] )
      dc.paramCreator[i] = selfName;
  }

  if( parentApplyData )
    parentApplyData.data.applyMembersData[inheritedGroupMemberIndex].fillDebugContext( sequenceData, inheritedGroupMemberIndex, parentApplyData.data, ownedLayersBegin, dc );
  else {
    String startPassName = sequenceData.renderDataPasses[sequenceData.startPassIndex].name;
    dc.paramPass[2] = startPassName;//initial pass, always at layer 2
    dc.paramCreator[2] = 'Viewport';
    dc.callStack.push(startPassName);
  }
}

function ApplyMemberData.fillDebugContext?( RenderSequenceDataStruct sequenceData, Size memberIndex, ApplyData applyData, Size ownedLayersEnd, io DebugContext dc ) {
  Size ownedLayersBegin;
  Ref<SequencePassDataObj> sequencePass = applyData.sequencePassDataObj;
  Ref<ApplyDataObj> parentApplyData = sequencePass.data.parentSequenceApplyOp;

  if( applyData.inheritedGroup ) {
    Size inheritedGroupMemberIndex;
    if( applyData.inheritedSubGroup ) {
      inheritedGroupMemberIndex = applyData.memberSourceGroupMapping[memberIndex];
    } else
      inheritedGroupMemberIndex = memberIndex;
    ownedLayersBegin = parentApplyData.data.applyMembersData[inheritedGroupMemberIndex].allParams.getNumLayers();
  } else
    ownedLayersBegin = this.firstMemberLayerForBindings;

  String selfName = this.getName(sequenceData);
  for( Size i = ownedLayersBegin; i < ownedLayersEnd && i < dc.params.getNumLayers(); ++i ) {
    dc.paramPass[i] = selfName;
    dc.paramCreator[i] = sequenceData.getInstanceDataCreatorName(this.instanceIndex, dc.params.layers[i].params);
    if( !dc.paramCreator[i] )
      dc.paramCreator[i] = selfName;
  }

  applyData.fillDebugContext( sequenceData, memberIndex, ownedLayersBegin, dc );
  dc.callStack.push(selfName);
}

function DebugContext ApplyData.buildDebugContext( RenderSequenceDataStruct sequenceData, RenderParams params ) {

  DebugContext dc = DebugContext();
  dc.params = params;
  dc.paramPass.resize(params.getNumLayers());
  dc.paramCreator.resize(params.getNumLayers());

  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  this.fillDebugContext( sequenceData, sequencePass.data.parentApplyOpMemberIndex, params.getNumLayers(), dc );
  dc.callStack.push(this.getName(sequenceData));

  return dc;
}

function DebugContext ApplyMemberData.buildDebugContext( RenderSequenceDataStruct sequenceData, Size memberIndex, ApplyData applyData, Size paramsLayerCount ) {

  DebugContext dc = DebugContext();
  dc.params = this.allParams;
  dc.params.resize(paramsLayerCount, true);
  dc.paramPass.resize(paramsLayerCount);
  dc.paramCreator.resize(paramsLayerCount);

  this.fillDebugContext(sequenceData, memberIndex, applyData, paramsLayerCount, dc);

  return dc;
}

function DebugContext GroupData.buildDebugContext( io RenderSequenceDataStruct sequenceData, RenderParams params ) {
  DebugContext dc = DebugContext();
  dc.params = params;
  dc.paramPass.resize(params.getNumLayers());
  dc.paramCreator.resize(params.getNumLayers());

  String selfName = this.getName(sequenceData);

  //NOTE: in this case, it can happen that params.getNumLayers() < parentMember.allParams.getNumLayers(), in case we inherit from a group.
  Size ownedLayersBegin = 3;
  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Ref<ApplyDataObj> parentSequenceApplyOp = sequencePass.data.parentSequenceApplyOp;
  Size parentApplyOpMemberIndex;
  if( parentSequenceApplyOp ) {
    parentApplyOpMemberIndex = sequencePass.data.parentApplyOpMemberIndex;
    ownedLayersBegin = parentSequenceApplyOp.data.applyMembersData[parentApplyOpMemberIndex].allParams.getNumLayers();
  }

  for( Size i = ownedLayersBegin; i < params.getNumLayers(); ++i ) {
    dc.paramPass[i] = selfName;
    dc.paramCreator[i] = sequenceData.getInstanceDataCreatorName(sequencePass.data.ownerInstanceIndex, dc.params.layers[i].params);
    if( !dc.paramCreator[i] )
      dc.paramCreator[i] = selfName;
  }

  if( parentSequenceApplyOp )
    sequencePass.data.parentSequenceApplyOp.data.fillDebugContext( sequenceData, parentApplyOpMemberIndex, ownedLayersBegin, dc );
  else {
    String startPassName = sequenceData.renderDataPasses[sequenceData.startPassIndex].name;
    dc.paramPass[2] = startPassName;//initial pass, always at layer 2
    dc.paramCreator[2] = 'Viewport';
  }
  dc.callStack.push(selfName);

  return dc;
}

function DebugContext GroupData.buildDebugContext( io RenderSequenceDataStruct sequenceData, Size instanceIndex, Size sourceApplyOpMemberIndex, RenderParams params ) {
  DebugContext dc = DebugContext();
  dc.params = params;
  dc.paramPass.resize(params.getNumLayers());
  dc.paramCreator.resize(params.getNumLayers());

  String selfName = this.getName(sequenceData)+'.member:'+sequenceData.renderData.data.getInstanceName(instanceIndex);

  Size ownedLayersBegin = 3;
  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Ref<ApplyDataObj> parentSequenceApplyOp = sequencePass.data.parentSequenceApplyOp;
  if( parentSequenceApplyOp )
    ownedLayersBegin = parentSequenceApplyOp.data.applyMembersData[sourceApplyOpMemberIndex].allParams.getNumLayers();

  for( Size i = ownedLayersBegin; i < params.getNumLayers(); ++i ) {
    dc.paramPass[i] = selfName;
    dc.paramCreator[i] = sequenceData.getInstanceDataCreatorName(instanceIndex, dc.params.layers[i].params);
    if( !dc.paramCreator[i] )
      dc.paramCreator[i] = selfName;
  }

  if( parentSequenceApplyOp )
    sequencePass.data.parentSequenceApplyOp.data.fillDebugContext( sequenceData, sourceApplyOpMemberIndex, ownedLayersBegin, dc );
  else {
    String startPassName = sequenceData.renderDataPasses[sequenceData.startPassIndex].name;
    dc.paramPass[2] = startPassName;//initial pass, always at layer 2
    dc.paramCreator[2] = 'Viewport';
  }

  dc.callStack.push(selfName);

  return dc;
}

function GroupData.evaluateGroupMemberConditionAndFlag!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, Size typeIndex, Size instanceIndex, io GroupUpdateCachedMemberData cacheMemberData, Size cacheMemberIndex, io RenderParams tempSharedParams, RenderParams parentParams ) {

  Boolean keep = true;
  Boolean newMember = !cacheMemberData.initialized;
  cacheMemberData.initialized = true;
  UInt32 flags = this.nonMemberFlagBits;

  if( this.perMemberFlagCheck ) {
    //Build flag bits: merge from non-member params, member flag cache and other bindings
    Size primIndex = sequenceData.renderDataInstances[instanceIndex].primIndex;
    Size primPerTypeIndex = sequenceData.renderDataPrimitives[primIndex].primPerTypeIndex;

    Size flagOffset = 0;
    for( Size k = 0; k < this.numFlags; ++k ) {
      if( getBit( this.flagMemberBits, k ) )
        setBit( flags, k, sequenceData.tempBitArrayRefs[typeIndex*this.numFlags + flagOffset++].get(primPerTypeIndex) );
    }

    if( !this.perMemberFlagEval ) {
      //Optimization: early check if flags don't require dynamic bindings
      if( newMember || flags != cacheMemberData.cachedFlagBits ) {
        cacheMemberData.cachedFlagsResultValue = evalFlagCondition( flags, this.flagOpsBits );
        cacheMemberData.cachedFlagBits = flags;
      }
      if( !cacheMemberData.cachedFlagsResultValue )
        keep = false;
    }
  }
  if( keep && (this.perMemberFlagEval || this.perMemberCondition) ) {

    Boolean inheritedGroup = cacheMemberData.sourceGroupIndex != InvalidIndex;

    cacheMemberData.instanceLayersCache.update( sequenceData, instanceIndex, inheritedGroup, sequencePassData.passOrderStack, this.sequencePassOrder, null );
    Size numInstanceLayers = cacheMemberData.instanceLayersCache.layers.size();

    Size firstPrimLayer = inheritedGroup ? 
                              sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].firstMemberLayerForBindings
                            : parentParams.getNumLayers();

    if( inheritedGroup && numInstanceLayers == 0 ) {
      //SubGroup: take params from parent apply op.

      Size numParams = sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams.getNumLayers();

      //Important: test flags first, even before synchronizing condition member params: these might not be valid if flags fail
      if( this.perMemberFlagEval ) {
        this.flagValueKeys.synchronizeMemberParams( sequenceData, cacheMemberIndex, sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams, firstPrimLayer, numParams, newMember );
        keep = this.updateFlags( flags, cacheMemberData, cacheMemberIndex, newMember );
      }

      if( this.perMemberCondition && keep ) {
        Boolean conditionMemberParamsDirty = this.conditionFunctionKeys.synchronizeMemberParams( sequenceData, cacheMemberIndex, sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams, firstPrimLayer, numParams, !cacheMemberData.conditionInitialized );
        if( conditionMemberParamsDirty || this.conditionFunctionKeys.passParamsGenerationCount == sequenceData.generationCount ) {//reevaluate the condition
          DebugContext dc = null;
          if( this.conditionFunctionKeys.sharedKeys.needsDebugContext )
            dc = this.buildDebugContext( sequenceData, instanceIndex, cacheMemberData.sourceGroupIndex, sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams );
          cacheMemberData.cachedConditionValue = this.conditionFunctionKeys.callBooleanFunction( !cacheMemberData.conditionInitialized, cacheMemberIndex, firstPrimLayer, sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams, dc );
        }
        cacheMemberData.conditionInitialized = true;
      }
    } else {
      Size tempSharedParamsTopoVersionBackup = tempSharedParams.versions.topo;
      Size nextLayer;
      Size sourceApplyMemberIndex;

      if( inheritedGroup ) {
        nextLayer = parentParams.getNumLayers();
        sourceApplyMemberIndex = cacheMemberData.sourceGroupIndex;
        Size numPrimLayers = sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams.getNumLayers();
        for( Size k = nextLayer; k < numPrimLayers; ++k ) {
          tempSharedParams.setLayer_noVersionChange( nextLayer++, sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams.layers[k] );
          tempSharedParams.versions.topo += sequencePassData.parentSequenceApplyOp.data.applyMembersData[cacheMemberData.sourceGroupIndex].allParams.layers[k].params.versions.topo;
        }
        //TODO: add feedback params only if was not there... which is 1st frame only + if added by precedent same-ancestor pass

      } else {
        sourceApplyMemberIndex = sequencePassData.parentApplyOpMemberIndex;

        //Set prim layer refs
        nextLayer = firstPrimLayer;
        Size primIndex = sequenceData.renderDataInstances[instanceIndex].primIndex;
        Size numPrimLayers = sequenceData.renderDataPrimitives[primIndex].params.getNumLayers();
        for( Size k = 0; k < numPrimLayers; ++k ) {
          tempSharedParams.setLayer_noVersionChange( nextLayer++, sequenceData.renderDataPrimitives[primIndex].params.layers[k].params, sequenceData.renderDataInstances[instanceIndex].primInstanceIndex );
          tempSharedParams.versions.topo += sequenceData.renderDataPrimitives[primIndex].params.layers[k].params.versions.topo;
        }

        Ref<RenderParamValues> feedbackParams = sequenceData.instancesStoredData[instanceIndex].feedbackParams;
        if( feedbackParams ) {
          tempSharedParams.setLayer_noVersionChange( nextLayer++, feedbackParams, 0 );
          tempSharedParams.versions.topo += feedbackParams.versions.topo;
        }
      }

      //Set instance refs (if applicable)
      for( Size k = 0; k < cacheMemberData.instanceLayersCache.layers.size(); ++k ) {
        tempSharedParams.setLayer_noVersionChange( nextLayer++, cacheMemberData.instanceLayersCache.layers[k], 0 );
        tempSharedParams.versions.topo += cacheMemberData.instanceLayersCache.layers[k].versions.topo;
      }

      //TODO: setting those layers potentially make the keys 'falsely' dirty... TOFIX: otherwise a lookup will be made constantly!
      Size totalNumLayers = tempSharedParams.getNumLayers();

      //Reset the remaining layers if any
      while( nextLayer < totalNumLayers )
        tempSharedParams.resetLayer_noVersionChange( nextLayer++ );

      //Important: test flags first, even before synchronizing condition member params: these might not be valid if flags fail
      if( this.perMemberFlagEval ) {
        this.flagValueKeys.synchronizeMemberParams( sequenceData, cacheMemberIndex, tempSharedParams, firstPrimLayer, tempSharedParams.getNumLayers(), newMember );
        keep = this.updateFlags( flags, cacheMemberData, cacheMemberIndex, newMember );
      }

      if( this.perMemberCondition && keep ) {
        Boolean conditionMemberParamsDirty = this.conditionFunctionKeys.synchronizeMemberParams( sequenceData, cacheMemberIndex, tempSharedParams, firstPrimLayer, tempSharedParams.getNumLayers(), !cacheMemberData.conditionInitialized );
        if( conditionMemberParamsDirty || this.conditionFunctionKeys.passParamsGenerationCount == sequenceData.generationCount ) {//reevaluate the condition
          DebugContext dc = null;
          if( this.conditionFunctionKeys.sharedKeys.needsDebugContext )
            dc = this.buildDebugContext( sequenceData, instanceIndex, sourceApplyMemberIndex, tempSharedParams );
          cacheMemberData.cachedConditionValue = this.conditionFunctionKeys.callBooleanFunction( !cacheMemberData.conditionInitialized, cacheMemberIndex, firstPrimLayer, tempSharedParams, dc );
        }
        cacheMemberData.conditionInitialized = true;
      }

      tempSharedParams.versions.topo = tempSharedParamsTopoVersionBackup;
    }

    if( this.perMemberCondition && !cacheMemberData.cachedConditionValue )
        keep = false;

  }
  cacheMemberData.keep = keep;
}

operator ParallelEvaluateGroupMemberConditionAndFlag<<<index>>>( Size batchSize, io GroupData group, io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, Size typeIndex, Size type, UInt32 instanceIndices[], RenderParams parentParams ) {
  RenderParams params;
  Size numParentLayers = parentParams.getNumLayers();
  for( Size i = 0; i < numParentLayers; ++i )
    params.setLayer( i, parentParams.layers[i] );

  Size start = index*batchSize;
  Size end = start + batchSize;
  if( end > instanceIndices.size() )
    end = instanceIndices.size();

  for( Size i = start; i < end; ++i ) {
    UInt32 instanceIndex = instanceIndices[i];
    if(sequenceData.renderDataPrimitives[ sequenceData.renderDataInstances[instanceIndex].primIndex ].ownerType == type) {
      Size memberCacheIndex = sequenceData.tempInstanceValues[instanceIndex];
      group.evaluateGroupMemberConditionAndFlag(sequenceData, sequencePassData, typeIndex, instanceIndex, group.groupUpdateCachedMemberData[memberCacheIndex], memberCacheIndex, params, parentParams);
    }
  }
}


function GroupData.update!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, Ref<GroupDataObj> thisObj, RenderParams parentParams ) {
  //This function is quite complex, mostly because it is very optimized toward frequent scenarios.
  //First, when building a group, it will try to apply filtering in the best order, to minimize the overall computation cost.
  //Second, it need to build a 'diff' map between previous elements and new ones, and build 'patch' information about how
  //to shuffle optimally the different elements (added or removed).
  //Third, it handles building a group as a complement of another one, or starting from a source set...
//report("GROUP "+this.getName( renderData, sequenceData )+" layersDesc "+parentParams.getLayersDesc());
  if( sequenceData.enableProfiling )
    this.profileStart = getCurrentTicks();

  Ref<SequencePassDataObj> sequencePass = this.sequencePassDataObj;
  Size sourcePass = sequencePass.data.sourcePassIndex;

  Boolean recompute = false;
  Boolean initialize = false;
  Boolean isComplementGroup = false;

  Boolean computeSourceGroupMappings = false;
  Ref<GroupDataObj> sourceGroupData = this.sourceGroupDataObj;
  if( sourceGroupData ) {
    Ref<GroupDataObj> complementGroup = sourceGroupData.data.complementGroupDataObj;
    if( complementGroup === thisObj ) {
      isComplementGroup = true;
      Ref<GroupDataObj> unionGroupData = sourceGroupData.data.sourceGroupDataObj;
      if( synchronizeVersion( unionGroupData.data.generationCount, this.unionGroupDataGenerationCount ) )
        recompute = true;
    }
    if( synchronizeVersion( sourceGroupData.data.generationCount, this.sourceGroupDataGenerationCount ) )
      recompute = true;

    if( !recompute && sourceGroupData.data.memberInstances.size() == 0 ) {
      if( sequenceData.enableProfiling )
        this.profileEnd = getCurrentTicks();
      return;
    }
    computeSourceGroupMappings = (isComplementGroup || !this.complementGroupDataObj) && this.subGroup;//If there is a complement group, do it there.
  }

  Size numTypes = this.types.size();
  Boolean anyType = numTypes == 0;
  if( anyType )
    numTypes = numOwnerTypes;

  //Check if new instances have been added
  if( Boolean(sourceGroupData) || !anyType ) {
    for( Size i = 0; i < numTypes; ++i ) {
      Integer type = anyType ? i : this.types[i];
      UInt32 version = this.instanceListVersionPerType.get(i);
      if( synchronizeVersion( sequenceData.renderData.data.primitivesListVersionPerType[type], version ) ) {
        this.instanceListVersionPerType.set(i, version);
        recompute = true;
        initialize = true;
        this.conditionInitialized = false;
      }
    }
  }

  Boolean keepNone = false;


  Size numMemberFlags;

  Size tempBitArraysNbToReset;

  LocalBoundingVolume localBVol;
  Boolean bVolCull;

  if( !isComplementGroup ) {
    Boolean recomputeIfLBVolOrTransfoMightChange = false;

    //Important: test flags first, even before synchronizing condition member params: these might not be valid if flags fail
    if( this.flags.size() ) {
      this.perMemberFlagEval = this.flagValueKeys.hasMemberBindings();
      this.perMemberFlagCheck = this.perMemberFlagEval || this.flagMemberBits != 0;

      if( this.flagValueKeys.isDynamic() ) {
        if( this.flagValueKeys.hasMemberBindings() )
          recompute = true;

        this.flagValueKeys.synchronizePassParams( sequenceData, parentParams, initialize );
      }
      //Update non-member flags
      this.numFlags = this.flagValueKeys.sharedKeys.keys.size();
      UInt32 nonMemberFlagBits;
      if( initialize || this.flagValueKeys.passParamsGenerationCount == sequenceData.generationCount ) {
        UInt32 nonMemberBits = this.flagValueKeys.sharedKeys.parentBindingBits | this.flagValueKeys.sharedKeys.globalBindingBits;
        for( Size i = 0; i < this.numFlags; ++i ) {
          if( getBit( nonMemberBits, i ) ) {
            setBit( nonMemberFlagBits, i, this.flagValueKeys.sharedKeys.keys[i].isValid() );
          }
        }
        if( nonMemberFlagBits != this.nonMemberFlagBits || initialize ) {
          if( this.perMemberFlagCheck )
            recompute = true;//OPTIMIZE: eval global-only subportions? Eg: (global.X and member.Y): if global.X is false -> can set to false without evaluating member.Y
          else {
            //Eval global flags and compare result
            Boolean globalFlagResult = evalFlagCondition( nonMemberFlagBits, this.flagOpsBits );
            if( globalFlagResult != this.globalFlagResult ) {
              this.globalFlagResult = globalFlagResult;
              recompute = true;
            }
          }
          this.nonMemberFlagBits = nonMemberFlagBits;
        }
      }
      if( !this.perMemberFlagCheck && !this.globalFlagResult )
        keepNone = true;

      if( this.flagMemberBits ) {
        //Flags are cached globally at the members' level
        //Fetch required flag caches, and reuse sequenceData.tempBitArrayRefs to avoid mallocs
        Size numMemberFlagsAndTypes = this.flagsVersionPerType.size();
        tempBitArraysNbToReset = numMemberFlagsAndTypes;
        if( sequenceData.tempBitArrayRefs.size() < tempBitArraysNbToReset )
          sequenceData.tempBitArrayRefs.resize(tempBitArraysNbToReset);

        Size index = 0;
        for( Size i = 0; i < numTypes; ++i ) {
          numMemberFlags = 0;
          Integer type = anyType ? i : this.types[i];

          for( Size j = 0; j < this.numFlags; ++j ) {
            if( getBit( this.flagMemberBits, j ) ) {
              ++numMemberFlags;
              UInt32 flagsVersion;
              Ref<RenderCaches> caches = sequenceData.renderData.data.renderCaches;//Trick KL "const"
              sequenceData.tempBitArrayRefs[index] = sequenceData.renderData.data.getPrimitivePerTypeFlagsRef( this.flagValueKeys.sharedKeys.paramNames[j], type, flagsVersion );
              UInt32 version = this.flagsVersionPerType.get(index);
              if( synchronizeVersion( flagsVersion, version ) ) {
                this.flagsVersionPerType.set(index, version);
                recompute = true;
              }
              ++index;
            }
          }
        }
      }
    }

    if( this.hasCondition && !keepNone ) {
      if( this.conditionFunctionKeys.isDynamic() ) {
        this.conditionFunctionKeys.synchronizePassParams( sequenceData, parentParams, !this.conditionInitialized );
        if( this.conditionFunctionKeys.hasMemberBindings() && this.conditionFunctionKeys.passParamsGenerationCount == sequenceData.generationCount )
          recompute = true;

        if( this.conditionFunctionKeys.hasMemberBindings() ) {
          this.perMemberCondition = true;
          if( this.conditionFunctionKeys.memberBindingsAreOnlyTransfoOrLocalBVol )
            recomputeIfLBVolOrTransfoMightChange = true;
          else
            recompute = true;
        }
      }
      if( !this.conditionFunctionKeys.hasMemberBindings() ) {
        if(!this.conditionInitialized || this.conditionFunctionKeys.passParamsGenerationCount == sequenceData.generationCount) {
          DebugContext dc;
          if( this.conditionFunctionKeys.sharedKeys.needsDebugContext )
            dc = this.buildDebugContext( sequenceData, parentParams );
          Boolean globalConditionResult = this.conditionFunctionKeys.callBooleanFunction( !this.conditionInitialized, 0, parentParams.getNumLayers(), parentParams, dc );
          if( globalConditionResult != this.globalConditionResult ) {
            this.globalConditionResult = globalConditionResult;
            recompute = true;
          }
        }
        if( !this.globalConditionResult )
          keepNone = true;
      }
      this.conditionInitialized = true;
    }

    bVolCull = this.bVolCull && sequenceData.renderData.data.renderCaches.gridActive;

    if( bVolCull ) {
      Boolean transfoChanged = this.transformKey.synchronize( parentParams, sequenceData.renderData.data.transformParamString );
      if( transfoChanged )
        recompute = true;

      if( this.bVolCullWithLocalBVol ) {
        if( this.localBVolKey.synchronize( parentParams, sequenceData.renderData.data.localBVolParamString ) )
          recompute = true;
        if( this.localBVolKey.isValid() )
          parentParams.get( this.localBVolKey.key, localBVol );
      } else {
        //Evaluate the BVol, and compare...
        this.bVolCullFunctionKeys.synchronizePassParams( sequenceData, parentParams, initialize );
        if( this.bVolCullFunctionKeys.passParamsGenerationCount == sequenceData.generationCount ) {

          DebugContext dc;
          if( this.bVolCullFunctionKeys.sharedKeys.needsDebugContext )
            dc = this.buildDebugContext( sequenceData, parentParams );

          LocalBoundingVolume newBoundingVolume = this.bVolCullFunctionKeys.callLocalBoundingVolumeFunction( initialize, 0, 0, parentParams, dc );
          if( !this.bVolCullFunctionResult.equal(newBoundingVolume) ) {
            this.bVolCullFunctionResult = newBoundingVolume;
            recompute = true;
          }
        }
        if( transfoChanged )
          recompute = true;
        localBVol = this.bVolCullFunctionResult;
      }

      if( localBVol.type == LocalBoundingVolume_infinite || ( localBVol.type == LocalBoundingVolume_bSphere && localBVol.sc1 < 0 ) )
        bVolCull = false;
    }

    if( bVolCull || recomputeIfLBVolOrTransfoMightChange ) {
      for( Size i = 0; i < numTypes; ++i ) {
        Integer type = anyType ? i : this.types[i];
        UInt32 version = this.globalTransformAndLocalBVolVersionPerType.get(i);
        if( synchronizeVersion( sequenceData.renderData.data.globalTransformAndLocalBVolVersionPerType[type], version ) ) {
          this.globalTransformAndLocalBVolVersionPerType.set(i, version);
          recompute = true;
        }
      }
    }
  }

  Boolean hadChanges = false;
  if( recompute ) {

    this.memberTypeFlags = 0;

    //Mark previous members
    Size prevNumMembers = this.memberInstances.size();
    for( Size i = 0; i < prevNumMembers; ++i )
      sequenceData.tempInstanceBits1.set(this.memberInstances[i]);

    Size nextMember = prevNumMembers;

    if( isComplementGroup ) {
      // In this case, no filtering; just take a complement from the sourceGroup and its own sourceGroup.
      Ref<GroupDataObj> unionGroupData = sourceGroupData.data.sourceGroupDataObj;

      UInt32 sourceGroupDataMemberInstances[] = sourceGroupData.data.memberInstances;

      Size numInstances = sourceGroupDataMemberInstances.size();
      for( Size i = 0; i < numInstances; ++i )
        sequenceData.tempInstanceBits3.set( sourceGroupDataMemberInstances[i] );

      UInt32 unionGroupDataMembers[] = unionGroupData.data.memberInstances;
      numInstances = unionGroupDataMembers.size();
      for( Size i = 0; i < numInstances; ++i ) {
        Size instanceIndex = unionGroupDataMembers[i];
        if( !sequenceData.tempInstanceBits3.get(instanceIndex) ) {

          setBit( this.memberTypeFlags, sequenceData.renderDataPrimitives[ sequenceData.renderDataInstances[instanceIndex].primIndex ].ownerType );
          Boolean wasMember = sequenceData.tempInstanceBits1.getThenSet(instanceIndex);
          sequenceData.tempInstanceBits2.set(instanceIndex);

          if( !wasMember ) {
            hadChanges = true;
            UInt32 member = this.memberInstances.size();
            this.memberInstances.resize( member + 1 );
            this.memberInstances[ member ] = instanceIndex;
          }
        }
      }

      //Bit cleanup
      numInstances = sourceGroupDataMemberInstances.size();
      for( Size i = 0; i < numInstances; ++i )
        sequenceData.tempInstanceBits3.clear( sourceGroupDataMemberInstances[i] );
    } else if( !keepNone ) {
      Mat44 transform;
      if( bVolCull )
        parentParams.get( this.transformKey, transform );

      if( this.perMemberFlagCheck || this.perMemberCondition ) {
        //Mark previous members
        for( Size i = 0; i < this.groupUpdateCachedMemberData.size(); ++i )
          sequenceData.tempInstanceValues[this.groupUpdateCachedMemberData[i].instanceIndex] = i;
      }

      //The current strategy tries to minimize global computation cost (but make things more complex):
      //Filter order, based on cost & reduce efficiency:
      // 1) by sourceGroup indices (if any)
      // 2) by type
      // 4) by volume culling (if applicable: requires to build a mask from all the criteria above, in the same order)
      // 5) by flags (if any) and conditions (if any)
      //Note: this could still be improved a lot, but it's ok for current typical scenarios...

      for( Size i = 0; i < numTypes; ++i ) {
        //TODO: perform culling in parallel at the same time. Cull only if transfoChanged or instance transfo changed (synch).
        Integer type = anyType ? i : this.types[i];
        Size numInstances;

        if( sourceGroupData ) {
          if( !getBit( sourceGroupData.data.memberTypeFlags, type ) )
            continue;
        }
        UInt32 instanceIndices[];
        Boolean checkInstanceType;
        Boolean indicesFromSourceGroup;
        if( bVolCull ) {

          //1) Update grid hierarchy
          Ref<RenderCaches> renderCaches = sequenceData.renderData.data.renderCaches;//Trick KL "const"
          Size nbUpdates = renderCaches.octreePerType[type].update( renderCaches.gridCurrentFrameCellUpdateBudgetBeforeDraw );
          setBit( renderCaches.gridTypesToUpdateBits, type );

          if( nbUpdates >= renderCaches.gridCurrentFrameCellUpdateBudgetBeforeDraw )
            renderCaches.gridCurrentFrameCellUpdateBudgetBeforeDraw = 0;
          else
            renderCaches.gridCurrentFrameCellUpdateBudgetBeforeDraw -= nbUpdates;

          //2) If sourceGroupData, first build a mask
          //TODO: have per-type-instance numbering for flags + Octree objects
          if( sourceGroupData ) {

            UInt32 sourceGroupDataMemberInstances[] = sourceGroupData.data.memberInstances;
            numInstances = sourceGroupDataMemberInstances.size();

            for( Size j = 0; j < numInstances; ++j ) {
              UInt32 instanceIndex;
              instanceIndex = sourceGroupDataMemberInstances[j];
              if( sequenceData.renderDataPrimitives[ sequenceData.renderDataInstances[instanceIndex].primIndex ].ownerType == type )
                sequenceData.tempInstanceBits3.set( instanceIndex );
            }
            renderCaches.octreePerType[type].localBVolQuery( transform, localBVol, sequenceData.tempIndexSet, sequenceData.tempInstanceBits3 );
            //Cleanup...
            for( Size j = 0; j < numInstances; ++j ) {
              UInt32 instanceIndex = sourceGroupDataMemberInstances[j];
              sequenceData.tempInstanceBits3.clear( instanceIndex );
            }
          } else
            renderCaches.octreePerType[type].localBVolQuery( transform, localBVol, sequenceData.tempIndexSet );

          instanceIndices = sequenceData.tempIndexSet.indices;
          numInstances = sequenceData.tempIndexSet.size();

          //report(("Cull type="+ ownerTypeToString(type)+" ResultIndices="+ sequenceData.tempIndexSet.indices);
        } else if(sourceGroupData) {
          instanceIndices = sourceGroupData.data.memberInstances;
          numInstances = instanceIndices.size();
          checkInstanceType = true;
          indicesFromSourceGroup = true;
        } else {
          instanceIndices = sequenceData.renderData.data.instanceIndicesPerType[type];
          numInstances = instanceIndices.size();
        }

        //Allocate entries to make it multithread-safe
        if(this.perMemberFlagCheck || this.perMemberCondition) {
          for( Size j = 0; j < numInstances; ++j ) {
            UInt32 instanceIndex = instanceIndices[j];
            if(checkInstanceType && sequenceData.renderDataPrimitives[ sequenceData.renderDataInstances[instanceIndex].primIndex ].ownerType != type)
                continue;

            //tempInstanceBits3: if condition and/or flag was tested
            sequenceData.tempInstanceBits3.set(instanceIndex);

            //Check if it was a member; if not, allocate one
            Boolean newMember = false;
            UInt32 memberCacheIndex = sequenceData.tempInstanceValues[instanceIndex];
            if( memberCacheIndex == InvalidIndex ) {
              newMember = true;
              memberCacheIndex = this.groupUpdateCachedMemberData.size();
              sequenceData.tempInstanceValues[instanceIndex] = memberCacheIndex;
              this.groupUpdateCachedMemberData.resize( memberCacheIndex+1 );
              this.conditionFunctionKeys.resize( memberCacheIndex+1 );
              this.flagValueKeys.resize( memberCacheIndex+1 );
              this.groupUpdateCachedMemberData[memberCacheIndex].instanceIndex = instanceIndex;
            }
            this.groupUpdateCachedMemberData[memberCacheIndex].sourceGroupIndex = (Boolean(sequencePassData.parentSequenceApplyOp) && this.subGroup && indicesFromSourceGroup) ? j : InvalidIndex;//TODO: this won't work with BVol check + subrgoup...
//if(j==0)report("GROUP "+this.getName( sequenceData )+" sourceIndex "+this.groupUpdateCachedMemberData[memberCacheIndex].sourceGroupIndex);
          }
        }
        if( this.perMemberFlagCheck || this.perMemberCondition ) {

          Size batchSize, numBatches;
          Size workload = 1 * (this.perMemberFlagEval?2:1) * (this.perMemberCondition?2:1);
          GetBatchSizeAndCountForParallel( numInstances, workload, 100, numBatches, batchSize );

          if( numBatches > 1 )
            ParallelEvaluateGroupMemberConditionAndFlag<<<numBatches>>>(batchSize, this, sequenceData, sequencePassData, i, type, instanceIndices, parentParams );
          else {
            Size numParentLayers = parentParams.getNumLayers();
            for( Size j = 0; j < numParentLayers; ++j )
              this.tempSharedParams.setLayer( j, parentParams.layers[j] );

            for( Size j = 0; j < numInstances; ++j ) {
              UInt32 instanceIndex = instanceIndices[j];
              if(checkInstanceType && sequenceData.renderDataPrimitives[ sequenceData.renderDataInstances[instanceIndex].primIndex ].ownerType != type)
                  continue;

              Size memberCacheIndex = sequenceData.tempInstanceValues[instanceIndex];
              this.evaluateGroupMemberConditionAndFlag(sequenceData, sequencePassData, i, instanceIndex, this.groupUpdateCachedMemberData[memberCacheIndex], memberCacheIndex, this.tempSharedParams, parentParams);
            }
          }
        }

        Boolean keptSome = false;

        for( Size j = 0; j < numInstances; ++j ) {
            UInt32 instanceIndex = instanceIndices[j];
            if(checkInstanceType && sequenceData.renderDataPrimitives[ sequenceData.renderDataInstances[instanceIndex].primIndex ].ownerType != type)
                continue;

          Boolean keep = true;
          if( this.perMemberFlagCheck || this.perMemberCondition ) {
            UInt32 memberCacheIndex = sequenceData.tempInstanceValues[instanceIndex];
            keep = this.groupUpdateCachedMemberData[memberCacheIndex].keep;
          }
          if( keep ) {
            Boolean wasMember = sequenceData.tempInstanceBits1.getThenSet(instanceIndex);
            keptSome = true;
            sequenceData.tempInstanceBits2.set(instanceIndex);

            if( !wasMember ) {
              hadChanges = true;
              UInt32 member = this.memberInstances.size();
              this.memberInstances.resize( member + 1 );
              this.memberInstances[ member ] = instanceIndex;
            }
          }
        }
        if( keptSome )
          setBit( this.memberTypeFlags, type );
      }
    }

    if( this.perMemberFlagCheck || this.perMemberCondition ) {
      //Only keep member which had tested conditions. Shuffle entries accordingly.
      Size targetIndex = 0;
      for( Size i = 0; i < this.groupUpdateCachedMemberData.size(); ++i ) {
        Size instanceIndex = this.groupUpdateCachedMemberData[i].instanceIndex;
        Boolean testedCondition = sequenceData.tempInstanceBits3.getThenSet(instanceIndex, false);//Clean temp bits
        sequenceData.tempInstanceValues[instanceIndex] = InvalidIndex;//Clean temp values

        if( testedCondition ) {
          if( i != targetIndex ) {
            this.groupUpdateCachedMemberData[targetIndex] = this.groupUpdateCachedMemberData[i];
            this.conditionFunctionKeys.moveMember( i, targetIndex );
            this.flagValueKeys.moveMember( i, targetIndex );
          }
          ++targetIndex;
        }
      }
      if( targetIndex != this.groupUpdateCachedMemberData.size() ) {
        this.groupUpdateCachedMemberData.resize(targetIndex);
        this.conditionFunctionKeys.resize(targetIndex);
        this.flagValueKeys.resize(targetIndex);
      }
    }

    for( Size i = 0; i < this.memberInstances.size(); ++i ) {
      Size instanceIndex = this.memberInstances[i];
      if( i < prevNumMembers && (!sequenceData.tempInstanceBits2.get(instanceIndex) || sequenceData.renderDataInstances[instanceIndex].renderDataGenerationCount > this.lastRenderDataGenerationCount) )
        hadChanges = true;
      //cleanup temp bits
      sequenceData.tempInstanceBits1.clear(instanceIndex);
    }

    if(hadChanges) {
      //Replace unused members by recompacting the array with minimal element copy
      this.prevMembersNewIndex.resize(prevNumMembers);
      Integer end = Integer(this.memberInstances.size());
      Size i;
      for( i = 0; i < prevNumMembers && i < end; ++i ) {
        Size instanceIndex = this.memberInstances[i];
        if( !sequenceData.tempInstanceBits2.get(instanceIndex) ) {
          //Unused: replace with tail
          this.prevMembersNewIndex[i] = InvalidIndex;
          Size endInstanceIndex;
          while( --end >= 0 && end > i ) {
            endInstanceIndex = this.memberInstances[end];
            if( sequenceData.tempInstanceBits2.get(endInstanceIndex) )
              break;
            else if( end < prevNumMembers )
              this.prevMembersNewIndex[end] = InvalidIndex;
          }
          if( end > i ) {
            this.memberInstances[i] = this.memberInstances[end];
            if( end < prevNumMembers ) {
              if ( sequenceData.renderDataInstances[endInstanceIndex].renderDataGenerationCount > this.lastRenderDataGenerationCount ) {
                this.prevMembersNewIndex[end] = InvalidIndex;
              } else
                this.prevMembersNewIndex[end] = i;
            }
          }
        } else if ( sequenceData.renderDataInstances[instanceIndex].renderDataGenerationCount > this.lastRenderDataGenerationCount ) {
          //Was used and still used, but in fact it now represents another primitive (index was reused)
          this.prevMembersNewIndex[i] = InvalidIndex;
        } else
          this.prevMembersNewIndex[i] = i;
      }
      this.memberInstances.resize(end);
    } else
      this.prevMembersNewIndex.resize(0);

    //cleanup temp bits
    for( Size i = 0; i < this.memberInstances.size(); ++i )
      sequenceData.tempInstanceBits2.clear( this.memberInstances[i] );
  } else
    this.prevMembersNewIndex.resize(0);

  //Bit array ref cleanup
  for( Size i = 0; i < tempBitArraysNbToReset; ++i )
    sequenceData.tempBitArrayRefs[i] = BitVector();

  //Update params value version
  if( hadChanges || initialize )
    this.generationCount = sequenceData.generationCount;

  //Update mapping to source group, if required
  if( computeSourceGroupMappings ) {
    Ref<GroupDataObj> groupDatas[2];
    Size groupCount = 1;
    groupDatas[0] = thisObj;
    if( isComplementGroup ) {
      sourceGroupData = sourceGroupData.data.sourceGroupDataObj;
      groupDatas[1] = this.sourceGroupDataObj;
      groupCount = 2;
    } else
      sourceGroupData = this.sourceGroupDataObj;
    UInt32 sourceGroupDataMembers[] = sourceGroupData.data.memberInstances;
    Size numUnionGroupInstances = sourceGroupDataMembers.size();

    Boolean didMapping = false;
    for( Size idx = 0; idx < groupCount; ++idx ) {
      Ref<GroupDataObj> group = groupDatas[idx];
      if(  sourceGroupData.data.generationCount == sequenceData.generationCount 
        || group.data.generationCount == sequenceData.generationCount ) {
        //update
        if(!didMapping) {
          didMapping = true;
          for( Size i = 0; i < numUnionGroupInstances; ++i )
            sequenceData.tempInstanceValues[sourceGroupDataMembers[i]] = i;
        }
        UInt32 groupDataMemberInstances[] = group.data.memberInstances;
        Size numGroupInstances = groupDataMemberInstances.size();
        group.data.memberSourceGroupMapping.resize(numGroupInstances);
        UInt32 groupDataMemberSourceGroupMapping[] = group.data.memberSourceGroupMapping;
        for( Size i = 0; i < numGroupInstances; ++i ) {
          Size instanceIndex = groupDataMemberInstances[i];
          groupDataMemberSourceGroupMapping[i] = sequenceData.tempInstanceValues[instanceIndex];
        }
      }
    }
    if(didMapping) {//Cleanup
      for( Size i = 0; i < numUnionGroupInstances; ++i )
        sequenceData.tempInstanceValues[sourceGroupDataMembers[i]] = InvalidIndex;
    }
  }

  //TODO: save group into instance data if it has the 'save' attribute & not uptodate

//report("Group "+this.getName( renderData, sequenceData )+" changed=" + hadChanges + " recomputed=" + recompute + " members="+ this.memberInstances.size());//+" mapping"+computeSourceGroupMappings+" "+this.memberSourceGroupMapping);//+" prevMembersNewIndex="+this.prevMembersNewIndex);
  this.lastRenderDataGenerationCount = sequenceData.renderData.data.generationCount;

  if( sequenceData.enableProfiling )
    this.profileEnd = getCurrentTicks();
}

function cleanup( io RenderSequenceDataStruct sequenceData, io InstanceStoredDatas instanceStoredDatas, Ref<InstanceStoredData > toRemove_ ) {
  //Work-around KL wrong 'const' handling
  Ref<InstanceStoredData > toRemove = toRemove_;
  for( Size i = 0; i < toRemove.textureData.size(); ++i ) {
    if( toRemove.textureData[i].recycleInPool ) {
      Ref<RenderCaches> renderCaches = sequenceData.renderData.data.renderCaches;//Trick KL "const"
      renderCaches.oglTextureCache.releaseTexture( toRemove.textureData[i].textureContainer );
    } else {
      if( !toRemove.textureData[i].setFromSource ) {
        sequenceData.texturesToRelease.push(toRemove.textureData[i].textureContainer);
        toRemove.textureData[i].textureContainer = null;
      }
    }
  }

  Size indexToRemove = toRemove.index;
  if( indexToRemove+1 < instanceStoredDatas.data.size() ) {
    sequenceData.instanceStoredDataIndexPool.unusedIndex( toRemove.poolIndex );
    toRemove.reset();

    instanceStoredDatas.data[indexToRemove] = instanceStoredDatas.data[instanceStoredDatas.data.size()-1];
    instanceStoredDatas.data[indexToRemove].index = indexToRemove;
  }
  instanceStoredDatas.data.resize( instanceStoredDatas.data.size()-1 );
  instanceStoredDatas.updateInitialVersions();
}

function ApplyMemberData.cleanup!( io RenderSequenceDataStruct sequenceData, ApplyData applyData ) {
  if( this.instanceStoredData )
    cleanup( sequenceData, sequenceData.instancesStoredData[this.instanceIndex], this.instanceStoredData );

  if( this.memberSubPassObj ) {
    Ref<SequencePassDataObj> pass = this.memberSubPassObj;
    pass.cleanup( sequenceData );
  }

  if( applyData.requestID != 0 && this.primIndex < sequenceData.renderDataPrimitives.size() ) {
    Size numPrimLayers = sequenceData.renderDataPrimitives[ this.primIndex ].params.getNumLayers();
    for( Size k = 0; k < numPrimLayers; ++k ) {
      Ref<RenderParamValues> paramValues = sequenceData.renderDataPrimitives[ this.primIndex ].params.getLayer(k);
      Size numRequests = paramValues.renderRequests.size();
      Size target = 0;
      for( Size reqIndex = 0; reqIndex < numRequests; ++reqIndex ) {
        if( paramValues.renderRequests[reqIndex].renderOwnerCookie != applyData.requestID ) {
          if( target != reqIndex )
            paramValues.renderRequests[target] = paramValues.renderRequests[reqIndex];
          ++target;
        }
      }
      paramValues.renderRequests.resize(target);
    }
  }
}

function RenderSequenceDataStruct.releaseFramebuffers!() {
  if (cpglHaveContext()) {
    for( Size i = 0; i < this.framebuffersToRelease.size(); ++i ) {
      this.tempSizeOneIntegerArray[0] = this.framebuffersToRelease[i];
      glDeleteFramebuffers(1, this.tempSizeOneIntegerArray);
    }
    this.framebuffersToRelease.resize(0);
  }
}

function RenderSequenceDataStruct.releaseTextures!() {
  if (cpglHaveContext()) {
    for( Size i = 0; i < this.texturesToRelease.size(); ++i )
      this.texturesToRelease[i].delete();
    this.texturesToRelease.resize(0);
  }
}

function RenderSequenceDataStruct.allocateTextures!() {
  for( Size i = 0; i < this.texturesToAllocate.size(); ++i ) {
    Ref<OGLTexture2D> texture = this.texturesToAllocate[i];
    Integer width = texture.width;
    Integer height = texture.height;
    Integer depth = texture.depth;
    texture.width = -1;
    texture.height = -1;
    texture.depth = -1;

    Data NULL;
    texture.configure( width, height, depth, NULL );
  }
  this.texturesToAllocate.resize(0);
}


function ApplyData.cleanup!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData ) {
  if( this.ownedFramebufferID) {
    if( this.ownedFramebufferID != -1 )
      sequenceData.framebuffersToRelease.push(this.ownedFramebufferID);
    this.ownedFramebufferID = 0;
  }
  for( Size i = 0; i < this.applyMembersData.size(); ++i )
    this.applyMembersData[i].cleanup( sequenceData, this );

  if( this.applySubPassObj ) {
    Ref<SequencePassDataObj> subPass = this.applySubPassObj;
    subPass.cleanup( sequenceData );
  }
}

function SequencePassData.cleanup!( io RenderSequenceDataStruct sequenceData ) {
  for( Size i = 0; i < this.applyDatas.size(); ++i ) {
    this.applyDatas[i].data.cleanup( sequenceData, this );
    sequenceData.applyOpsDataIndexPool.unusedIndex( this.applyDatas[i].poolIndex );
    if( this.applyDatas[i].autoStats )
      this.applyDatas[i].autoStats.unregister();
    this.applyDatas[i].data = ApplyData();
    this.applyDatas[i].data.selfObj = this.applyDatas[i];
  }
  for( Size i = 0; i < this.groupDatas.size(); ++i ) {
    sequenceData.groupsDataIndexPool.unusedIndex( this.groupDatas[i].poolIndex );
    if( this.groupDatas[i].autoStats )
      this.groupDatas[i].autoStats.unregister();
    this.groupDatas[i].data = GroupData();
  }
}

function SequencePassDataObj.cleanup!( io RenderSequenceDataStruct sequenceData ) {
  this.data.cleanup(sequenceData);
  sequenceData.passesDataIndexPool.unusedIndex( this.poolIndex );
  this.data = SequencePassData();
  this.data.sequenceDataObj = sequenceData.selfObj;
}

function Boolean ApplyMemberData.updateTexture!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, io ApplyData applyData, Size memberIndex, Ref<InstanceStoredData> instanceData_, Size textureIndex ) {
  //Work-around KL wrong 'const' handling
  Ref<InstanceStoredData> instanceData = instanceData_;

  Boolean changed;
  if( applyData.dynamicTextureFunctions[textureIndex].sourceFunctionBindings.isValid() ) {
    Size numLayersWithoutTextureParams = this.allParams.getNumLayers()-1;
    if( applyData.dynamicTextureFunctions[textureIndex].sourceFunctionBindings.updateMemberParamsAndStoreResult( 
              sequenceData, memberIndex, this.allParams, this.debugContext, this.firstMemberLayerForBindings, numLayersWithoutTextureParams,
              instanceData.params,
              instanceData.textureData[textureIndex].name,
              instanceData.textureData[textureIndex].key, !this.initialized ) ) {
      changed = true;
      Object result = instanceData.params.get(instanceData.textureData[textureIndex].key);
      if( result != null && result.type != OGLTexture2D )
        throw("Error: render target "+instanceData.textureData[textureIndex].name+" of member " + this.getName(sequenceData) + " was not set with an OGLTexture2D type");
      instanceData.textureData[textureIndex].textureContainer = result;
      instanceData.textureData[textureIndex].setFromSource = true;
    }
  } else {
    Integer newWidth;
    Integer newHeight;
    Integer newDepth;
    if(instanceData.textureData[textureIndex].textureContainer) {
      newWidth = instanceData.textureData[textureIndex].textureContainer.width;
      newHeight = instanceData.textureData[textureIndex].textureContainer.height;
      newDepth = instanceData.textureData[textureIndex].textureContainer.depth;
    } else {
      newWidth = instanceData.textureData[textureIndex].textureTypeReference.width;
      newHeight = instanceData.textureData[textureIndex].textureTypeReference.height;
      newDepth = instanceData.textureData[textureIndex].textureTypeReference.depth;
    }

    if( applyData.hasDynamicSizedTextureTarget ) {
      if( applyData.dynamicTextureFunctions[textureIndex].widthFunctionBindings.isDynamic() ) {
        if(  applyData.dynamicTextureFunctions[textureIndex].widthFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, this.allParams.getNumLayers(), !this.initialized ) 
          || applyData.dynamicTextureFunctions[textureIndex].widthFunctionBindings.passParamsGenerationCount == sequenceData.generationCount || !this.initialized )
          newWidth = applyData.dynamicTextureFunctions[textureIndex].widthFunctionBindings.callIntegerFunction( !this.initialized, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
      }
      if( applyData.dynamicTextureFunctions[textureIndex].heightFunctionBindings.isDynamic() ) {
        if(  applyData.dynamicTextureFunctions[textureIndex].heightFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, this.allParams.getNumLayers(), !this.initialized )
          || applyData.dynamicTextureFunctions[textureIndex].heightFunctionBindings.passParamsGenerationCount == sequenceData.generationCount || !this.initialized )
          newHeight = applyData.dynamicTextureFunctions[textureIndex].heightFunctionBindings.callIntegerFunction( !this.initialized, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
      }
      if( applyData.dynamicTextureFunctions[textureIndex].depthFunctionBindings.isDynamic() ) {
        if(  applyData.dynamicTextureFunctions[textureIndex].depthFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, this.allParams.getNumLayers(), !this.initialized ) 
          || applyData.dynamicTextureFunctions[textureIndex].depthFunctionBindings.passParamsGenerationCount == sequenceData.generationCount || !this.initialized )
          newDepth = applyData.dynamicTextureFunctions[textureIndex].depthFunctionBindings.callIntegerFunction( !this.initialized, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
      }
    }
    if(newWidth <= 0)
      newWidth = 1;
    if(newHeight <= 0)
      newHeight = 1;
    if(newDepth <= 0)
      newDepth = 1;

    Integer width, height, depth;
    if( instanceData.textureData[textureIndex].textureContainer ) {
      if( instanceData.textureData[textureIndex].textureContainer.bufferID == 0 )
        changed = true;
      width = instanceData.textureData[textureIndex].textureContainer.width;
      height = instanceData.textureData[textureIndex].textureContainer.height;
      depth = instanceData.textureData[textureIndex].textureContainer.depth;
    } else
      changed = true;

    if( newWidth != width ) {
      changed = true;
      width = newWidth;
    }
    if( newHeight != height ) {
      changed = true;
      height = newHeight;
    }
    if( newDepth != depth ) {
      changed = true;
      depth = newDepth;
    }
    if( changed ) {
      if( instanceData.textureData[textureIndex].recycleInPool ) {
        //important: release with previous width
        Ref<RenderCaches> renderCaches = sequenceData.renderData.data.renderCaches;//trick KL's "const"
        renderCaches.oglTextureCache.releaseTexture( instanceData.textureData[textureIndex].textureContainer );
        Boolean needsConfigure;
        instanceData.textureData[textureIndex].textureContainer = renderCaches.oglTextureCache.allocateTexture( needsConfigure, width, height, depth, instanceData.textureData[textureIndex].textureTypeReference );
        if( needsConfigure )
          sequenceData.texturesToAllocate.push(instanceData.textureData[textureIndex].textureContainer);
      } else {
        if(instanceData.textureData[textureIndex].textureContainer == null) {
          instanceData.textureData[textureIndex].textureContainer = instanceData.textureData[textureIndex].textureTypeReference.clone();
          if( sequenceData.enableStatistics ) {
            if( !instanceData.textureData[textureIndex].textureContainer.autoStats )
              instanceData.textureData[textureIndex].textureContainer.autoStats = StatisticsAutoRegisterMember(instanceData.textureData[textureIndex].textureContainer);
            else
              instanceData.textureData[textureIndex].textureContainer.autoStats.postCloneRefresh(instanceData.textureData[textureIndex].textureContainer); //see postCloneRefresh for comments
          }
        }
        instanceData.textureData[textureIndex].textureContainer.width = width;
        instanceData.textureData[textureIndex].textureContainer.height = height;
        instanceData.textureData[textureIndex].textureContainer.depth = depth;
        sequenceData.texturesToAllocate.push(instanceData.textureData[textureIndex].textureContainer);
      }
      instanceData.params.set(instanceData.textureData[textureIndex].key, instanceData.textureData[textureIndex].textureContainer);
      if(sequenceData.enableStatistics) {
        Ref<ApplyDataObj> applyDataObj = applyData.selfObj;
        AddStatisticsChild(applyDataObj.autoStats, instanceData.textureData[textureIndex].textureContainer.autoStats);
      }
      instanceData.params.incrementValueVersion(instanceData.textureData[textureIndex].key);
    }
  }

  if( changed )
    this.generationCount = sequenceData.generationCount;
  return changed;
}

//ApplyMemberData.updateTextures: returns true if bufferIDs changed
inline Boolean ApplyMemberData.updateTextures!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, io ApplyData applyData, Size memberIndex ) {
  Boolean changed;
  if( this.instanceStoredData ) {
    Size sourcePass = sequencePassData.sourcePassIndex;
    Size numTextureDefinitions = this.instanceStoredData.textureData.size();
    for( Size k = 0; k < numTextureDefinitions; ++k ) {
      if( this.updateTexture( sequenceData, sequencePassData, applyData, memberIndex, this.instanceStoredData, k ) )
        changed = true;
    }
  }
  return changed;
}

function ApplyMemberData.initTextureIDs!( io RenderSequenceDataStruct sequenceData, ApplyData applyData, Ref<InstanceStoredData> instanceStoredData_ ) {
  //Work-around KL wrong 'const' handling
  Ref<InstanceStoredData> instanceStoredData = instanceStoredData_;

  instanceStoredData.depthBufferIndex = -1;
  Integer width = -1;
  Integer height = -1;

  Size numTextureDefinitions = instanceStoredData.textureData.size();
  for( Size k = 0; k < numTextureDefinitions; ++k ) {
    if( instanceStoredData.textureData[k].textureContainer.width > 0 ) {

      if( width == -1 ) {
        width = instanceStoredData.textureData[k].textureContainer.width;
        height = instanceStoredData.textureData[k].textureContainer.height;
      } else if ( width != instanceStoredData.textureData[k].textureContainer.width || height != instanceStoredData.textureData[k].textureContainer.height ) {
        throw("Error: render targets of member " + this.getName(sequenceData) + " have different sizes: (" + instanceStoredData.textureData[k].textureContainer.width + ", "+ instanceStoredData.textureData[k].textureContainer.height + ") and (" + width + ", "  + height + ")"  );
      }

      if( instanceStoredData.textureData[k].textureContainer.glFormat == GL_DEPTH_COMPONENT || instanceStoredData.textureData[k].textureContainer.glFormat == GL_DEPTH_STENCIL ) {
        if( instanceStoredData.depthBufferIndex != -1 )
          throw("Error: more than one GL_DEPTH_COMPONENT texture target in 'apply' of member " + this.getName(sequenceData) );
        instanceStoredData.depthBufferIndex = k;

        if( instanceStoredData.textureData[k].textureContainer.isRenderBuffer ) {
          if( instanceStoredData.textureData[k].textureContainer.glFormat == GL_DEPTH_STENCIL )
            instanceStoredData.depthAttachmentType = AttachmentType_depthStencilRenderBuffer;
          else
            instanceStoredData.depthAttachmentType = AttachmentType_depthRenderBuffer;
        } else if( instanceStoredData.textureData[k].textureContainer.glTextureType == GL_TEXTURE_CUBE_MAP )
          instanceStoredData.depthAttachmentType = AttachmentType_depthCubeTexture;
        else if( instanceStoredData.textureData[k].textureContainer.glTextureType == GL_TEXTURE_2D_ARRAY )
          instanceStoredData.depthAttachmentType = AttachmentType_depthTextureArray;
        else if( instanceStoredData.textureData[k].textureContainer.glTextureType == GL_TEXTURE_3D )
          instanceStoredData.depthAttachmentType = AttachmentType_depth3DTexture;
        else
          instanceStoredData.depthAttachmentType = AttachmentType_depthTexture;
      }
    }
  }
}

inline ApplyMemberData.initTextureIDs!( io RenderSequenceDataStruct sequenceData, ApplyData applyData ) {
  if( this.instanceStoredData )
    this.initTextureIDs( sequenceData, applyData, this.instanceStoredData );
}

function ApplyMemberData.init_noThreadSafe!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, Ref<SequencePassDataObj> sequencePassDataObj, ApplyDataObj applyDataObj, ApplyData applyData, Size memberIndex ) {
  this.generationCount = sequenceData.generationCount;

  Size sourcePass = sequencePassData.sourcePassIndex;

  Size numTextureDefinitions = sequenceData.renderDataPasses[sourcePass].applyOps[applyData.sourcePassApplyIndex].renderTargets.size();
  Size sourcePassRef = applyData.applySourcePassIndex;

  //Update texture target & bindings storage
  if( numTextureDefinitions != 0 || applyData.hasStoredBindings ) {

    InstanceStoredDataInfo instanceStoredDataInfo;
    instanceStoredDataInfo.memberIndex = memberIndex;
    instanceStoredDataInfo.sequenceApplyData = this.sequenceApplyDataObj;

    //Create stored texture that will be filled by this applyOp
    this.instanceStoredData = sequenceData.instancesStoredData[this.instanceIndex].allocate( sequenceData );
    if( numTextureDefinitions )
      this.renderTargetInstanceStoredData = this.instanceStoredData;

    this.instanceStoredData.ownerApplyObj = applyDataObj;
    this.instanceStoredData.ownerApplyMemberIndex = memberIndex;

    this.instanceStoredData.passOrderStack = sequencePassData.passOrderStack;
    this.instanceStoredData.sequencePassOrder = applyData.sequencePassOrder;

    for( Size k = 0; k < numTextureDefinitions; ++k ) {
      InstanceStoredTextureData info;
      info.name = sequenceData.renderDataPasses[sourcePass].applyOps[applyData.sourcePassApplyIndex].renderTargets[k].name;
      info.key = this.instanceStoredData.params.setAsOGLTexture2D(info.name);
      info.textureTypeReference = sequenceData.renderDataPasses[sourcePass].applyOps[applyData.sourcePassApplyIndex].renderTargets[k].definition;
      info.recycleInPool = sequenceData.renderDataPasses[sourcePass].applyOps[applyData.sourcePassApplyIndex].renderTargets[k].recycleInPool;
      this.instanceStoredData.textureData.push(info);
    }

    if( numTextureDefinitions )
      this.framebufferKey = this.instanceStoredData.params.setAsInteger("fbo");

  } else
    this.instanceStoredData = null;

  //Create member passes
  if( sourcePassRef != 0 && applyData.perMemberPass ) {

    UInt32 memberSubPassIndex;
    if( sequenceData.passesDataIndexPool.getFreeIndex( memberSubPassIndex ) ) {
      sequenceData.passesData.resize( sequenceData.passesDataIndexPool.getIndexEnd() );
      sequenceData.passesData[memberSubPassIndex] = SequencePassDataObj();
      sequenceData.passesData[memberSubPassIndex].data.sequenceDataObj = sequenceData.selfObj;
      sequenceData.passesData[memberSubPassIndex].poolIndex = memberSubPassIndex;
    }
    Ref<SequencePassDataObj> memberSubPass = sequenceData.passesData[memberSubPassIndex];
    this.memberSubPassObj = memberSubPass;

    memberSubPass.data.ownerPrimIndex = this.primIndex;
    memberSubPass.data.ownerInstanceIndex = this.instanceIndex;
    memberSubPass.data.parentSequencePassObj = sequencePassDataObj;
    memberSubPass.data.parentSequenceApplyOp = this.sequenceApplyDataObj;
    memberSubPass.data.sourcePassIndex = applyData.applySourcePassIndex;

    memberSubPass.data.passOrderStack = sequencePassData.passOrderStack;
    memberSubPass.data.passOrderStack.push(applyData.sequencePassOrder);
  }
}

inline ApplyMemberData.initFBOInternal!( io RenderSequenceDataStruct sequenceData, Integer framebufferID ) {
  this.instanceStoredData.params.set(this.framebufferKey, framebufferID);
}

inline Integer ApplyData.initFBOInternal!( io RenderSequenceDataStruct sequenceData ) {
  if( this.ownedFramebufferID == -1 ) {
    if( this.ownedFramebufferID == -1 ) {
      glGenFramebuffers(1, sequenceData.tempSizeOneIntegerArray);
      this.ownedFramebufferID = sequenceData.tempSizeOneIntegerArray[0];
    }
    Size numMembers = this.applyMembersData.size();
    for( Size i = 0; i < numMembers; ++i )
      this.applyMembersData[i].initFBOInternal( sequenceData, this.ownedFramebufferID );
  }
  return this.ownedFramebufferID;
}

inline Integer ApplyMemberData.initFBO!( io RenderSequenceDataStruct sequenceData, io ApplyData applyData ) {
  if( this.renderTargetInstanceStoredData ) {
    Ref<ApplyDataObj> instDataApplyData = this.renderTargetInstanceStoredData.ownerApplyObj;
    Integer framebufferID = instDataApplyData.data.ownedFramebufferID;

    if( framebufferID != -1 )
      return framebufferID;
    else
      return instDataApplyData.data.initFBOInternal( sequenceData );
  } else
    return 0;
}


inline ApplyMemberData.callDrawFunction?( RenderSequenceDataStruct sequenceData, ApplyData applyData, Size drawFunctionIndex, Size memberIndex ) {
  Ref<SequencePassDataObj> sequencePass = applyData.sequencePassDataObj;
  Size primLayerIndex = sequencePass.data.numParamLayers;
  
  applyData.memberDrawCallbackFunctions[drawFunctionIndex].callVoidFunction(
    applyData.memberDrawCallbackFunctions[drawFunctionIndex].passParamsGenerationCount == sequenceData.generationCount, 
    memberIndex, primLayerIndex, this.allParams, this.debugContext );
}

inline ApplyMemberData.updateClearFunctions!( io RenderSequenceDataStruct sequenceData, io ApplyData applyData, io ClearTextureFunctions clearFunctions, Size memberIndex, Size lastLayer, io TextureClearValues clearValues ) {

  clearValues.hasClearColor = clearFunctions.hasClearColor;
  if( clearFunctions.hasClearColor ) {
    if( clearFunctions.clearColorFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, lastLayer, !this.initialized )
      || clearFunctions.clearColorFunctionBindings.passParamsGenerationCount == sequenceData.generationCount || !this.initialized )
     clearValues.color = clearFunctions.clearColorFunctionBindings.callColorFunction( !this.initialized, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
  }
  clearValues.hasClearDepth = clearFunctions.hasClearDepth;
  if( clearFunctions.hasClearDepth ) {
    if( clearFunctions.clearDepthFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, lastLayer, !this.initialized )
      || clearFunctions.clearDepthFunctionBindings.passParamsGenerationCount == sequenceData.generationCount || !this.initialized )
      clearValues.depth = clearFunctions.clearDepthFunctionBindings.callScalarFunction( !this.initialized, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
  }
}

function ApplyMemberData.update!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, io ApplyData applyData, RenderParams parentParams, Boolean viewTransfoChanged, Size memberIndex, io RenderParamValues sharedRequestContainer ) {
//report("ApplyMemberData.update: "+applyData.getName(sequenceData)+" member "+memberIndex+" instance "+sequenceData.renderData.data.getInstanceDesc(this.instanceIndex));
  //Before anything, check if we should update (updateInterval)
  if( this.initialized && !applyData.hasPerMemberUpdateInterval && applyData.defaultUpdateInterval > 1 ) {
    if( ( (sequenceData.generationCount + this.uniqueIndex) % applyData.defaultUpdateInterval) != 0 ) {// no update
      this.skipBecauseOfUpdateInterval = true;
      return;// no update
    } else
      this.skipBecauseOfUpdateInterval = false;
  }
  
  Boolean needToUpdateShaderParams = !this.initialized;

  Size sourcePass = sequencePassData.sourcePassIndex;
  //Build / update allParams

  Ref<RenderParamValues> feedbackParams = sequenceData.instancesStoredData[this.instanceIndex].feedbackParams;

  Size nextTargetLayer = 0;
  Size inheritedGroupMemberIndex;
  if( applyData.inheritedGroup ) {
    if( applyData.inheritedSubGroup )
      inheritedGroupMemberIndex = applyData.memberSourceGroupMapping[memberIndex];
    else
      inheritedGroupMemberIndex = memberIndex;

    Size numParentParamLayers = sequencePassData.parentSequenceApplyOp.data.applyMembersData[inheritedGroupMemberIndex].allParams.getNumLayers();
    for( Size k = 0; k < numParentParamLayers; ++k ) {
      if( this.allParams.setLayer( nextTargetLayer++, sequencePassData.parentSequenceApplyOp.data.applyMembersData[inheritedGroupMemberIndex].allParams.layers[k] ) ) {
        if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
          needToUpdateShaderParams = true;
      }
    }

    this.firstMemberLayerForBindings = sequencePassData.parentSequenceApplyOp.data.applyMembersData[inheritedGroupMemberIndex].firstMemberLayerForBindings;
    if(applyData.passValues) {
      if( this.allParams.setLayer( nextTargetLayer++, applyData.passValues ) ) {
        if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
          needToUpdateShaderParams = true;
      }
    }
  } else {
    Size numParentParamLayers = parentParams.getNumLayers();
    for( Size k = 0; k < numParentParamLayers; ++k ) {
      if( this.allParams.setLayer( nextTargetLayer++, parentParams.layers[k] ) ) {
        if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
          needToUpdateShaderParams = true;
      }
    }

    if(applyData.passValues) {
      if( this.allParams.setLayer( nextTargetLayer++, applyData.passValues ) ) {
        if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
          needToUpdateShaderParams = true;
      }
    }

    this.firstMemberLayerForBindings = nextTargetLayer;
    Size numPrimLayers = sequenceData.renderDataPrimitives[ this.primIndex ].params.getNumLayers();
    for( Size k = 0; k < numPrimLayers; ++k ) {
      if( this.allParams.setLayer( nextTargetLayer++, sequenceData.renderDataPrimitives[ this.primIndex ].params.layers[k].params, sequenceData.renderDataInstances[this.instanceIndex].primInstanceIndex ) ) {
        if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
          needToUpdateShaderParams = true;
      }
    }

    if( feedbackParams ) {
      if( this.allParams.setLayer( nextTargetLayer++, feedbackParams ) ) {
        if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
          needToUpdateShaderParams = true;
      }
    }
  }

  //Then: instance stored params
  if( !feedbackParams ) {
    if( applyData.hasFeedbackBindings ) {
      sequenceData.instancesStoredData[this.instanceIndex].feedbackParams = RenderParamValues();
      feedbackParams = sequenceData.instancesStoredData[this.instanceIndex].feedbackParams;
      feedbackParams.ownerType = OwnerType_pass;
      feedbackParams.ownerName = "InstanceFeedbackData"+this.instanceIndex;

      sequenceData.instancesStoredData[this.instanceIndex].updateInitialVersions();
      feedbackParams.versions = sequenceData.instancesStoredData[this.instanceIndex].initialVersions;

      sequenceData.instancesStoredData[this.instanceIndex].feedbackParamsCreationGenerationCount = sequenceData.generationCount;
      this.allParams.setLayer( nextTargetLayer++, feedbackParams );
    }
  } else if( sequenceData.instancesStoredData[this.instanceIndex].feedbackParamsCreationGenerationCount == sequenceData.generationCount ) {
    //Feedback params was just created; might not be present: search, insert it if not found
    Size i = nextTargetLayer;
    while( i-- ) {
      if( this.allParams.getLayer(i) === feedbackParams )
        break;
      if( i == 0 ) {
        //Not found; insert it.
        this.allParams.setLayer( nextTargetLayer++, feedbackParams );
      }
    }
  }

  this.instanceLayersCache.update( sequenceData, this.instanceIndex, applyData.inheritedGroup, sequencePassData.passOrderStack, applyData.sequencePassOrder, this.instanceStoredData );
  for( Size k = 0; k < this.instanceLayersCache.layers.size(); ++k ) {
    if( this.allParams.setLayer( nextTargetLayer++, this.instanceLayersCache.layers[k], 0 ) ) {
      if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
        needToUpdateShaderParams = true;
    }
  }

  Size layerBeforeImplicits = nextTargetLayer;
  Integer implicitGeomType = applyData.implicitGeometry;
  if( implicitGeomType != ImplicitGeomType_none ) {
    //Override with implicit geom params
    //TODO: if implicit geom intersects viewPlane, draw as viewportPlane, or disable clipping somehow? (else clipping causes geometry to not be drawn...)
    Integer space = TransformSpace_none;
    Mat44 adjustedTransform;
    Size implicitPrimitiveIndex;
    if( implicitGeomType == ImplicitGeomType_viewportPlane ) {
      implicitPrimitiveIndex = ImplicitGeometryPrimitive_screenPlane;
      space = TransformSpace_viewProjection;
    } else if( implicitGeomType == ImplicitGeomType_boundingVolume ) {
      LocalBoundingVolume localBVol;
      sequenceData.renderDataPrimitives[this.primIndex].params.get( sequenceData.renderDataPrimitives[this.primIndex].localBVolVersionKey.key, localBVol );
      if( localBVol.type == LocalBoundingVolume_infinite ) {
        implicitPrimitiveIndex = ImplicitGeometryPrimitive_screenPlane;
        space = TransformSpace_viewProjection;
        Vec3 scale(2.0, 2.0, 1.0);
        Vec3 translate(-1.0, -1.0, 0.0);
        adjustedTransform.setDiagonal(scale);
        adjustedTransform.setTranslation(translate);
        space = TransformSpace_viewProjection;
      } else {
        //NOTE: this is fragile; we don't take into account overriden transforms...
        sequenceData.renderDataPrimitives[this.primIndex].params.get( sequenceData.renderDataInstances[this.instanceIndex].transformVersionKey.key, adjustedTransform, sequenceData.renderDataInstances[this.instanceIndex].primInstanceIndex );
        if( localBVol.type == LocalBoundingVolume_bCone ) {
          Mat44 localTransfoMat;
          Scalar length = localBVol.sc2;
          if(length < 0) {
            //Infinite: just make sure we englobe the known world
            Vec3 dir = Vec3(-adjustedTransform.row0.z, -adjustedTransform.row1.z, -adjustedTransform.row2.z).unit();
            LocalBoundingVolume worldBBox = sequenceData.renderData.data.getWorldGeometryBBox();
            length = worldBBox.bBoxGetMaxDistToPlane(adjustedTransform.translation(), dir);
            if( length < 1.0e-6 )
              length = 1.0e-6;
          }
          Vec3 scale(length*localBVol.sc3, length*localBVol.sc3, length);
          localTransfoMat.setDiagonal(scale);
          adjustedTransform *= localTransfoMat;
          implicitPrimitiveIndex = ImplicitGeometryPrimitive_negZAxisUnitCone;
          space = TransformSpace_world;
        } else if( localBVol.type == LocalBoundingVolume_bSphere ) {
          Mat44 localTransfoMat;
          Scalar length = localBVol.sc1;
          if(length < 0) {
            //Infinite: just make sure we englobe the known world
            LocalBoundingVolume worldBBox = sequenceData.renderData.data.getWorldGeometryBBox();
            Scalar halfRadius = (worldBBox.pt2-worldBBox.pt1).length()*0.5;
            Scalar approxDistance = ((worldBBox.pt2+worldBBox.pt1)*0.5-adjustedTransform.translation()).length();
            length = halfRadius+approxDistance;
          }
          Vec3 scale(length, length, length);
          localTransfoMat.setDiagonal(scale);
          adjustedTransform *= localTransfoMat;
          implicitPrimitiveIndex = ImplicitGeometryPrimitive_unitSphere;
          space = TransformSpace_world;
        }
        //TODO: implement others!
      }
    }
    if(implicitPrimitiveIndex) {
      this.allParams.setLayer( nextTargetLayer++, sequenceData.renderDataPrimitives[implicitPrimitiveIndex].params.layers[0] );
      if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
        needToUpdateShaderParams = true;
    }

    if( !this.initialized || this.allParams.layoutOrderVersion != this.lastAllParamsLayoutVersion ) {
      if( nextTargetLayer >= this.allParams.getNumLayers() )
        this.allParams.ensureLayerExists(nextTargetLayer);
      else {
        this.allParams.resetLayer_noVersionChange(nextTargetLayer);
        this.allParams.layers[nextTargetLayer].params = RenderParamValues();
      }
      this.allParams.layers[nextTargetLayer].params.ownerName = sequenceData.renderData.data.adjustedImplicitGeometryString;
      this.allParams.layers[nextTargetLayer].params.ownerType = OwnerType_pass;
      this.allParams.layers[nextTargetLayer].params.setAsMat44( sequenceData.renderData.data.transformParamString, 1, space );
    }
    this.allParams.layers[nextTargetLayer++].params.set( RenderValueKey(0), adjustedTransform );
  }

  if( applyData.membersNeedDebugContext )
    this.debugContext = this.buildDebugContext(sequenceData, memberIndex, applyData, nextTargetLayer);

  Size numBindingKeys = applyData.memberFunctionBindings.size();
  if( numBindingKeys ) {
    if( !this.initialized ) {
      this.bindingValues = RenderParamValues();
      this.bindingTargetKeys.resize(numBindingKeys);

      if( applyData.hasStoredBindings || applyData.hasFeedbackBindings || applyData.hasRequestBindings ) {
        for( Size k = 0; k < numBindingKeys; ++k )
          this.bindingTargetKeys[k].instanceStored = sequenceData.renderDataPasses[sourcePass].applyOps[applyData.sourcePassApplyIndex].bindingStore[k];
      }
    }
    //Then: binding overrides
    //However, first, update bindings values
    for( Size k = 0; k < numBindingKeys; ++k ) {
      UInt8 instanceStored = this.bindingTargetKeys[k].instanceStored;
      if( instanceStored == StoredBinding ) {
        applyData.memberFunctionBindings[k].updateMemberParamsAndStoreResult( 
                  sequenceData, memberIndex, this.allParams, this.debugContext, this.firstMemberLayerForBindings, layerBeforeImplicits,
                  this.instanceStoredData.params, 
                  applyData.bindingTargetNames[k], this.bindingTargetKeys[k].key, !this.initialized );

        if( applyData.hasBindingTargetSpaces )
          this.instanceStoredData.params.setSpace( this.bindingTargetKeys[k].key, applyData.bindingTargetSpaces[k] );
      } else if( instanceStored == FeedbackBinding ) {
        applyData.memberFunctionBindings[k].updateMemberParamsAndStoreResult( 
                  sequenceData, memberIndex, this.allParams, this.debugContext, this.firstMemberLayerForBindings, layerBeforeImplicits,
                  sequenceData.instancesStoredData[this.instanceIndex].feedbackParams, 
                  applyData.bindingTargetNames[k], this.bindingTargetKeys[k].key, !this.initialized );
        if( applyData.hasBindingTargetSpaces )
          feedbackParams.setSpace( this.bindingTargetKeys[k].key, applyData.bindingTargetSpaces[k] );
      } else if( instanceStored == DefineBinding ) {
        applyData.memberFunctionBindings[k].updateMemberParamsAndStoreResult( 
                  sequenceData, memberIndex, this.allParams, this.debugContext, this.firstMemberLayerForBindings, layerBeforeImplicits,
                  this.bindingValues, 
                  applyData.bindingTargetNames[k], this.bindingTargetKeys[k].key, !this.initialized );

        if( applyData.hasBindingTargetSpaces )
          this.bindingValues.setSpace( this.bindingTargetKeys[k].key, applyData.bindingTargetSpaces[k] );
      } else {
        //RequestBinding
        Boolean initContainer;
        if( !sharedRequestContainer ) {
          //TODO: this is not very optimal...
          sharedRequestContainer = RenderParamValues();
          initContainer = true;
        }
        if( applyData.memberFunctionBindings[k].updateMemberParamsAndStoreResult( 
                  sequenceData, memberIndex, this.allParams, this.debugContext, this.firstMemberLayerForBindings, layerBeforeImplicits,
                  sharedRequestContainer, 
                  applyData.bindingTargetNames[k], this.bindingTargetKeys[k].key, initContainer || !this.initialized ) ) {
          //Update requests on primitives
          Size numPrimLayers = sequenceData.renderDataPrimitives[ this.primIndex ].params.getNumLayers();
          for( Size L = 0; L < numPrimLayers; ++L ) {
            Integer index = -1;
            Ref<RenderParamValues> paramValues = sequenceData.renderDataPrimitives[ this.primIndex ].params.getLayer(L);
            Size numRequests = paramValues.renderRequests.size();
            for( Size reqIndex = 0; reqIndex < numRequests; ++reqIndex ) {
              if(    paramValues.renderRequests[reqIndex].renderOwnerCookie == applyData.requestID 
                  && paramValues.renderRequests[reqIndex].name == applyData.bindingTargetNames[k] ) {
                index = reqIndex;
                break;
              }
            }
            if( index == -1 ) {
              index = numRequests;
              paramValues.renderRequests.resize(numRequests+1);
              paramValues.renderRequests[index].renderOwnerCookie = applyData.requestID;
              paramValues.renderRequests[index].name = applyData.bindingTargetNames[k];
            }
            paramValues.renderRequests[index].value = sharedRequestContainer.get(this.bindingTargetKeys[k].key);
          }
        }
      }
    }
    if( this.allParams.setLayer( nextTargetLayer++, this.bindingValues ) ) {
      if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
        needToUpdateShaderParams = true;
    }
  }

  if( applyData.hasClearColor || applyData.hasClearDepth ) {
    Size numRenderTargets = applyData.dynamicTextureFunctions.size();
    this.renderTargetClearValues.resize(numRenderTargets);

    for( Size k = 0; k < numRenderTargets; ++k )
      this.updateClearFunctions( sequenceData, applyData, applyData.dynamicTextureFunctions[k].clearFunctions, memberIndex, layerBeforeImplicits, this.renderTargetClearValues[k] );

    Size numRefineRenderTargets = applyData.refineTextureTargetInfos.size();
    this.refineRenderTargetClearValues.resize(numRefineRenderTargets);

    for( Size k = 0; k < numRefineRenderTargets; ++k )
      this.updateClearFunctions( sequenceData, applyData, applyData.refineTextureTargetInfos[k].clearFunctions, memberIndex, layerBeforeImplicits, this.refineRenderTargetClearValues[k] );
  }

  if( this.instanceStoredData ) {
    if( this.allParams.setLayer( nextTargetLayer++, this.instanceStoredData.params ) ) {
      if( getBit( this.usedShaderParamLayerBits, nextTargetLayer-1 ) )
        needToUpdateShaderParams = true;
    }
  }

  this.allParams.resize(nextTargetLayer, false);

  //Update args required for draw calls
  if( applyData.hasPerMemberDrawCallbackArgs ) {
    Size numDrawCallbacks = applyData.memberDrawCallbackFunctions.size();
    for( Size k = 0; k < numDrawCallbacks; ++k )
      applyData.memberDrawCallbackFunctions[k].synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, nextTargetLayer, !this.initialized );
  }

  if( synchronizeVersion(this.allParams.layoutOrderVersion, this.lastAllParamsLayoutVersion) ) {
    needToUpdateShaderParams = true;
    RenderParamKey geometryElementTypeKey = this.allParams.getKey( sequenceData.renderData.data.geometryElementTypeString );
    if( geometryElementTypeKey.isValid() )
      this.allParams.get( geometryElementTypeKey, this.geometryElementType );
  }

  //NOTE: there is a bug with member-specific skipBecauseOfUpdateInterval, related to generationCount & dirtification: ignoring for now.
  /*
  //Check if we should update (updateInterval)
  if( applyData.hasPerMemberUpdateInterval ) {
    if( applyData.memberUpdateIntervalFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, this.allParams.getNumLayers(), this.memberSpecificUpdateInterval == -1 ) )
      this.memberSpecificUpdateInterval = applyData.memberUpdateIntervalFunctionBindings.callIntegerFunction( this.memberSpecificUpdateInterval == -1, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
  }
  if( this.initialized && this.memberSpecificUpdateInterval > 1 && ( (sequenceData.generationCount + this.uniqueIndex) % this.memberSpecificUpdateInterval) != 0 )
    this.skipBecauseOfUpdateInterval = true;
  else
    this.skipBecauseOfUpdateInterval = false;
  */

  if( applyData.hasPerMemberCullFace ) {
    if( applyData.memberCullFaceFunctionBindings.synchronizeMemberParams( sequenceData, memberIndex, this.allParams, this.firstMemberLayerForBindings, this.allParams.getNumLayers(), !this.initialized ) )
      this.memberSpecificCullFace = applyData.memberCullFaceFunctionBindings.callIntegerFunction( !this.initialized, memberIndex, this.firstMemberLayerForBindings, this.allParams, this.debugContext );
  } else if( applyData.inheritedGroup && applyData.defaultCullFace == -1) {
    this.memberSpecificCullFace = sequencePassData.parentSequenceApplyOp.data.applyMembersData[inheritedGroupMemberIndex].memberSpecificCullFace;
  } else {
    this.memberSpecificCullFace = applyData.defaultCullFace;
  }
  if( applyData.shaderDraw && needToUpdateShaderParams /*&& !this.skipBecauseOfUpdateInterval*/ )
    this.updateShaderParams( sequenceData, applyData, viewTransfoChanged );

  //Update textures
  if( applyData.hasDynamicSizedTextureTarget || !this.initialized ) {
    if( this.updateTextures( sequenceData, sequencePassData, applyData, memberIndex )
        || !this.initialized )
      this.initTextureIDs( sequenceData, applyData );
  }
  if( this.generationCount == sequenceData.generationCount ) {
    this.initialized = true;
    applyData.generationCount = sequenceData.generationCount;
    //TODO: set parent as confirmed, recursively
  }

//if(memberIndex==0)report("MEMBERDATA "+this.getName(sequenceData)+" LAY "+this.allParams.getLayersDesc());
}

operator ParallelApplyMemberDataUpdate<<<index>>>( Size batchSize, io RenderSequenceDataStruct sequenceData, SequencePassData sequencePassData, io ApplyData applyOp, RenderParams parentParams, Boolean viewTransfoChanged ) {
  Size start = index*batchSize;
  Size end = start + batchSize;
  if( end > applyOp.applyMembersData.size() )
    end = applyOp.applyMembersData.size();

  RenderParamValues sharedRequestContainer = null;
  for( Size i = start; i < end; ++i )
    applyOp.applyMembersData[i].update( sequenceData, sequencePassData, applyOp, parentParams, viewTransfoChanged, i, sharedRequestContainer );
}

inline InstanceStoredData.getRenderTargetInfo?( io UInt32 depthBufferID, io UInt32 depthAttachmentType, io UInt32 defaultColorBufferID, io LocalL16UInt32Array allColorBufferIDs, io LocalL16UInt32Array allColorBufferTypes, io UInt32 width, io UInt32 height ) {
  Size count = this.textureData.size();
  allColorBufferIDs.resize(0);
  allColorBufferTypes.resize(0);
  defaultColorBufferID = 0;
  depthAttachmentType = this.depthAttachmentType;
  depthBufferID = 0;
  width = 1;
  height = 1;

  for( Size i = 0; i < count; ++i ) {
    UInt32 bufferID = this.textureData[i].textureContainer.bufferID;
    if( i == this.depthBufferIndex ) {
      depthBufferID = bufferID;
    } else if(bufferID) {
      allColorBufferIDs.push(bufferID);
      allColorBufferTypes.push(this.textureData[i].textureContainer.glTextureType);
      if( defaultColorBufferID == 0 )
        defaultColorBufferID = bufferID;
    }
    if(bufferID) {
      width = this.textureData[i].textureContainer.width;
      height = this.textureData[i].textureContainer.height;
    }
  }
}

inline ApplyMemberData.getTextureTargetInfoInternal?( io UInt32 depthBufferID, io UInt32 depthAttachmentType, io UInt32 defaultColorBufferID, io LocalL16UInt32Array allColorBufferIDs, io LocalL16UInt32Array allColorTypes, io UInt32 width, io UInt32 height ) {
  if( !this.instanceStoredData )
    throw("Error: this ApplyMemberData is not a texture target owner");

  this.instanceStoredData.getRenderTargetInfo( depthBufferID, depthAttachmentType, defaultColorBufferID, allColorBufferIDs, allColorTypes, width, height );
}

inline ApplyMemberData.getTextureTargetInfo?( io UInt32 depthBufferID, io UInt32 depthAttachmentType, io UInt32 defaultColorBufferID, io LocalL16UInt32Array allColorBufferIDs, io LocalL16UInt32Array allColorTypes, io UInt32 width, io UInt32 height ) {
  Ref<ApplyDataObj> applyData = this.renderTargetInstanceStoredData.ownerApplyObj;
  applyData.data.applyMembersData[this.renderTargetInstanceStoredData.ownerApplyMemberIndex].getTextureTargetInfoInternal( depthBufferID, depthAttachmentType, defaultColorBufferID, allColorBufferIDs, allColorTypes, width, height );
}

inline Size InstanceStoredData.getColorAttachmentActualIndex?( Size colorAttachmentIndex ) {
  Size index = 0;
  Size count = this.textureData.size();
  for( Size i = 0; i < count; ++i ) {
    UInt32 bufferID = this.textureData[i].textureContainer.bufferID;
    if( i == this.depthBufferIndex || bufferID == 0 )
      continue;
    if( index == colorAttachmentIndex )
      return i;
    ++index;
  }
  return 0;
}

function Color ApplyMemberData.getClearColor?( ApplyData parentApplyData, Size colorAttachmentIndex, io Boolean hasClear ) {
  if( parentApplyData.refineTextureTargetInfos.size() ) {
    for( Size i = 0; i < parentApplyData.refineTextureTargetInfos.size(); ++i ) {
      if( parentApplyData.refineTextureTargetInfos[i].colorAttachIndex == colorAttachmentIndex ) {
        hasClear = this.refineRenderTargetClearValues[i].hasClearColor;
        return this.refineRenderTargetClearValues[i].color;
      }
    }
    hasClear = false;
    return Color();
  } else {
    UInt32 index = this.instanceStoredData.getColorAttachmentActualIndex(colorAttachmentIndex);
    hasClear = this.renderTargetClearValues[index].hasClearColor;
    return this.renderTargetClearValues[index].color;
  }
}

function Scalar ApplyMemberData.getClearDepth?( ApplyData parentApplyData, io Boolean hasClear ) {
  if( this.refineRenderTargetClearValues.size() ) {
    for( Size i = 0; i < parentApplyData.refineTextureTargetInfos.size(); ++i ) {
      if( parentApplyData.refineTextureTargetInfos[i].isDepth ) {
        hasClear = this.refineRenderTargetClearValues[i].hasClearDepth;
        return this.refineRenderTargetClearValues[i].depth;
      }
    }
    hasClear = false;
    return 0;
  } else {
    Integer depthBufferIndex = this.instanceStoredData.depthBufferIndex;
    hasClear = this.renderTargetClearValues[depthBufferIndex].hasClearDepth;
    return this.renderTargetClearValues[depthBufferIndex].depth;
  }
}

function ApplyMemberData.setRenderTargetAttachmentInfoFromName?( ApplyData applyData, RenderSequenceDataStruct sequenceData, String textureName, io RefineTextureTargetInfo info ) {
  Ref<SequencePassDataObj> pass = applyData.sequencePassDataObj;
  Size sourcePassIndex = pass.data.sourcePassIndex;
  Size sourcePassApplyIndex = applyData.sourcePassApplyIndex;
  info.colorAttachIndex = -1;

  for( Size i = 0; i < sequenceData.renderDataPasses[sourcePassIndex].applyOps[sourcePassApplyIndex].renderTargets.size(); ++i ) {
    if( sequenceData.renderDataPasses[sourcePassIndex].applyOps[sourcePassApplyIndex].renderTargets[i].name == textureName ) {
      Integer depthIndex = this.instanceStoredData.depthBufferIndex;
      if( i == depthIndex )
        info.isDepth = true;
      else
        info.colorAttachIndex = i;
      break;
    }
  }
}

inline ApplyMemberData.updateRenderTargetVersion!( io RenderSequenceDataStruct sequenceData, ApplyData applyData ) {
  if( this.generationCount == sequenceData.generationCount ) {
    for( Size i = 0; i < this.instanceStoredData.textureData.size(); ++i )
      this.instanceStoredData.params.incrementValueVersion( this.instanceStoredData.textureData[i].key );
  }
}

function Ref<GroupDataObj> SequencePassDataObj.findGroup( RenderSequenceDataStruct sequenceData, String groupName, io Ref<SequencePassDataObj> pass, io Size groupDefinitionIndex ) {
  //Search from here up to parent passes, recursively.
  String currentGroupName = groupName;
  pass = this;
  Ref<ApplyDataObj> apply;
  Ref<GroupDataObj> group;

  while( pass ) {
    Size sourcePassIndex = pass.data.sourcePassIndex;

    //Check aliases if any
    if( apply ) {
      Size sourceParentApplyIndex = apply.data.sourcePassApplyIndex;
      Size numApplyAlias =  sequenceData.renderDataPasses[sourcePassIndex].applyOps[sourceParentApplyIndex].groupAliasTargets.size();
      for( Size j = 0; j < numApplyAlias; ++j ) {
        if( sequenceData.renderDataPasses[sourcePassIndex].applyOps[sourceParentApplyIndex].groupAliasTargets[j] == currentGroupName ) {
          currentGroupName = sequenceData.renderDataPasses[sourcePassIndex].applyOps[sourceParentApplyIndex].groupAliasSources[j];
          break;
        }
      }
    }

    Size passNumGroups = pass.data.groupDatas.size();
    for( groupDefinitionIndex = 0; groupDefinitionIndex < passNumGroups; ++groupDefinitionIndex ) {
      if( sequenceData.renderDataPasses[sourcePassIndex].groups[groupDefinitionIndex].name == currentGroupName ) {
        group = pass.data.groupDatas[groupDefinitionIndex];
        break;
      }
    }
    if( group )
      break;

    apply = pass.data.parentSequenceApplyOp;
    pass = pass.data.parentSequencePassObj;
  }
  return group;
}

function ApplyData.initialize!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePass, Ref<SequencePassDataObj> sequencePassObj, RenderParams parentParams, Ref<InstanceStoredData> renderTarget) {

  Size passOrder = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].passOrder;
  this.sequencePassOrder = passOrder;

  this.isElse = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].isElse;
  this.transformSpace = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].transformSpace;
  this.shaderDraw = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].shaderDraw;

  Size ownerInstance = sequencePass.ownerInstanceIndex;
  Size ownerPrimInstanceIndex = sequenceData.renderDataInstances[ ownerInstance ].primInstanceIndex;
  this.transformKey.elementIndex = ownerPrimInstanceIndex;
  Boolean hasParentSequenceApplyOp = sequencePass.parentSequenceApplyOp;

  if(sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].renderTargets.size())
    this.ownedFramebufferID = -1;

  Size numTextureRefine = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].refineRenderTargets.size();
  if(numTextureRefine) {
    if( renderTarget ) {
      Ref<ApplyDataObj> sourceApplyData = renderTarget.ownerApplyObj;
      for( Size j = 0; j < numTextureRefine; ++j ) {
        RefineTextureTargetInfo info;
        info.subIndex = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].refineRenderTargets[j].subIndex;
        sourceApplyData.data.applyMembersData[renderTarget.ownerApplyMemberIndex].setRenderTargetAttachmentInfoFromName( sourceApplyData.data, sequenceData, sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].refineRenderTargets[j].name, info );
        if( !info.isDepth && info.colorAttachIndex == -1 )
          throw("Error: "+this.getName(sequenceData)+" has 'refineRenderTarget' but no renderTarget is named '"+sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].refineRenderTargets[j].name+"'");

        info.clearFunctions.clearColorFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].refineRenderTargetClearColorKeys[j], sequenceData.functionCaller );
        info.clearFunctions.clearDepthFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].refineRenderTargetClearDepthKeys[j], sequenceData.functionCaller );

        if( info.clearFunctions.clearColorFunctionBindings.sharedKeys.needsDebugContext || info.clearFunctions.clearDepthFunctionBindings.sharedKeys.needsDebugContext )
          this.needsDebugContext = true;

        if( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].refineRenderTargetClearColorKeys[j].isValid ) {
          info.clearFunctions.hasClearColor = true;
          this.hasClearColor = true;

          if( info.clearFunctions.clearColorFunctionBindings.isDynamic() )
            this.hasDynamicClearColor = true;
        }

        if( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].refineRenderTargetClearDepthKeys[j].isValid ) {
          info.clearFunctions.hasClearDepth = true;
          this.hasClearDepth = true;

          if( info.clearFunctions.clearColorFunctionBindings.isDynamic() )
            this.hasDynamicClearDepth = true;
        }

        this.refineTextureTargetInfos.push(info);
      }
    } else
      throw("Error: "+this.getName(sequenceData)+" has 'refineRenderTarget' but parent passes define no renderTarget");
  }

  Size numBindings = sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].bindingKeys.size();
  this.memberFunctionBindings.resize(numBindings);

  if(numBindings)
    this.membersDoSomething = true;

  this.bindingTargetNames = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].bindingTargets;
  this.bindingTargetSpaces = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].bindingSpaces;

  for( Size j = 0; j < numBindings; ++j ) {
    if(this.bindingTargetSpaces[j] != TransformSpace_none)
      this.hasBindingTargetSpaces = true;

    this.memberFunctionBindings[j].initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].bindingKeys[j], sequenceData.functionCaller );

    if( this.memberFunctionBindings[j].sharedKeys.needsDebugContext )
      this.membersNeedDebugContext = true;

    if( this.memberFunctionBindings[j].isDynamic() ) {
      this.hasDynamicBindings = true;
      if( this.memberFunctionBindings[j].hasMemberBindings() && this.memberFunctionBindings[j].hasFunctionCall() )
        this.hasPerMemberFunctionBindings = true;
    }
    UInt8 bindingStore = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].bindingStore[j];
    if( bindingStore == StoredBinding )
      this.hasStoredBindings = true;
    else if( bindingStore == FeedbackBinding )
      this.hasFeedbackBindings = true;
    else if( bindingStore == RequestBinding )
      this.hasRequestBindings = true;
  }

  if( this.hasRequestBindings )
    this.requestID = sequenceData.nextRequestID++;

  Size numFunctions = sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].drawCallbackKeys.size();
  this.memberDrawCallbackFunctions.resize(numFunctions);
  this.isPreDrawCallback = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].isPreDrawCallback;

  if(numFunctions)
    this.membersDoSomething = true;

  for( Size j = 0; j < numFunctions; ++j ) {
    this.memberDrawCallbackFunctions[j].initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].drawCallbackKeys[j], sequenceData.functionCaller );
    if( this.memberDrawCallbackFunctions[j].sharedKeys.needsDebugContext )
      this.membersNeedDebugContext = true;

    if( this.memberDrawCallbackFunctions[j].isDynamic() ) {
      this.hasDynamicDrawCallbackArgs = true;
      if( this.memberDrawCallbackFunctions[j].hasMemberBindings() && this.memberDrawCallbackFunctions[j].hasFunctionCall() )
        this.hasPerMemberDrawCallbackArgs = true;
    }
    if( this.isPreDrawCallback[j] )
      this.hasPreDrawCallback = true;
    else
      this.hasPostDrawCallback = true;
  }

  Size numTextures = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].renderTargets.size();
  this.dynamicTextureFunctions.resize(numTextures);

  for( Size j = 0; j < numTextures; ++j ) {
    this.dynamicTextureFunctions[j].widthFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetWidthKeys[j], sequenceData.functionCaller );
    this.dynamicTextureFunctions[j].heightFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetHeightKeys[j], sequenceData.functionCaller );
    this.dynamicTextureFunctions[j].depthFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetDepthKeys[j], sequenceData.functionCaller );
    this.dynamicTextureFunctions[j].sourceFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetSourceKeys[j], sequenceData.functionCaller );
    this.dynamicTextureFunctions[j].clearFunctions.clearColorFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetClearColorKeys[j], sequenceData.functionCaller );
    this.dynamicTextureFunctions[j].clearFunctions.clearDepthFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetClearDepthKeys[j], sequenceData.functionCaller );

    if( this.dynamicTextureFunctions[j].widthFunctionBindings.sharedKeys.needsDebugContext ||
        this.dynamicTextureFunctions[j].heightFunctionBindings.sharedKeys.needsDebugContext ||
        this.dynamicTextureFunctions[j].depthFunctionBindings.sharedKeys.needsDebugContext ||
        this.dynamicTextureFunctions[j].sourceFunctionBindings.sharedKeys.needsDebugContext ||
        this.dynamicTextureFunctions[j].clearFunctions.clearColorFunctionBindings.sharedKeys.needsDebugContext ||
        this.dynamicTextureFunctions[j].clearFunctions.clearDepthFunctionBindings.sharedKeys.needsDebugContext )
      this.membersNeedDebugContext = true;

    if( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetClearColorKeys[j].isValid ) {
      this.dynamicTextureFunctions[j].clearFunctions.hasClearColor = true;
      this.hasClearColor = true;
      if( this.dynamicTextureFunctions[j].clearFunctions.clearColorFunctionBindings.isDynamic() )
        this.hasDynamicClearColor = true;
    }

    if( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].renderTargetClearDepthKeys[j].isValid ) {
      this.dynamicTextureFunctions[j].clearFunctions.hasClearDepth = true;
      this.hasClearDepth = true;
      if( this.dynamicTextureFunctions[j].clearFunctions.clearDepthFunctionBindings.isDynamic() )
        this.hasDynamicClearDepth = true;
    }

    if(  this.dynamicTextureFunctions[j].widthFunctionBindings.isDynamic() 
      || this.dynamicTextureFunctions[j].heightFunctionBindings.isDynamic()
      || this.dynamicTextureFunctions[j].depthFunctionBindings.isDynamic()
      || this.dynamicTextureFunctions[j].sourceFunctionBindings.isDynamic() ) {
      this.hasDynamicSizedTextureTarget = true;
    }
    if( this.dynamicTextureFunctions[j].sourceFunctionBindings.isValid() )
      this.hasSharedRenderTargets = true;
  }

  this.defaultUpdateInterval = 1;

  if(sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].updateIntervalKeys.isValid) {
    if( this.ownedFramebufferID == 0 )
      report( "Warning: pass '" + sequenceData.renderDataPasses[sequencePass.sourcePassIndex].name + "' has 'intervalUpdate' param but has no render target: ignoring" );
    else {
      this.memberUpdateIntervalFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].updateIntervalKeys, sequenceData.functionCaller );
      if( this.memberUpdateIntervalFunctionBindings.sharedKeys.needsDebugContext )
        this.membersNeedDebugContext = true;

      if( this.memberUpdateIntervalFunctionBindings.isDynamic() ) {
        this.hasDynamicUpdateInterval = true;
        if( this.memberUpdateIntervalFunctionBindings.hasMemberBindings() )
          this.hasPerMemberUpdateInterval = true;
      } else {
        //Constant value: cache it...
        parentParams.get( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].updateIntervalKeys.keys[0].key, this.defaultUpdateInterval );
      }
    }
  }

  this.defaultCullFace = -1;

  if(sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].cullFaceKeys.isValid) {
    this.memberCullFaceFunctionBindings.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].cullFaceKeys, sequenceData.functionCaller );
    if( this.memberCullFaceFunctionBindings.sharedKeys.needsDebugContext )
      this.membersNeedDebugContext = true;

    if( this.memberCullFaceFunctionBindings.isDynamic() ) {
      this.hasDynamicCullFace = true;
      if( this.memberCullFaceFunctionBindings.hasMemberBindings() )
        this.hasPerMemberCullFace = true;
    } else {
      //Constant value: cache it...
      parentParams.get( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].cullFaceKeys.keys[0].key, this.defaultCullFace );
    }
  } else {
    this.inheritsCullFace = true;
    this.parentHasDynamicCullFace = hasParentSequenceApplyOp ? (sequencePass.parentSequenceApplyOp.data.parentHasDynamicCullFace || sequencePass.parentSequenceApplyOp.data.hasDynamicCullFace) : false;
  }

  if( this.hasDynamicCullFace || this.parentHasDynamicCullFace )
    this.membersDoSomething = true;

  if( this.shaderDraw )
    this.membersDoSomething = true;

  this.implicitGeometry = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].implicitGeometry;
  if( this.implicitGeometry != ImplicitGeomType_none )
    this.membersDoSomething = true;

  this.hasFlags = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].flags.size() > 0;
  if( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].conditionKeys.isValid ) {
    this.hasCondition = true;
    this.conditionFunctionKeys.initialize( sequenceData.renderDataPassFunctionKeys[sequencePass.sourcePassIndex].applyKeys[this.sourcePassApplyIndex].conditionKeys, sequenceData.functionCaller );
    if( this.conditionFunctionKeys.sharedKeys.needsDebugContext )
      this.needsDebugContext = true;
  }

  if( sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].depthMask == -1 )
    this.disablesDepthWrites = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.disablesDepthWrites : false;//Copy value from parent pass
  else
    this.disablesDepthWrites = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].depthMask == 0;

  if( sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].polygonOffsetFactor == -1.0 || sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].polygonOffsetUnits == -1.0 ) {
    this.polygonOffsetFactor = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.polygonOffsetFactor : 0;//Copy value from parent pass
    this.polygonOffsetUnits = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.polygonOffsetUnits : 0;//Copy value from parent pass
    this.hasPolygonOffset = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.hasPolygonOffset : false;//Copy value from parent pass
  } else {
    this.polygonOffsetFactor = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].polygonOffsetFactor;
    this.polygonOffsetUnits = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].polygonOffsetUnits;
    this.hasPolygonOffset = this.polygonOffsetFactor > 0 && this.polygonOffsetUnits > 0;
  }

  if( sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].blendModeSfactor == GL_NONE && sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].blendModeDfactor == GL_NONE ) {
    this.blendModeSfactor = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.blendModeSfactor : 0;
    this.blendModeDfactor = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.blendModeDfactor : 0;
    this.hasBlend = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.hasBlend : false;
  } else {
    this.blendModeSfactor = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].blendModeSfactor;
    this.blendModeDfactor = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].blendModeDfactor;
    this.hasBlend = this.blendModeSfactor != GL_NONE && this.blendModeDfactor != GL_NONE;
  }

  if( sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].depthFunc == -1 )
    this.depthFunc = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.depthFunc : GL_LESS;//Copy value from parent pass
  else
    this.depthFunc = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].depthFunc;

  String groupName = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].group;
  this.group = null;
  if( groupName ) {
    Size groupDefinitionIndex;
    Ref<SequencePassDataObj> pass;
    this.group = sequencePassObj.findGroup( sequenceData, groupName, pass, groupDefinitionIndex );

    if( !this.group )
      throw("Error: " + this.getName(sequenceData) + " refers an undefined group: " + groupName);

    if( pass === sequencePassObj && this.sequencePassOrder < this.group.data.sequencePassOrder )
      throw("Error: " + this.getName(sequenceData) + " refers a group which is defined afterward: " + groupName);
    this.inheritedSubGroup = this.group.data.subGroup;
    this.inheritedGroup = this.inheritedSubGroup;
  } else {
    Ref<GroupDataObj> nullGroup;
    this.group = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.group : nullGroup;
    if( hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.perMemberPass : false ) {
      this.group = sequencePass.privatePerMemberPassGroup;
      this.inheritedSubGroup = true;
    } else
      this.group = hasParentSequenceApplyOp ? sequencePass.parentSequenceApplyOp.data.group : nullGroup;

    this.inheritedGroup = this.group;
  }

  this.perMemberPass = true;
  String passName = sequenceData.renderDataPasses[sequencePass.sourcePassIndex].applyOps[this.sourcePassApplyIndex].passName;
  if( passName != '' ) {
    this.applySourcePassIndex = sequenceData.renderData.data.primitiveNameToIndex[OwnerType_pass].get( passName, 0 );
    if( this.applySourcePassIndex == 0 )
      throw("Error: " + this.getName(sequenceData) + " refers an undefined pass: " + passName);
    else {
      Boolean requiresPerMemberPass = !this.group || this.transformSpace || this.ownedFramebufferID != 0;
      //Render target split causes bugs: to improve. Note: might not be a big deal; clearColor / clearDepth requires per-member passes anyway.
      this.perMemberPass = requiresPerMemberPass
                        || sequenceData.renderDataPasses[this.applySourcePassIndex].groups.size() != 0;
      if( !this.perMemberPass ) {
        Size numApplyOps = sequenceData.renderDataPasses[this.applySourcePassIndex].applyOps.size();
        for( Size i = 0; i < numApplyOps; ++i ) {
          if( sequenceData.renderDataPasses[this.applySourcePassIndex].applyOps[i].group ) {
            this.perMemberPass = true;
            break;
          }
        }
      }
      //TODO: this is hacky; add more info to applyOps
      //TODO: splitting per member because of a group which is not a subgroup is BAD if that group doesn't even depend on the members' values...
      if( this.perMemberPass && !requiresPerMemberPass ) {
        Size numGroups = sequenceData.renderDataPasses[this.applySourcePassIndex].groups.size();
        for( Size i = 0; i < numGroups; ++i ) {
          if( sequenceData.renderDataPasses[this.applySourcePassIndex].groups[i].subGroup ) {
            this.perMemberPass = false;
            break;
          }
        }
      }
      //TODO: there are probably other conditions to check!
      //TODO: if applied groups are filtered from our group, then permit it...
      //TODO: if groups have nothing to do with the member params, move them down at preprocessing stage.
    }
  }
  if( this.needsDebugContext )
    this.debugContext = this.buildDebugContext(sequenceData, parentParams);
}

function ApplyData.updatetransformSpaces!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePass, RenderParams parentParams) {
  ///////////////XFO PARAMS
  if(this.passValues == null) {
    this.passValues = RenderParamValues();
    this.passValues.ownerType = OwnerType_pass;
    Size sourcePass = sequencePass.sourcePassIndex;
    this.passValues.ownerName = sequenceData.renderDataPasses[sourcePass].name;
  }
  this.viewTransfoChanged = this.transformKey.synchronize( parentParams, sequenceData.renderData.data.transformParamString );

  if(!this.viewTransformKey.isValid()) {
    this.viewTransformKey.valueKey = this.passValues.setAsMat44(sequenceData.renderData.data.viewTransformParamString, 1, TransformSpace_world );
    this.invViewTransformKey.valueKey = this.passValues.setAsMat44(sequenceData.renderData.data.invViewTransformParamString, 1, TransformSpace_world );
  }
  this.viewTransformKey.layerIndex = parentParams.getNumLayers();//Always set it in case layout changed
  this.invViewTransformKey.layerIndex = parentParams.getNumLayers();

  if(this.viewTransfoChanged) {
    Mat44 transform;
    parentParams.get( this.transformKey.key, transform, this.transformKey.elementIndex );
    this.passValues.set( this.viewTransformKey.valueKey, transform );

    Mat44 invTransform = transform.inverse_safe();
    this.passValues.set( this.invViewTransformKey.valueKey, invTransform );
  }

  this.projectionChanged = this.projectionKey.synchronize( parentParams, sequenceData.renderData.data.projectionParamString );
  if( this.projectionChanged && this.projectionKey.isValid() ) {
    if( !this.invProjectionKey.isValid() )
      this.invProjectionKey = this.passValues.setAsMat44(sequenceData.renderData.data.invProjectionParamString, 1, TransformSpace_world );

    Mat44 projTransform;
    parentParams.get( this.projectionKey.key, projTransform );
    Mat44 invProjTransform = projTransform.inverse_safe();
    this.passValues.set( this.invProjectionKey, invProjTransform );
  }
}

function ApplyData.update!( io RenderSequenceDataStruct sequenceData, SequencePassData sequencePass, Ref<SequencePassDataObj> sequencePassObj, Ref<ApplyDataObj> thisObj, RenderParams parentParams, Size applyOpMemberIndex, Ref<InstanceStoredData> renderTarget, Boolean reInitParams) {
  if( sequenceData.enableProfiling )
    this.profileStart = getCurrentTicks();

  Boolean initialized = sequencePass.initialized;
  Size sourcePass = sequencePass.sourcePassIndex;
  Ref<ApplyDataObj> parentApplyOp = sequencePass.parentSequenceApplyOp;

  if( this.hasFlags && !this.disabled ) {
    UInt32 prevFlags = this.flagBits;
    Size numFlags = sequenceData.renderDataPasses[sourcePass].applyOps[this.sourcePassApplyIndex].flags.size();
    Boolean initialize = synchronizeVersion( parentParams.versions.topo, this.flagLastParamsTopoVersion );
    for( Size j = 0; j < numFlags; ++j ) {
      if( initialize ) {
        RenderParamKey flagKey = parentParams.getKey( sequenceData.renderDataPasses[sourcePass].applyOps[this.sourcePassApplyIndex].flags[j].name );
        setBit( this.flagBits, j, flagKey.isValid() );
      }
    }
    if( reInitParams || prevFlags != this.flagBits )
      this.flagsOpsResult = evalFlagCondition( this.flagBits, sequenceData.renderDataPasses[sourcePass].applyOps[this.sourcePassApplyIndex].flagOpsBits );
    if( !this.flagsOpsResult )
      this.disabled = true;
  }

  if( this.hasCondition && !this.disabled ) {
    this.conditionFunctionKeys.synchronizePassParams( sequenceData, parentParams, !initialized || reInitParams );
    if( this.conditionFunctionKeys.passParamsGenerationCount == sequenceData.generationCount )
      this.conditionResult = this.conditionFunctionKeys.callBooleanFunction( !initialized || reInitParams, 0, 0, parentParams, this.debugContext );
    if( !this.conditionResult )
      this.disabled = true;
  }
  Size numBindings = this.memberFunctionBindings.size();
  Size numDrawCallbacks = this.memberDrawCallbackFunctions.size();
  Size numTextures = this.dynamicTextureFunctions.size();
  Size numRefineTextures = this.refineTextureTargetInfos.size();

  if( !this.disabled ) {

    if( parentApplyOp ) {
      if( parentApplyOp.data.transformSpace ) {
        if( this.inheritedGroup )//NOTE: for now we are forced in per-member-pass. TODO: move this to per-member update!!
          this.updatetransformSpaces( sequenceData, sequencePass, parentApplyOp.data.applyMembersData[applyOpMemberIndex].allParams);
        else
          this.updatetransformSpaces( sequenceData, sequencePass, parentParams);
      } else {
        this.viewTransformKey = parentApplyOp.data.viewTransformKey;
        this.invViewTransformKey = parentApplyOp.data.invViewTransformKey;
        this.projectionKey = parentApplyOp.data.projectionKey;
        this.invProjectionKey = parentApplyOp.data.invProjectionKey;

        this.projectionChanged = parentApplyOp.data.projectionChanged || reInitParams;
        this.viewTransfoChanged = parentApplyOp.data.viewTransfoChanged || reInitParams;
      }
    }

    //Don't initialize bindings if we are disabled; the binding params might not even exist...
    if( this.hasDynamicBindings ) {
      for( Size j = 0; j < numBindings; ++j ) {
        if( this.memberFunctionBindings[j].isDynamic() )
          this.memberFunctionBindings[j].synchronizePassParams( sequenceData, parentParams, reInitParams );
      }
    }

    if( this.hasDynamicDrawCallbackArgs ) {
      for( Size j = 0; j < numDrawCallbacks; ++j ) {
        if( this.memberDrawCallbackFunctions[j].isDynamic() )
          this.memberDrawCallbackFunctions[j].synchronizePassParams( sequenceData, parentParams, reInitParams );
      }
    }

    if( this.hasDynamicSizedTextureTarget ) {
      for( Size j = 0; j < numTextures; ++j ) {
        this.dynamicTextureFunctions[j].widthFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
        this.dynamicTextureFunctions[j].heightFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
        this.dynamicTextureFunctions[j].depthFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
        this.dynamicTextureFunctions[j].sourceFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
      }
    }

    if( this.hasDynamicClearColor ) {
      for( Size j = 0; j < numTextures; ++j )
        this.dynamicTextureFunctions[j].clearFunctions.clearColorFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
      for( Size j = 0; j < numRefineTextures; ++j )
        this.refineTextureTargetInfos[j].clearFunctions.clearColorFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
    }

    if( this.hasDynamicClearDepth ) {
      for( Size j = 0; j < numTextures; ++j )
        this.dynamicTextureFunctions[j].clearFunctions.clearDepthFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
      for( Size j = 0; j < numRefineTextures; ++j )
        this.refineTextureTargetInfos[j].clearFunctions.clearDepthFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
    }

    if( this.hasDynamicUpdateInterval )
      this.memberUpdateIntervalFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );

    if( this.hasDynamicCullFace )
      this.memberCullFaceFunctionBindings.synchronizePassParams( sequenceData, parentParams, reInitParams );
    else if( this.inheritsCullFace ){
      //Propagate from parent member. TODO: reduce overhead of propagation...
      if( parentApplyOp ) {
        this.defaultCullFace = parentApplyOp.data.applyMembersData[applyOpMemberIndex].memberSpecificCullFace;
      } else
        this.defaultCullFace = GL_BACK;
    }
  }
    
  Size numMembers = this.disabled ? 0 : (this.group ? this.group.data.memberInstances.size() : 1);
  Boolean groupChanged = (this.group ? synchronizeVersion( this.group.data.generationCount, this.groupGenerationCount ) : false)
                      || numMembers != this.applyMembersData.size(); //If 'disabled' state changed...
  Boolean someMembersNeedInit;

  if( groupChanged ) {
    this.generationCount = sequenceData.generationCount;//Required when goes from N to 0 (with 0 -> no memberData gencount)
    Size prevNumMembers = this.applyMembersData.size();
    Size noMemberSourceGroupMapping[];
    this.memberSourceGroupMapping = this.group ? this.group.data.memberSourceGroupMapping : noMemberSourceGroupMapping;
    Boolean prevIndexRemap = (prevNumMembers > 0 && numMembers == 0) || (Boolean(this.group) && this.group.data.prevMembersNewIndex.size() != 0);
    if( prevIndexRemap ) {
      //Remap prev members that were just moved
      this.generationCount = sequenceData.generationCount;
      UInt32 prevMembersNewIndex[];
      if(this.group)
        prevMembersNewIndex = this.group.data.prevMembersNewIndex;

      for( Size j = 0; j < prevNumMembers; ++j ) {
        UInt32 newIndex = numMembers != 0 ? prevMembersNewIndex[j] : InvalidIndex;
        if( newIndex != j ) {
          if( newIndex == InvalidIndex ) {
            //Cleanup member & sub-passes recursively
            this.applyMembersData[j].cleanup( sequenceData, this );
          } else {
            //Just move; no cleanup required
            this.applyMembersData[newIndex] = this.applyMembersData[j];
            Ref<InstanceStoredData> instanceStoredData = this.applyMembersData[newIndex].instanceStoredData;
            if( Boolean(instanceStoredData) && instanceStoredData.ownerApplyObj === thisObj && instanceStoredData.ownerApplyMemberIndex == j )
              instanceStoredData.ownerApplyMemberIndex = newIndex;

            for( Size k = 0; k < numBindings; ++k )
              this.memberFunctionBindings[k].moveMember( j, newIndex );

            for( Size k = 0; k < numDrawCallbacks; ++k )
              this.memberDrawCallbackFunctions[k].moveMember( j, newIndex );

            for( Size k = 0; k < numTextures; ++k ) {
              this.dynamicTextureFunctions[k].widthFunctionBindings.moveMember( j, newIndex );
              this.dynamicTextureFunctions[k].heightFunctionBindings.moveMember( j, newIndex );
              this.dynamicTextureFunctions[k].depthFunctionBindings.moveMember( j, newIndex );
              this.dynamicTextureFunctions[k].sourceFunctionBindings.moveMember( j, newIndex );
              this.dynamicTextureFunctions[k].clearFunctions.clearColorFunctionBindings.moveMember( j, newIndex );
              this.dynamicTextureFunctions[k].clearFunctions.clearDepthFunctionBindings.moveMember( j, newIndex );
            }

            for( Size k = 0; k < numRefineTextures; ++k ) {
              this.refineTextureTargetInfos[k].clearFunctions.clearColorFunctionBindings.moveMember( j, newIndex );
              this.refineTextureTargetInfos[k].clearFunctions.clearDepthFunctionBindings.moveMember( j, newIndex );
            }

            this.memberUpdateIntervalFunctionBindings.moveMember( j, newIndex );
            this.memberCullFaceFunctionBindings.moveMember( j, newIndex );
          }
          ApplyMemberData defaultValue;
          defaultValue.memberSpecificUpdateInterval = -1;
          this.applyMembersData[j] = defaultValue;

          for( Size k = 0; k < numBindings; ++k )
            this.memberFunctionBindings[k].resetMember(j);

          for( Size k = 0; k < numDrawCallbacks; ++k )
            this.memberDrawCallbackFunctions[k].resetMember(j);

          for( Size k = 0; k < numTextures; ++k ) {
            this.dynamicTextureFunctions[k].widthFunctionBindings.resetMember( j );
            this.dynamicTextureFunctions[k].heightFunctionBindings.resetMember( j );
            this.dynamicTextureFunctions[k].depthFunctionBindings.resetMember( j );
            this.dynamicTextureFunctions[k].sourceFunctionBindings.resetMember( j );
            this.dynamicTextureFunctions[k].clearFunctions.clearColorFunctionBindings.resetMember( j );
            this.dynamicTextureFunctions[k].clearFunctions.clearDepthFunctionBindings.resetMember( j );
          }

          for( Size k = 0; k < numRefineTextures; ++k ) {
            this.refineTextureTargetInfos[k].clearFunctions.clearColorFunctionBindings.resetMember( j );
            this.refineTextureTargetInfos[k].clearFunctions.clearDepthFunctionBindings.resetMember( j );
          }

          this.memberUpdateIntervalFunctionBindings.resetMember(j);
          this.memberCullFaceFunctionBindings.resetMember(j);
        }
      }
    }
    if( numMembers != prevNumMembers ) {
      this.applyMembersData.resize( numMembers );

      for( Size k = 0; k < numBindings; ++k )
        this.memberFunctionBindings[k].resize( numMembers );

      for( Size k = 0; k < numDrawCallbacks; ++k )
        this.memberDrawCallbackFunctions[k].resize( numMembers );

      for( Size k = 0; k < numTextures; ++k ) {
        this.dynamicTextureFunctions[k].widthFunctionBindings.resize( numMembers );
        this.dynamicTextureFunctions[k].heightFunctionBindings.resize( numMembers );
        this.dynamicTextureFunctions[k].depthFunctionBindings.resize( numMembers );
        this.dynamicTextureFunctions[k].sourceFunctionBindings.resize( numMembers );
        this.dynamicTextureFunctions[k].clearFunctions.clearColorFunctionBindings.resize( numMembers );
        this.dynamicTextureFunctions[k].clearFunctions.clearDepthFunctionBindings.resize( numMembers );
      }

      for( Size k = 0; k < numRefineTextures; ++k ) {
        this.refineTextureTargetInfos[k].clearFunctions.clearColorFunctionBindings.resize( numMembers );
        this.refineTextureTargetInfos[k].clearFunctions.clearDepthFunctionBindings.resize( numMembers );
      }
      this.memberUpdateIntervalFunctionBindings.resize( numMembers );
      this.memberCullFaceFunctionBindings.resize( numMembers );
    }

    for( Size j = 0; j < numMembers; ++j ) {
      Boolean init = !this.applyMembersData[j].initialized;
      if( init ) {
        someMembersNeedInit = true;
        this.applyMembersData[j].sequenceApplyDataObj = thisObj;
        Size instanceIndex = this.group ? this.group.data.memberInstances[ j ] : sequencePass.ownerInstanceIndex;
        this.applyMembersData[j].instanceIndex = instanceIndex;
        this.applyMembersData[j].primIndex = sequenceData.renderDataInstances[ instanceIndex ].primIndex;
        this.applyMembersData[j].drawInstanceCount = -1;

        //if(this.inheritedGroup && !this.perMemberPass)
        //  this.applyMembersData[j].renderTargetInstanceStoredData = parentApplyOp.applyMembersData[j].renderTargetInstanceStoredData;
        //else
        this.applyMembersData[j].renderTargetInstanceStoredData = renderTarget;

        this.applyMembersData[j].uniqueIndex = sequenceData.nextApplyMemberDataUniqueIndex++;
        this.applyMembersData[j].init_noThreadSafe( sequenceData, sequencePass, sequencePassObj, thisObj, this, j );
      }
    }
  }

  Size batchSize, numBatches;
  Size workload = 1 * (this.membersDoSomething?2:1) * (this.shaderDraw?3:1) * (this.hasPerMemberFunctionBindings?2:1) * ((this.hasPerMemberUpdateInterval || this.hasPerMemberCullFace || this.implicitGeometry != ImplicitGeomType_none)?2:1);

  GetBatchSizeAndCountForParallel( numMembers, workload, 100, numBatches, batchSize );
  if( numBatches > 1 ) {
    ParallelApplyMemberDataUpdate<<<numBatches>>>(batchSize, sequenceData, sequencePass, this, parentParams, this.viewTransfoChanged || this.projectionChanged );
  } else {
    RenderParamValues sharedRequestContainer;
    for( Size j = 0; j < numMembers; ++j ) {
      this.applyMembersData[j].update( sequenceData, sequencePass, this, parentParams, this.viewTransfoChanged || this.projectionChanged, j, sharedRequestContainer );
    }
  }

  // Create sub-apply-pass, if required
  if( (this.applySourcePassIndex != 0) && !this.perMemberPass ) {
    if( numMembers != 0 ) {
      if( !this.applySubPassObj ) {
        //Create
        UInt32 applySubPassIndex;
        if( sequenceData.passesDataIndexPool.getFreeIndex( applySubPassIndex ) ) {
          sequenceData.passesData.resize( sequenceData.passesDataIndexPool.getIndexEnd() );
          sequenceData.passesData[applySubPassIndex] = SequencePassDataObj();
          sequenceData.passesData[applySubPassIndex].data.sequenceDataObj = sequenceData.selfObj;
          sequenceData.passesData[applySubPassIndex].poolIndex = applySubPassIndex;
        }
        Ref<SequencePassDataObj> applySubPass = sequenceData.passesData[applySubPassIndex];
        this.applySubPassObj = applySubPass;

        applySubPass.data.ownerPrimIndex = sequencePass.ownerPrimIndex;
        applySubPass.data.ownerInstanceIndex = sequencePass.ownerInstanceIndex;
        applySubPass.data.parentSequencePassObj = sequencePassObj;
        applySubPass.data.parentSequenceApplyOp = thisObj;
        applySubPass.data.sourcePassIndex = this.applySourcePassIndex;

        applySubPass.data.passOrderStack = sequencePass.passOrderStack;
        applySubPass.data.passOrderStack.push(this.sequencePassOrder);
      }
    } else {
      if( this.applySubPassObj ) {
        //Cleanup
        Ref<SequencePassDataObj> applySubPass = this.applySubPassObj;
        applySubPass.cleanup( sequenceData );
        this.applySubPassObj = null;
      }
    }
  }

  if( sequenceData.enableProfiling )
    this.profileEnd = getCurrentTicks();
}

function String SequencePassData.getName( RenderData renderData ) {
  return renderData.data.passes[this.sourcePassIndex].name;
}

function String SequencePassData.getProfilingDesc(String indent, RenderSequenceDataStruct sequenceData) {
  String s;
  s += indent+"Pass "+this.getName(sequenceData.renderData)+": "+Size(getSecondsBetweenTicks(this.profileStart, this.profileEnd)*1000000.0)+"\n";
  String subIndent = indent+'  ';
  for( Size i = 0; i < this.groupDatas.size(); ++i ) {
    Ref<GroupDataObj> group = this.groupDatas[i];
    s += subIndent+"Group "+group.data.getName(sequenceData)+": "+Size(getSecondsBetweenTicks(group.data.profileStart, group.data.profileEnd)*1000000.0)+"\n";
  }
  for( Size i = 0; i < this.applyDatas.size(); ++i ) {
    if( !this.applyDatas[i].data.disabled ) {
      s += subIndent+"Apply "+this.applyDatas[i].data.getName(sequenceData)+": "+Size(getSecondsBetweenTicks(this.applyDatas[i].data.profileStart, this.applyDatas[i].data.profileEnd)*1000000.0)+"\n";

      if( this.applyDatas[i].data.applySubPassObj ) {
        Ref<SequencePassDataObj> pass = this.applyDatas[i].data.applySubPassObj;
        s += pass.data.getProfilingDesc(subIndent+'  ', sequenceData);
      }

      for( Size j = 0; j < this.applyDatas[i].data.applyMembersData.size(); ++j ) {
        if( this.applyDatas[i].data.applyMembersData[j].memberSubPassObj ) {
          Ref<SequencePassDataObj> pass = this.applyDatas[i].data.applyMembersData[j].memberSubPassObj;
          s += pass.data.getProfilingDesc(subIndent+'  ', sequenceData);
        }
      }
    }
  }
  return s;
}

function SequencePassData.update!( io RenderSequenceDataStruct sequenceData, Ref<SequencePassDataObj> thisObj, RenderParams parentParams, Size applyOpMemberIndex, Ref<InstanceStoredData> renderTarget ) {
  if( sequenceData.enableProfiling )
    this.profileStart = getCurrentTicks();
//report("PASS "+this.getName(sequenceData.renderData)+" LAY "+parentParams.getLayersDesc());

  Boolean somethingChanged = false;
  Size sourcePass = this.sourcePassIndex;
  Size numGroups = sequenceData.renderDataPasses[sourcePass].groups.size();
  Size numApplyOps = sequenceData.renderDataPasses[sourcePass].applyOps.size();
  Boolean initialized = this.initialized;

  if( !initialized ) {
    somethingChanged = true;

    //Initialize groups
    if( Boolean(this.parentSequenceApplyOp) && this.parentSequenceApplyOp.data.perMemberPass ) {
      UInt32 privatePerMemberPassGroupIndex;
      if( sequenceData.groupsDataIndexPool.getFreeIndex( privatePerMemberPassGroupIndex ) ) {
        sequenceData.groupsData.resize( sequenceData.groupsDataIndexPool.getIndexEnd() );
        sequenceData.groupsData[privatePerMemberPassGroupIndex] = GroupDataObj();
        sequenceData.groupsData[privatePerMemberPassGroupIndex].poolIndex = privatePerMemberPassGroupIndex;
      }
      this.privatePerMemberPassGroup = sequenceData.groupsData[privatePerMemberPassGroupIndex];

      this.privatePerMemberPassGroup.data.sequencePassDataObj = thisObj;
      this.privatePerMemberPassGroup.data.sourcePassGroupIndex = InvalidIndex;

      this.privatePerMemberPassGroup.data.sourceGroupDataObj = this.parentSequenceApplyOp.data.group;
      this.privatePerMemberPassGroup.data.subGroup = true;

      this.privatePerMemberPassGroup.data.generationCount = sequenceData.generationCount;

      Size ownerType = sequenceData.renderDataPrimitives[ this.ownerPrimIndex ].ownerType;
      this.privatePerMemberPassGroup.data.types.push(ownerType);
      setBit( this.privatePerMemberPassGroup.data.memberTypeFlags, ownerType );

      this.privatePerMemberPassGroup.data.memberInstances.push(this.ownerInstanceIndex);
      this.privatePerMemberPassGroup.data.memberSourceGroupMapping.resize(1);

      this.privatePerMemberPassGroup.initStats( sequenceData );
    }

    for( Size i = 0; i < numGroups; ++i ) {
      UInt32 sequenceGroupIndex;
      if( sequenceData.groupsDataIndexPool.getFreeIndex( sequenceGroupIndex ) ) {
        sequenceData.groupsData.resize( sequenceData.groupsDataIndexPool.getIndexEnd() );
        sequenceData.groupsData[sequenceGroupIndex] = GroupDataObj();
        sequenceData.groupsData[sequenceGroupIndex].poolIndex = sequenceGroupIndex;
      }
      Ref<GroupDataObj> sequenceGroup = sequenceData.groupsData[sequenceGroupIndex];

      this.groupDatas.push(sequenceGroup);

      sequenceGroup.data.sequencePassDataObj = thisObj;
      sequenceGroup.data.sourcePassGroupIndex = i;
      sequenceGroup.initStats( sequenceData );
    }
    //Set source & complementary group indices
    for( Size i = 0; i < numGroups; ++i ) {
      Ref<GroupDataObj> sequenceGroup = this.groupDatas[i];

      Size passOrder = sequenceData.renderDataPasses[sourcePass].groups[i].passOrder;
      sequenceGroup.data.sequencePassOrder = passOrder;

      if( sequenceData.renderDataPasses[sourcePass].groups[i].sourceGroup ) {

        Size groupDefinitionIndex;
        Ref<SequencePassDataObj> pass;
        sequenceGroup.data.sourceGroupDataObj = thisObj.findGroup( sequenceData, sequenceData.renderDataPasses[sourcePass].groups[i].sourceGroup, pass, groupDefinitionIndex );

        if( !sequenceGroup.data.sourceGroupDataObj )
          throw("Error: pass '" + sequenceData.renderDataPasses[sourcePass].name + "' group '" + sequenceData.renderDataPasses[sourcePass].groups[i].name + "' refers to an undefined source group '" + sequenceData.renderDataPasses[sourcePass].groups[i].sourceGroup + "'" );
        if( pass === thisObj && groupDefinitionIndex > i )
          throw("Error: pass '" + sequenceData.renderDataPasses[sourcePass].name + "' group '" + sequenceData.renderDataPasses[sourcePass].groups[i].name + "' refers to a source group which is defined afterward: '" + sequenceData.renderDataPasses[sourcePass].groups[i].sourceGroup + "'" );
      }
      if( sequenceData.renderDataPasses[sourcePass].groups[i].subGroup ) {
        sequenceGroup.data.sourceGroupDataObj = this.parentSequenceApplyOp.data.group;
        sequenceGroup.data.subGroup = true;
      }

      if( sequenceData.renderDataPasses[sourcePass].groups[i].complementGroup ) {
        //For the complement, however, just look at this level
        Size j;
        Size complementGroupIndex;
        for( j = 0; j < numGroups; ++j ) {
          if( j == i )
            continue;
          if( sequenceData.renderDataPasses[sourcePass].groups[i].complementGroup == sequenceData.renderDataPasses[sourcePass].groups[j].name ) {
            sequenceGroup.data.complementGroupDataObj = this.groupDatas[j];
            complementGroupIndex = j;
            break;
          }
        }
        if( !sequenceGroup.data.complementGroupDataObj )
          throw("Error: pass '" + sequenceData.renderDataPasses[sourcePass].name + "' group '" + sequenceData.renderDataPasses[sourcePass].groups[i].name + "' refers to an undefined complement group '" + sequenceData.renderDataPasses[sourcePass].groups[i].complementGroup + "'" );
        if( j < i )
          throw("Error: pass '" + sequenceData.renderDataPasses[sourcePass].name + "' group '" + sequenceData.renderDataPasses[sourcePass].groups[i].name + "' refers to a complement group which is defined before: '" + sequenceData.renderDataPasses[sourcePass].groups[i].sourceGroup + "'" );

        if( sequenceData.renderDataPasses[sourcePass].groups[i].subGroup )
          this.groupDatas[complementGroupIndex].data.subGroup = true;
      }
      sequenceGroup.data.init( sequenceData, this );
    }

    //Initialize applyOps
    for( Size i = 0; i < numApplyOps; ++i ) {
      UInt32 sequenceApplyIndex;
      if( sequenceData.applyOpsDataIndexPool.getFreeIndex( sequenceApplyIndex ) ) {
        sequenceData.applyOpsData.resize( sequenceData.applyOpsDataIndexPool.getIndexEnd() );
        sequenceData.applyOpsData[sequenceApplyIndex] = ApplyDataObj();
        sequenceData.applyOpsData[sequenceApplyIndex].poolIndex = sequenceApplyIndex;
        sequenceData.applyOpsData[sequenceApplyIndex].data.selfObj = sequenceData.applyOpsData[sequenceApplyIndex];
      }
      Ref<ApplyDataObj> applyData = sequenceData.applyOpsData[sequenceApplyIndex];

      this.applyDatas.push(applyData);

      applyData.data.sequencePassDataObj = thisObj;
      applyData.data.sourcePassApplyIndex = i;
      applyData.initStats( sequenceData );

      applyData.data.initialize(sequenceData, this, thisObj, parentParams, renderTarget);
    }
  }
  this.parentApplyOpMemberIndex = applyOpMemberIndex;
  this.numParamLayers = parentParams.getNumLayers();

  Size nextPassOrder = 0;
  Size nextApplyOpIndex = 0;
  Size nextGroupIndex = 0;
  Boolean parentHasPerMemberPass = this.privatePerMemberPassGroup;
  Boolean parentHasNewGroup = Boolean(this.parentSequenceApplyOp) && !this.parentSequenceApplyOp.data.inheritedGroup;

  if(this.privatePerMemberPassGroup)
    this.privatePerMemberPassGroup.data.memberSourceGroupMapping[0] = applyOpMemberIndex;

  Ref<ApplyDataObj> parentSequenceApplyOp = this.parentSequenceApplyOp;
  Boolean conditionMatched = false;
  for( Size i = 0; i < numGroups + numApplyOps; ++i ) {
    Size nextApplyPassOrder = InvalidIndex;
    Ref<ApplyDataObj> nextSequenceApply;
    if( nextApplyOpIndex < numApplyOps ) {
      nextSequenceApply = this.applyDatas[nextApplyOpIndex];
      nextApplyPassOrder = nextSequenceApply.data.sequencePassOrder;
    }

    Size nextGroupPassOrder = InvalidIndex;
    Ref<GroupDataObj> nextSequenceGroup;
    if( nextGroupIndex < numGroups ) {
      nextSequenceGroup = this.groupDatas[nextGroupIndex];
      nextGroupPassOrder = nextSequenceGroup.data.sequencePassOrder;
    }

    if( i == nextGroupPassOrder ) {
      if( nextApplyOpIndex != 0 && !nextSequenceGroup.data.subGroup ) {//Only if at least 1 apply was evaluated
        nextSequenceGroup.data.ownerInstanceLayers.update( sequenceData, this.ownerInstanceIndex, true, this.passOrderStack, i, null );
        if( nextSequenceGroup.data.ownerInstanceLayers.layers.size() || nextSequenceGroup.data.parentParamsWithOwnerInstanceLayers.getNumLayers() ) {
          Size nextTargetLayer = 0;
          if( parentSequenceApplyOp ) {
            for( Size j = 0; j < parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams.getNumLayers(); ++j )
              nextSequenceGroup.data.parentParamsWithOwnerInstanceLayers.setLayer( nextTargetLayer++, parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams.layers[j] );
          } else {
            for( Size j = 0; j < parentParams.getNumLayers(); ++j )
              nextSequenceGroup.data.parentParamsWithOwnerInstanceLayers.setLayer( nextTargetLayer++, parentParams.layers[j] );
          }
          for( Size j = 0; j < nextSequenceGroup.data.ownerInstanceLayers.layers.size(); ++j )
            nextSequenceGroup.data.parentParamsWithOwnerInstanceLayers.setLayer( nextTargetLayer++, nextSequenceGroup.data.ownerInstanceLayers.layers[j] );
        }
      }
      if( nextSequenceGroup.data.parentParamsWithOwnerInstanceLayers.getNumLayers() )
        nextSequenceGroup.data.update( sequenceData, this, nextSequenceGroup, nextSequenceGroup.data.parentParamsWithOwnerInstanceLayers );
      else if( Boolean(parentSequenceApplyOp) && !nextSequenceGroup.data.subGroup )
        nextSequenceGroup.data.update( sequenceData, this, nextSequenceGroup, parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams );
      else
        nextSequenceGroup.data.update( sequenceData, this, nextSequenceGroup, parentParams );

      if( nextSequenceGroup.data.generationCount == sequenceData.generationCount )
        somethingChanged = true;
      ++nextGroupIndex;

    } else if( i == nextApplyPassOrder ) {
      Ref<ApplyDataObj> sequenceApply = nextSequenceApply;
      //First, determine if the pass is enabled (flags, condition)
      Boolean wasDisabled = sequenceApply.data.disabled;
      Boolean isElse = sequenceApply.data.isElse;
      if( !isElse )
        conditionMatched = false;

      if( sequenceApply.data.isElse )
        sequenceApply.data.disabled = conditionMatched;
      else
        sequenceApply.data.disabled = false;

      if( nextApplyOpIndex != 0 && !sequenceApply.data.inheritedGroup ) {//Only if at least 1 apply was evaluated
        sequenceApply.data.ownerInstanceLayers.update( sequenceData, this.ownerInstanceIndex, true, this.passOrderStack, i, null );
        if( sequenceApply.data.ownerInstanceLayers.layers.size() || sequenceApply.data.parentParamsWithOwnerInstanceLayers.getNumLayers() ) {
          Size nextTargetLayer = 0;
          if( parentSequenceApplyOp ) {
            for( Size j = 0; j < parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams.getNumLayers(); ++j )
              sequenceApply.data.parentParamsWithOwnerInstanceLayers.setLayer( nextTargetLayer++, parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams.layers[j] );
          } else {
            for( Size j = 0; j < parentParams.getNumLayers(); ++j )
              sequenceApply.data.parentParamsWithOwnerInstanceLayers.setLayer( nextTargetLayer++, parentParams.layers[j] );
          }
          for( Size j = 0; j < sequenceApply.data.ownerInstanceLayers.layers.size(); ++j )
            sequenceApply.data.parentParamsWithOwnerInstanceLayers.setLayer( nextTargetLayer++, sequenceApply.data.ownerInstanceLayers.layers[j] );
        }
      }
      if( sequenceApply.data.parentParamsWithOwnerInstanceLayers.getNumLayers() )
        sequenceApply.data.update( sequenceData, this, thisObj, sequenceApply, sequenceApply.data.parentParamsWithOwnerInstanceLayers, applyOpMemberIndex, renderTarget, wasDisabled || !initialized);
      else if( Boolean(parentSequenceApplyOp) && !sequenceApply.data.inheritedGroup )
        sequenceApply.data.update( sequenceData, this, thisObj, sequenceApply, parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams, applyOpMemberIndex, renderTarget, wasDisabled || !initialized);
      else
        sequenceApply.data.update( sequenceData, this, thisObj, sequenceApply, parentParams, applyOpMemberIndex, renderTarget, wasDisabled || !initialized);
      //Recurse into applyOp
      Boolean applyOpChanged = wasDisabled != sequenceApply.data.disabled || sequenceApply.data.generationCount == sequenceData.generationCount;
      if(!sequenceApply.data.disabled) {
        for( Size j = 0; j < sequenceApply.data.applyMembersData.size(); ++j ) {
          if( !sequenceApply.data.applyMembersData[j].skipBecauseOfUpdateInterval ) {
            Ref<SequencePassDataObj> sequencePassRef = sequenceApply.data.applyMembersData[j].memberSubPassObj;
            if( sequencePassRef ) {
              if( Boolean(parentSequenceApplyOp) && !sequenceApply.data.inheritedGroup )
                sequencePassRef.data.update( sequenceData, sequencePassRef, parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams, j, sequenceApply.data.applyMembersData[j].renderTargetInstanceStoredData);
              else
                sequencePassRef.data.update( sequenceData, sequencePassRef, parentParams, j, sequenceApply.data.applyMembersData[j].renderTargetInstanceStoredData);

              if( sequencePassRef.data.generationCount == sequenceData.generationCount ) {
                sequenceApply.data.applyMembersData[j].generationCount = sequenceData.generationCount;
                applyOpChanged = true;
              }
            }
            if( sequenceApply.data.applyMembersData[j].generationCount == sequenceData.generationCount )
              applyOpChanged = true;
          }
        }
        if( sequenceApply.data.applySubPassObj ) {
          Ref<SequencePassDataObj> subPass = sequenceApply.data.applySubPassObj;
          if( Boolean(parentSequenceApplyOp) && !sequenceApply.data.inheritedGroup )
            subPass.data.update( sequenceData, subPass, parentSequenceApplyOp.data.applyMembersData[applyOpMemberIndex].allParams, 0, sequenceApply.data.applyMembersData[0].renderTargetInstanceStoredData);
          else
            subPass.data.update( sequenceData, subPass, parentParams, 0, sequenceApply.data.applyMembersData[0].renderTargetInstanceStoredData);

          if( subPass.data.generationCount == sequenceData.generationCount )
            applyOpChanged = true;
        }
      }
      if( applyOpChanged ) {
        sequenceApply.data.generationCount = sequenceData.generationCount;
        somethingChanged = true;
      }

      //If this Apply has its own render target && something changed: ensure the instance data render targets has an incremented value version
      if( sequenceApply.data.ownedFramebufferID ) {
        if( sequenceApply.data.generationCount == sequenceData.generationCount ) {
          for( Size j = 0; j < sequenceApply.data.applyMembersData.size(); ++j )
            sequenceApply.data.applyMembersData[j].updateRenderTargetVersion( sequenceData, sequenceApply.data );
        }
      }

      if( !conditionMatched )
        conditionMatched = !sequenceApply.data.disabled;
      ++nextApplyOpIndex;
    } else
      throw("Unexpected: no group or apply with pass order "+i);
  }

  if( somethingChanged )
    this.generationCount = sequenceData.generationCount;

  this.initialized = true;

  if( sequenceData.enableProfiling )
    this.profileEnd = getCurrentTicks();
}

function SequencePassData.buildDrawSequence!( io RenderSequenceDataStruct sequenceData ) {
  for( Size i = 0; i < this.applyDatas.size(); ++i ) {
    Ref<ApplyDataObj> sequenceApply = this.applyDatas[i];
    Boolean hasMembers = sequenceApply.data.applyMembersData.size() > 0 || !sequenceApply.data.group;
    if( hasMembers && !sequenceApply.data.disabled ) {
      Boolean hasRenderTarget = sequenceApply.data.ownedFramebufferID != 0 && !sequenceApply.data.hasSharedRenderTargets;
      if( !hasRenderTarget || sequenceApply.data.generationCount == sequenceData.generationCount ) {
        ApplyOpSequenceElement seqElt;
        seqElt.onlyPostDrawCallbacks = false;
        seqElt.applyData = sequenceApply;
        sequenceData.applyOpsSequence.push(seqElt);

        Ref<SequencePassDataObj> subPass;
        if( sequenceApply.data.applySubPassObj )
          subPass = sequenceApply.data.applySubPassObj;

        if( sequenceApply.data.applySourcePassIndex ) {
          for( Size j = 0; j < sequenceApply.data.applyMembersData.size(); ++j ) {
            Ref<SequencePassDataObj> sequencePassRef = sequenceApply.data.applyMembersData[j].memberSubPassObj;

            if( (Boolean(sequencePassRef) || Boolean(subPass) ) && ( !hasRenderTarget || sequenceApply.data.applyMembersData[j].generationCount == sequenceData.generationCount ) ) {
              sequenceApply.data.applyMembersData[j].noDraw = false;
              if( sequencePassRef )
                sequencePassRef.data.buildDrawSequence( sequenceData );
            } else
              sequenceApply.data.applyMembersData[j].noDraw = true;
          }
        }
        if( subPass )
          subPass.data.buildDrawSequence( sequenceData );

        if( sequenceApply.data.hasPostDrawCallback ) {
          seqElt.onlyPostDrawCallbacks = true;
          sequenceData.applyOpsSequence.push(seqElt);
        }
      }
    }
  }
}

function String RenderSequenceDataStruct.getDesc?( String indent, Boolean reportGroupMemberIndices, Boolean reportGroupMemberNames, Boolean reportGroupMemberParamLayers ) {
  String desc = "RenderSequenceDataStruct passes:\n";
  for( Size i = 0; i < this.applyOpsSequence.size(); ++i ) {
    desc += i + ": " + this.applyOpsSequence[i].applyData.data.getDesc( this, "  "+indent, reportGroupMemberIndices, reportGroupMemberNames, reportGroupMemberParamLayers );
  }
  return desc;
}

function RenderSequenceDataStruct.cleanup!() {
  if( this.passesDataIndexPool.getNumUsed() >= 2 ) {
    //Cleanup
    this.passesData[1].cleanup( this );

    this.releaseFramebuffers();
    this.releaseTextures();
  }
}

function ~RenderSequenceDataStruct() {
  this.cleanup();
}

function RenderSequenceDataStruct.update!( 
  Ref<RenderSequenceData> selfObj,
  RenderData renderData, 
  _RTRUserCallbackFunctions functionCaller,
  UInt32 targetDrawBuffer, 
  RenderParams viewportParams,
  String startPassName )
  {
  if( this.wrongGLVersion )
    return;

  this.enableProfiling = false;
  UInt64 profileStart;
  if( this.enableProfiling )
    profileStart = getCurrentTicks();

  //TODO: dirtify if different
  ++this.generationCount;
  Boolean allDirty = !this.renderData;
  if( synchronizeVersion( renderData.data.dataLayoutGenerationCount, this.renderDataLayoutGenerationCount ) 
   || (startPassName != '' && this.startPassName != startPassName)) {
    //Instance indices have changed...
    allDirty = true;
  }
  if( allDirty ) {
    String GLVersion;
    glGetVersion(GLVersion);
    if( GLVersion < "3.2" ) {
      report("Disabling OpenGL rendering: Creation Platform requires at least OpenGL 3.2, and the current OpenGL version is "+GLVersion);
      this.wrongGLVersion = true;
      return;
    } else if( this.generationCount == 1 )
      report("Running on OpenGL version "+GLVersion);

    UInt32 genCount = this.generationCount;

    this.cleanup();
    this = RenderSequenceDataStruct();
    this.selfObj = selfObj;

    this.renderDataLayoutGenerationCount = renderData.data.dataLayoutGenerationCount;
    this.nextRequestID = 1;
    this.generationCount = genCount;

    this.startPassName = startPassName;

    if( this.startPassName != '' ) {
      if( !renderData.data.primitiveNameToIndex[OwnerType_pass].has( this.startPassName ) )
        throw("Error: start pass " + startPassName + " not found in RenderDataStruct" );
      else
        this.startPassIndex = renderData.data.primitiveNameToIndex[OwnerType_pass][this.startPassName];
    }
    this.renderData = renderData;

    this.renderDataPrimitives = renderData.data.primitives;
    this.renderDataInstances = renderData.data.instances;
    this.renderDataPasses = renderData.data.passes;
    this.renderDataPassFunctionKeys = renderData.data.passFunctionKeys;

  }
  this.functionCaller = functionCaller;

  if( this.startPassIndex == 0 ) {
    throw("Error: start pass was not defined");
  }

  this.prevInstanceCount = this.instancesStoredData.size();
  Size newInstanceCount = renderData.data.instances.size();

  this.instancesStoredData.resize( newInstanceCount );
  this.tempInstanceBits1.resize( newInstanceCount );
  this.tempInstanceBits2.resize( newInstanceCount );
  this.tempInstanceBits3.resize( newInstanceCount );
  this.tempSizeOneIntegerArray.resize(1);
  this.tempInstanceValues.resize( newInstanceCount );

  for( Size i = this.prevInstanceCount; i < newInstanceCount; ++i ) {
    this.tempInstanceValues[i] = InvalidIndex;
    this.instancesStoredData[i].instanceIndex = i;
  }

  if( allDirty ) {
    //TODO: properly cleanup fbos and textures recursively

    //Set some initial params.
    //TODO: be able to specify arbitrary params & values in the passes XML
    this.initialParams = renderData.data.staticParams;

    //Burn into initialParams all constants

    UInt32 dummy;
    this.groupsData.resize(1);//Reserve 0 as 'null'
    this.groupsDataIndexPool.reset();
    this.groupsDataIndexPool.getFreeIndex( dummy );

    this.applyOpsDataIndexPool.reset();

    this.passesData.resize(2);//Reserve 0 as 'null'
    this.passesData[1] = SequencePassDataObj();
    this.passesData[1].poolIndex = 1;

    this.passesDataIndexPool.reset();
    this.passesDataIndexPool.getFreeIndex( dummy );
    this.passesDataIndexPool.getFreeIndex( dummy );

    this.passesData[1].data.sourcePassIndex = this.startPassIndex;
    this.passesData[1].data.sequenceDataObj = selfObj;

    this.passesData[1].data.ownerPrimIndex = 0;//No owner (initial pass)
    this.passesData[1].data.ownerInstanceIndex = 0;//No owner (initial pass)
    this.passesData[1].data.parentSequencePassObj = null;//No owner (initial pass)
    this.passesData[1].data.parentSequenceApplyOp = null;
  }

  this.targetDrawBuffer = targetDrawBuffer;

  Size numStaticParamsLayers = renderData.data.staticParams.getNumLayers();
  Size numViewportLayers = viewportParams.getNumLayers();
  for( Size i = 0; i < numViewportLayers; ++i )
    this.initialParams.setLayer( i+numStaticParamsLayers, viewportParams.layers[i] );

  this.globalParamsLayerStart = numStaticParamsLayers-1;//Last layer only
  this.globalParamsLayerEnd = numStaticParamsLayers+numViewportLayers;

  if( allDirty ) {
    if( !this.viewportWidthKey.isValid() )
      this.viewportWidthKey = this.initialParams.getKey( renderData.data.widthParamString );

    if( !this.viewportHeightKey.isValid() )
      this.viewportHeightKey = this.initialParams.getKey( renderData.data.heightParamString );
  }

  this.selfStats = selfObj.autoStats;
  this.enableStatistics = this.selfStats;
  this.passesData[1].data.update( this, this.passesData[1], this.initialParams, 0, null );

  if( this.passesData[1].data.generationCount == this.generationCount ) {
    this.applyOpsSequence.resize(0);
    this.passesData[1].data.buildDrawSequence( this );
  }
  if( false ) {
    if( this.generationCount == 1 ) {
      report("*********************************************");
      report("RENDER DATA:");
      String filters[];
      //report( this.getInstancesDesc("", true, true, true, filters ) );
      report("*********************************************");
      report("RENDER SEQUENCE:");
      report( this.getDesc("", false, false, false ) );
    }
  }

  if( this.enableProfiling ) {
    UInt64 profileEnd = getCurrentTicks();
    report("PROFILING: RenderSequenceDataStruct.update: "+ Size(getSecondsBetweenTicks(profileStart, profileEnd)*1000000.0) + '\n' + this.passesData[1].data.getProfilingDesc('  ', this));
  }
}

function RenderSequenceData.update!( 
  RenderData renderData, 
  _RTRUserCallbackFunctions functionCaller,
  UInt32 targetDrawBuffer, 
  RenderParams viewportParams,
  String startPassName ) {
  if( FabricStatisticsEnabled() && !this.autoStats )
    this.autoStats = StatisticsAutoRegisterMember(this);

  this.data.update(
    this,
    renderData, 
    functionCaller,
    targetDrawBuffer, 
    viewportParams,
    startPassName);
}
