/*
 *  Copyright 2010-2012 Fabric Engine Inc. All rights reserved.
 */

/*SPHINX-description
The :ref:`solveNCFIK` computes the solutio nfor an N-Bone chain without iteration, using the initial pose of the chain as a hit to aid in the definition of the solution.

A detailed description of the algorithm can be found inthe Game Programming Gems 8 book. 

Arguments
----------
=============== ============ =====================================
Name            Type         Description
=============== ============ =====================================
pose            Xfo[]        The initial pose of the chain. Often defined by a reference pose, or a pose generated by an animation system. 
boneLengths     Scalar[]     The lengths of the joints in the chain. 
boneLengths     Vec3[]       The unit vectors that represent the vector connecting the joint to its child. 
goalPosition    Vec3         The goal position that the chain will be solved towards.
=============== ============ =====================================


 */

require Math;
require Animation;

function Scalar sq(Scalar v) {
  return v * v;
}

function solveNCFIK(
  io Xfo pose[],
  in Scalar boneLengths[],
  in Vec3 boneVectors[],
  in Vec3 goalPosition
) {

  Integer boneIndex, lastBoneIndex = pose.size-1;
  Scalar distToIkGoal, distToFkChainTip, remainingChainLength = 0;
  Scalar fkBoneAngle, ikBoneAngle, deltaBoneAngle;
  Scalar maxFkBoneAngle, maxIkBoneAngle;
  Vec3 chainRootPos, vecToIkGoal, vecToFkChainTip, fkChainTip;
  Quat boneOffsetRotation, chainOffsetRotation;
  Xfo boneXfo, boneParentXfo;

  fkChainTip = pose[lastBoneIndex].transformVector(boneVectors[lastBoneIndex] * boneLengths[lastBoneIndex]);
  chainRootPos = pose[0].tr;

  for (Integer i = 0; i < boneLengths.size(); i++) {
    // Note: Scaling of bones is currently not supported. 
    remainingChainLength += abs(boneLengths[i] /* pose[i].sc.x*/);
  }

  // Apply the soft limit to the distance to the IK goal
  vecToIkGoal = goalPosition - chainRootPos;
  distToIkGoal = vecToIkGoal.length();

  for (Integer i = 0; i < pose.size(); i++) {
    boneIndex = i;
    boneXfo = pose[i];
    if (i == 0) {
      vecToFkChainTip = fkChainTip - boneXfo.tr;
    }
    else {
      // Transform the bone position by the overall chain offset.
      vecToFkChainTip = fkChainTip - (chainRootPos + (chainOffsetRotation.rotateVector((boneXfo.tr - chainRootPos))));

      // Calculate a new pose position based on the parent bones new orientation
      boneXfo.tr = pose[i-1].transformVector(boneVectors[i-1] * boneLengths[i-1]);
    }
    distToFkChainTip = vecToFkChainTip.length();
    vecToFkChainTip *= 1.0 / distToFkChainTip;

    vecToIkGoal = goalPosition - boneXfo.tr;
    distToIkGoal = vecToIkGoal.length();
    vecToIkGoal *= 1.0 / distToIkGoal; // normalize the vector
    Scalar boneLength = abs(boneLengths[i] /* boneXfo.sc.x*/);

    if (i == 0) {
      // For the first bone calculate and store the overall chain offset towards the ik target
      chainOffsetRotation.setFrom2Vectors(vecToFkChainTip, vecToIkGoal);
    
      fkChainTip = boneXfo.tr + (vecToIkGoal * distToFkChainTip);
      boneXfo.ori = chainOffsetRotation * boneXfo.ori;
    }
    else {
      // Apply the chain offset, and apply any incremental correction.
      // This additional correction is required due to a new bone position based on the new parent orientation
      boneOffsetRotation.setFrom2Vectors(vecToFkChainTip, vecToIkGoal);
      boneXfo.ori = boneOffsetRotation * chainOffsetRotation * boneXfo.ori;
    }

    // Based on the bone index, select an appropriate method to solve
    if (i <= (pose.size() - 2)) {
      // Remove the current bones length from the chain.
      remainingChainLength -= boneLength;
      Vec3 boneLengthVector;
      //if(boneLengths[i] < 0.0 /* || boneXfo.sc.x < 0.0*/)
      //  boneLengthVector = boneXfo.ori.rotateVector(Vec3(-1.0, 0.0, 0.0));
      //else
        boneLengthVector = boneXfo.ori.rotateVector(boneVectors[i]);
      
      // this is the current angle of the bone.
      fkBoneAngle = acos(Math_clamp(boneLengthVector.dot(vecToIkGoal), -1.0, 1.0));

      if(fkBoneAngle < 0.0001){
        // If the bone is already pointing directly at the target, we can't work with it.
        // in debug mode, report and error...
        continue;
      }
      
      Vec3 bendAxis = vecToIkGoal.cross(boneLengthVector);
      bendAxis.setUnit();
      
      if (i == (pose.size() - 2)) {
        // Use trigonometry to determine the ikBoneAngle
        // Law of cosines. a = BoneLength; b = Child BoneLength; c = Distance to the Ik Goal;
        ikBoneAngle = acos(Math_clamp((sq(boneLength) + sq(distToIkGoal) - sq(remainingChainLength)) / (2.0 * boneLength * distToIkGoal), - 1.0, 1.0));
      }
      else {

        // distance from the bone tip to the ik gloal
        if (distToFkChainTip > remainingChainLength) {
          // Using the law of cosines, calculate the maximum angle of this bone using the fk Chain tip
          maxFkBoneAngle = acos(Math_clamp((sq(boneLength) + sq(distToFkChainTip) - sq(remainingChainLength)) / (2.0 * boneLength * distToFkChainTip), - 1.0, 1.0));
        }
        else {
          // Add on the remaining chain length as radians.
          maxFkBoneAngle = acos(Math_clamp((boneLength * 0.5) / remainingChainLength, 0.0, 1.0));
          maxFkBoneAngle += (remainingChainLength - distToFkChainTip) / boneLength;
        }

        // distance from the bone tip to the ik gloal
        if (distToIkGoal > remainingChainLength) {
          // Using the law of cosines, calculate the maximum angle of this bone using the fk Chain tip
          maxIkBoneAngle = acos(Math_clamp((sq(boneLength) + sq(distToIkGoal) - sq(remainingChainLength)) / (2.0 * boneLength * distToIkGoal), - 1.0, 1.0));
        }
        else {
          // Add on the remaining chain length as radians.
          maxIkBoneAngle = acos(Math_clamp((boneLength * 0.5) / remainingChainLength, 0.0, 1.0));
          maxIkBoneAngle += (remainingChainLength - distToIkGoal) / boneLength;
        }

        ikBoneAngle = maxIkBoneAngle * (fkBoneAngle / maxFkBoneAngle);
      }

      // Subtract off the current angle the bone has with the vecToIkGoal to keep the delta
      deltaBoneAngle = (ikBoneAngle - fkBoneAngle);

      // Apply the rotation to the current bones
      Quat offset;
      offset.setFromAxisAndAngle(bendAxis, deltaBoneAngle);
      boneXfo.ori = offset * boneXfo.ori;
      
    }

    pose[boneIndex] = boneXfo;
  }
}

